// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pokerth.proto

#ifndef PROTOBUF_pokerth_2eproto__INCLUDED
#define PROTOBUF_pokerth_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pokerth_2eproto();
void protobuf_AssignDesc_pokerth_2eproto();
void protobuf_ShutdownFile_pokerth_2eproto();

class NetGameInfo;
class PlayerResult;
class AnnounceMessage;
class AnnounceMessage_Version;
class InitMessage;
class AuthServerChallengeMessage;
class AuthClientResponseMessage;
class AuthServerVerificationMessage;
class InitAckMessage;
class AvatarRequestMessage;
class AvatarHeaderMessage;
class AvatarDataMessage;
class AvatarEndMessage;
class UnknownAvatarMessage;
class PlayerListMessage;
class GameListNewMessage;
class GameListUpdateMessage;
class GameListPlayerJoinedMessage;
class GameListPlayerLeftMessage;
class GameListAdminChangedMessage;
class PlayerInfoRequestMessage;
class PlayerInfoReplyMessage;
class PlayerInfoReplyMessage_PlayerInfoData;
class PlayerInfoReplyMessage_PlayerInfoData_AvatarData;
class SubscriptionRequestMessage;
class JoinExistingGameMessage;
class JoinNewGameMessage;
class RejoinExistingGameMessage;
class JoinGameAckMessage;
class JoinGameFailedMessage;
class GamePlayerJoinedMessage;
class GamePlayerLeftMessage;
class GameAdminChangedMessage;
class RemovedFromGameMessage;
class KickPlayerRequestMessage;
class LeaveGameRequestMessage;
class InvitePlayerToGameMessage;
class InviteNotifyMessage;
class RejectGameInvitationMessage;
class RejectInvNotifyMessage;
class StartEventMessage;
class StartEventAckMessage;
class GameStartInitialMessage;
class GameStartRejoinMessage;
class GameStartRejoinMessage_RejoinPlayerData;
class HandStartMessage;
class HandStartMessage_PlainCards;
class PlayersTurnMessage;
class MyActionRequestMessage;
class YourActionRejectedMessage;
class PlayersActionDoneMessage;
class DealFlopCardsMessage;
class DealTurnCardMessage;
class DealRiverCardMessage;
class AllInShowCardsMessage;
class AllInShowCardsMessage_PlayerAllIn;
class EndOfHandShowCardsMessage;
class EndOfHandHideCardsMessage;
class ShowMyCardsRequestMessage;
class AfterHandShowCardsMessage;
class EndOfGameMessage;
class PlayerIdChangedMessage;
class AskKickPlayerMessage;
class AskKickDeniedMessage;
class StartKickPetitionMessage;
class VoteKickRequestMessage;
class VoteKickReplyMessage;
class KickPetitionUpdateMessage;
class EndKickPetitionMessage;
class StatisticsMessage;
class StatisticsMessage_StatisticsData;
class ChatRequestMessage;
class ChatMessage;
class ChatRejectMessage;
class DialogMessage;
class TimeoutWarningMessage;
class ResetTimeoutMessage;
class ReportAvatarMessage;
class ReportAvatarAckMessage;
class ReportGameMessage;
class ReportGameAckMessage;
class ErrorMessage;
class PokerTHMessage;

enum NetGameInfo_NetGameType {
  NetGameInfo_NetGameType_normalGame = 1,
  NetGameInfo_NetGameType_registeredOnlyGame = 2,
  NetGameInfo_NetGameType_inviteOnlyGame = 3,
  NetGameInfo_NetGameType_rankingGame = 4
};
bool NetGameInfo_NetGameType_IsValid(int value);
const NetGameInfo_NetGameType NetGameInfo_NetGameType_NetGameType_MIN = NetGameInfo_NetGameType_normalGame;
const NetGameInfo_NetGameType NetGameInfo_NetGameType_NetGameType_MAX = NetGameInfo_NetGameType_rankingGame;
const int NetGameInfo_NetGameType_NetGameType_ARRAYSIZE = NetGameInfo_NetGameType_NetGameType_MAX + 1;

enum NetGameInfo_RaiseIntervalMode {
  NetGameInfo_RaiseIntervalMode_raiseOnHandNum = 1,
  NetGameInfo_RaiseIntervalMode_raiseOnMinutes = 2
};
bool NetGameInfo_RaiseIntervalMode_IsValid(int value);
const NetGameInfo_RaiseIntervalMode NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_MIN = NetGameInfo_RaiseIntervalMode_raiseOnHandNum;
const NetGameInfo_RaiseIntervalMode NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_MAX = NetGameInfo_RaiseIntervalMode_raiseOnMinutes;
const int NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_ARRAYSIZE = NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_MAX + 1;

enum NetGameInfo_EndRaiseMode {
  NetGameInfo_EndRaiseMode_doubleBlinds = 1,
  NetGameInfo_EndRaiseMode_raiseByEndValue = 2,
  NetGameInfo_EndRaiseMode_keepLastBlind = 3
};
bool NetGameInfo_EndRaiseMode_IsValid(int value);
const NetGameInfo_EndRaiseMode NetGameInfo_EndRaiseMode_EndRaiseMode_MIN = NetGameInfo_EndRaiseMode_doubleBlinds;
const NetGameInfo_EndRaiseMode NetGameInfo_EndRaiseMode_EndRaiseMode_MAX = NetGameInfo_EndRaiseMode_keepLastBlind;
const int NetGameInfo_EndRaiseMode_EndRaiseMode_ARRAYSIZE = NetGameInfo_EndRaiseMode_EndRaiseMode_MAX + 1;

enum AnnounceMessage_ServerType {
  AnnounceMessage_ServerType_serverTypeLAN = 0,
  AnnounceMessage_ServerType_serverTypeInternetNoAuth = 1,
  AnnounceMessage_ServerType_serverTypeInternetAuth = 2
};
bool AnnounceMessage_ServerType_IsValid(int value);
const AnnounceMessage_ServerType AnnounceMessage_ServerType_ServerType_MIN = AnnounceMessage_ServerType_serverTypeLAN;
const AnnounceMessage_ServerType AnnounceMessage_ServerType_ServerType_MAX = AnnounceMessage_ServerType_serverTypeInternetAuth;
const int AnnounceMessage_ServerType_ServerType_ARRAYSIZE = AnnounceMessage_ServerType_ServerType_MAX + 1;

enum InitMessage_LoginType {
  InitMessage_LoginType_guestLogin = 0,
  InitMessage_LoginType_authenticatedLogin = 1,
  InitMessage_LoginType_unauthenticatedLogin = 2
};
bool InitMessage_LoginType_IsValid(int value);
const InitMessage_LoginType InitMessage_LoginType_LoginType_MIN = InitMessage_LoginType_guestLogin;
const InitMessage_LoginType InitMessage_LoginType_LoginType_MAX = InitMessage_LoginType_unauthenticatedLogin;
const int InitMessage_LoginType_LoginType_ARRAYSIZE = InitMessage_LoginType_LoginType_MAX + 1;

enum PlayerListMessage_PlayerListNotification {
  PlayerListMessage_PlayerListNotification_playerListNew = 0,
  PlayerListMessage_PlayerListNotification_playerListLeft = 1
};
bool PlayerListMessage_PlayerListNotification_IsValid(int value);
const PlayerListMessage_PlayerListNotification PlayerListMessage_PlayerListNotification_PlayerListNotification_MIN = PlayerListMessage_PlayerListNotification_playerListNew;
const PlayerListMessage_PlayerListNotification PlayerListMessage_PlayerListNotification_PlayerListNotification_MAX = PlayerListMessage_PlayerListNotification_playerListLeft;
const int PlayerListMessage_PlayerListNotification_PlayerListNotification_ARRAYSIZE = PlayerListMessage_PlayerListNotification_PlayerListNotification_MAX + 1;

enum SubscriptionRequestMessage_SubscriptionAction {
  SubscriptionRequestMessage_SubscriptionAction_unsubscribeGameList = 1,
  SubscriptionRequestMessage_SubscriptionAction_resubscribeGameList = 2
};
bool SubscriptionRequestMessage_SubscriptionAction_IsValid(int value);
const SubscriptionRequestMessage_SubscriptionAction SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_MIN = SubscriptionRequestMessage_SubscriptionAction_unsubscribeGameList;
const SubscriptionRequestMessage_SubscriptionAction SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_MAX = SubscriptionRequestMessage_SubscriptionAction_resubscribeGameList;
const int SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_ARRAYSIZE = SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_MAX + 1;

enum JoinGameFailedMessage_JoinGameFailureReason {
  JoinGameFailedMessage_JoinGameFailureReason_invalidGame = 1,
  JoinGameFailedMessage_JoinGameFailureReason_gameIsFull = 2,
  JoinGameFailedMessage_JoinGameFailureReason_gameIsRunning = 3,
  JoinGameFailedMessage_JoinGameFailureReason_invalidPassword = 4,
  JoinGameFailedMessage_JoinGameFailureReason_notAllowedAsGuest = 5,
  JoinGameFailedMessage_JoinGameFailureReason_notInvited = 6,
  JoinGameFailedMessage_JoinGameFailureReason_gameNameInUse = 7,
  JoinGameFailedMessage_JoinGameFailureReason_badGameName = 8,
  JoinGameFailedMessage_JoinGameFailureReason_invalidSettings = 9,
  JoinGameFailedMessage_JoinGameFailureReason_ipAddressBlocked = 10,
  JoinGameFailedMessage_JoinGameFailureReason_rejoinFailed = 11
};
bool JoinGameFailedMessage_JoinGameFailureReason_IsValid(int value);
const JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_MIN = JoinGameFailedMessage_JoinGameFailureReason_invalidGame;
const JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_MAX = JoinGameFailedMessage_JoinGameFailureReason_rejoinFailed;
const int JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_ARRAYSIZE = JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_MAX + 1;

enum GamePlayerLeftMessage_GamePlayerLeftReason {
  GamePlayerLeftMessage_GamePlayerLeftReason_leftOnRequest = 0,
  GamePlayerLeftMessage_GamePlayerLeftReason_leftKicked = 1,
  GamePlayerLeftMessage_GamePlayerLeftReason_leftError = 2
};
bool GamePlayerLeftMessage_GamePlayerLeftReason_IsValid(int value);
const GamePlayerLeftMessage_GamePlayerLeftReason GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_MIN = GamePlayerLeftMessage_GamePlayerLeftReason_leftOnRequest;
const GamePlayerLeftMessage_GamePlayerLeftReason GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_MAX = GamePlayerLeftMessage_GamePlayerLeftReason_leftError;
const int GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_ARRAYSIZE = GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_MAX + 1;

enum RemovedFromGameMessage_RemovedFromGameReason {
  RemovedFromGameMessage_RemovedFromGameReason_removedOnRequest = 0,
  RemovedFromGameMessage_RemovedFromGameReason_kickedFromGame = 1,
  RemovedFromGameMessage_RemovedFromGameReason_gameIsFull = 2,
  RemovedFromGameMessage_RemovedFromGameReason_gameIsRunning = 3,
  RemovedFromGameMessage_RemovedFromGameReason_gameTimeout = 4,
  RemovedFromGameMessage_RemovedFromGameReason_removedStartFailed = 5
};
bool RemovedFromGameMessage_RemovedFromGameReason_IsValid(int value);
const RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_MIN = RemovedFromGameMessage_RemovedFromGameReason_removedOnRequest;
const RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_MAX = RemovedFromGameMessage_RemovedFromGameReason_removedStartFailed;
const int RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_ARRAYSIZE = RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_MAX + 1;

enum RejectGameInvitationMessage_RejectGameInvReason {
  RejectGameInvitationMessage_RejectGameInvReason_rejectReasonNo = 0,
  RejectGameInvitationMessage_RejectGameInvReason_rejectReasonBusy = 1
};
bool RejectGameInvitationMessage_RejectGameInvReason_IsValid(int value);
const RejectGameInvitationMessage_RejectGameInvReason RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_MIN = RejectGameInvitationMessage_RejectGameInvReason_rejectReasonNo;
const RejectGameInvitationMessage_RejectGameInvReason RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_MAX = RejectGameInvitationMessage_RejectGameInvReason_rejectReasonBusy;
const int RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_ARRAYSIZE = RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_MAX + 1;

enum StartEventMessage_StartEventType {
  StartEventMessage_StartEventType_startEvent = 0,
  StartEventMessage_StartEventType_rejoinEvent = 1
};
bool StartEventMessage_StartEventType_IsValid(int value);
const StartEventMessage_StartEventType StartEventMessage_StartEventType_StartEventType_MIN = StartEventMessage_StartEventType_startEvent;
const StartEventMessage_StartEventType StartEventMessage_StartEventType_StartEventType_MAX = StartEventMessage_StartEventType_rejoinEvent;
const int StartEventMessage_StartEventType_StartEventType_ARRAYSIZE = StartEventMessage_StartEventType_StartEventType_MAX + 1;

enum YourActionRejectedMessage_RejectionReason {
  YourActionRejectedMessage_RejectionReason_rejectedInvalidGameState = 1,
  YourActionRejectedMessage_RejectionReason_rejectedNotYourTurn = 2,
  YourActionRejectedMessage_RejectionReason_rejectedActionNotAllowed = 3
};
bool YourActionRejectedMessage_RejectionReason_IsValid(int value);
const YourActionRejectedMessage_RejectionReason YourActionRejectedMessage_RejectionReason_RejectionReason_MIN = YourActionRejectedMessage_RejectionReason_rejectedInvalidGameState;
const YourActionRejectedMessage_RejectionReason YourActionRejectedMessage_RejectionReason_RejectionReason_MAX = YourActionRejectedMessage_RejectionReason_rejectedActionNotAllowed;
const int YourActionRejectedMessage_RejectionReason_RejectionReason_ARRAYSIZE = YourActionRejectedMessage_RejectionReason_RejectionReason_MAX + 1;

enum AskKickDeniedMessage_KickDeniedReason {
  AskKickDeniedMessage_KickDeniedReason_kickDeniedInvalidGameState = 0,
  AskKickDeniedMessage_KickDeniedReason_kickDeniedNotPossible = 1,
  AskKickDeniedMessage_KickDeniedReason_kickDeniedTryAgainLater = 2,
  AskKickDeniedMessage_KickDeniedReason_kickDeniedAlreadyInProgress = 3,
  AskKickDeniedMessage_KickDeniedReason_kickDeniedInvalidPlayerId = 4
};
bool AskKickDeniedMessage_KickDeniedReason_IsValid(int value);
const AskKickDeniedMessage_KickDeniedReason AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_MIN = AskKickDeniedMessage_KickDeniedReason_kickDeniedInvalidGameState;
const AskKickDeniedMessage_KickDeniedReason AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_MAX = AskKickDeniedMessage_KickDeniedReason_kickDeniedInvalidPlayerId;
const int AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_ARRAYSIZE = AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_MAX + 1;

enum VoteKickReplyMessage_VoteKickReplyType {
  VoteKickReplyMessage_VoteKickReplyType_voteKickAck = 0,
  VoteKickReplyMessage_VoteKickReplyType_voteKickDeniedInvalid = 1,
  VoteKickReplyMessage_VoteKickReplyType_voteKickDeniedAlreadyVoted = 2
};
bool VoteKickReplyMessage_VoteKickReplyType_IsValid(int value);
const VoteKickReplyMessage_VoteKickReplyType VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_MIN = VoteKickReplyMessage_VoteKickReplyType_voteKickAck;
const VoteKickReplyMessage_VoteKickReplyType VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_MAX = VoteKickReplyMessage_VoteKickReplyType_voteKickDeniedAlreadyVoted;
const int VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_ARRAYSIZE = VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_MAX + 1;

enum EndKickPetitionMessage_PetitionEndReason {
  EndKickPetitionMessage_PetitionEndReason_petitionEndEnoughVotes = 0,
  EndKickPetitionMessage_PetitionEndReason_petitionEndTooFewPlayers = 1,
  EndKickPetitionMessage_PetitionEndReason_petitionEndPlayerLeft = 2,
  EndKickPetitionMessage_PetitionEndReason_petitionEndTimeout = 3
};
bool EndKickPetitionMessage_PetitionEndReason_IsValid(int value);
const EndKickPetitionMessage_PetitionEndReason EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_MIN = EndKickPetitionMessage_PetitionEndReason_petitionEndEnoughVotes;
const EndKickPetitionMessage_PetitionEndReason EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_MAX = EndKickPetitionMessage_PetitionEndReason_petitionEndTimeout;
const int EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_ARRAYSIZE = EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_MAX + 1;

enum StatisticsMessage_StatisticsData_StatisticsType {
  StatisticsMessage_StatisticsData_StatisticsType_statNumberOfPlayers = 1
};
bool StatisticsMessage_StatisticsData_StatisticsType_IsValid(int value);
const StatisticsMessage_StatisticsData_StatisticsType StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_MIN = StatisticsMessage_StatisticsData_StatisticsType_statNumberOfPlayers;
const StatisticsMessage_StatisticsData_StatisticsType StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_MAX = StatisticsMessage_StatisticsData_StatisticsType_statNumberOfPlayers;
const int StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_ARRAYSIZE = StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_MAX + 1;

enum ChatMessage_ChatType {
  ChatMessage_ChatType_chatTypeLobby = 0,
  ChatMessage_ChatType_chatTypeGame = 1,
  ChatMessage_ChatType_chatTypeBot = 2,
  ChatMessage_ChatType_chatTypeBroadcast = 3,
  ChatMessage_ChatType_chatTypePrivate = 4
};
bool ChatMessage_ChatType_IsValid(int value);
const ChatMessage_ChatType ChatMessage_ChatType_ChatType_MIN = ChatMessage_ChatType_chatTypeLobby;
const ChatMessage_ChatType ChatMessage_ChatType_ChatType_MAX = ChatMessage_ChatType_chatTypePrivate;
const int ChatMessage_ChatType_ChatType_ARRAYSIZE = ChatMessage_ChatType_ChatType_MAX + 1;

enum TimeoutWarningMessage_TimeoutReason {
  TimeoutWarningMessage_TimeoutReason_timeoutNoDataReceived = 0,
  TimeoutWarningMessage_TimeoutReason_timeoutInactiveGame = 1,
  TimeoutWarningMessage_TimeoutReason_timeoutKickAfterAutofold = 2
};
bool TimeoutWarningMessage_TimeoutReason_IsValid(int value);
const TimeoutWarningMessage_TimeoutReason TimeoutWarningMessage_TimeoutReason_TimeoutReason_MIN = TimeoutWarningMessage_TimeoutReason_timeoutNoDataReceived;
const TimeoutWarningMessage_TimeoutReason TimeoutWarningMessage_TimeoutReason_TimeoutReason_MAX = TimeoutWarningMessage_TimeoutReason_timeoutKickAfterAutofold;
const int TimeoutWarningMessage_TimeoutReason_TimeoutReason_ARRAYSIZE = TimeoutWarningMessage_TimeoutReason_TimeoutReason_MAX + 1;

enum ReportAvatarAckMessage_ReportAvatarResult {
  ReportAvatarAckMessage_ReportAvatarResult_avatarReportAccepted = 0,
  ReportAvatarAckMessage_ReportAvatarResult_avatarReportDuplicate = 1,
  ReportAvatarAckMessage_ReportAvatarResult_avatarReportInvalid = 2
};
bool ReportAvatarAckMessage_ReportAvatarResult_IsValid(int value);
const ReportAvatarAckMessage_ReportAvatarResult ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_MIN = ReportAvatarAckMessage_ReportAvatarResult_avatarReportAccepted;
const ReportAvatarAckMessage_ReportAvatarResult ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_MAX = ReportAvatarAckMessage_ReportAvatarResult_avatarReportInvalid;
const int ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_ARRAYSIZE = ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_MAX + 1;

enum ReportGameAckMessage_ReportGameResult {
  ReportGameAckMessage_ReportGameResult_gameReportAccepted = 0,
  ReportGameAckMessage_ReportGameResult_gameReportDuplicate = 1,
  ReportGameAckMessage_ReportGameResult_gameReportInvalid = 2
};
bool ReportGameAckMessage_ReportGameResult_IsValid(int value);
const ReportGameAckMessage_ReportGameResult ReportGameAckMessage_ReportGameResult_ReportGameResult_MIN = ReportGameAckMessage_ReportGameResult_gameReportAccepted;
const ReportGameAckMessage_ReportGameResult ReportGameAckMessage_ReportGameResult_ReportGameResult_MAX = ReportGameAckMessage_ReportGameResult_gameReportInvalid;
const int ReportGameAckMessage_ReportGameResult_ReportGameResult_ARRAYSIZE = ReportGameAckMessage_ReportGameResult_ReportGameResult_MAX + 1;

enum ErrorMessage_ErrorReason {
  ErrorMessage_ErrorReason_reserved = 0,
  ErrorMessage_ErrorReason_initVersionNotSupported = 1,
  ErrorMessage_ErrorReason_initServerFull = 2,
  ErrorMessage_ErrorReason_initAuthFailure = 3,
  ErrorMessage_ErrorReason_initPlayerNameInUse = 4,
  ErrorMessage_ErrorReason_initInvalidPlayerName = 5,
  ErrorMessage_ErrorReason_initServerMaintenance = 6,
  ErrorMessage_ErrorReason_initBlocked = 7,
  ErrorMessage_ErrorReason_avatarTooLarge = 8,
  ErrorMessage_ErrorReason_invalidPacket = 9,
  ErrorMessage_ErrorReason_invalidState = 10,
  ErrorMessage_ErrorReason_kickedFromServer = 11,
  ErrorMessage_ErrorReason_bannedFromServer = 12,
  ErrorMessage_ErrorReason_blockedByServer = 13,
  ErrorMessage_ErrorReason_sessionTimeout = 14
};
bool ErrorMessage_ErrorReason_IsValid(int value);
const ErrorMessage_ErrorReason ErrorMessage_ErrorReason_ErrorReason_MIN = ErrorMessage_ErrorReason_reserved;
const ErrorMessage_ErrorReason ErrorMessage_ErrorReason_ErrorReason_MAX = ErrorMessage_ErrorReason_sessionTimeout;
const int ErrorMessage_ErrorReason_ErrorReason_ARRAYSIZE = ErrorMessage_ErrorReason_ErrorReason_MAX + 1;

enum PokerTHMessage_PokerTHMessageType {
  PokerTHMessage_PokerTHMessageType_Type_AnnounceMessage = 1,
  PokerTHMessage_PokerTHMessageType_Type_InitMessage = 2,
  PokerTHMessage_PokerTHMessageType_Type_AuthServerChallengeMessage = 3,
  PokerTHMessage_PokerTHMessageType_Type_AuthClientResponseMessage = 4,
  PokerTHMessage_PokerTHMessageType_Type_AuthServerVerificationMessage = 5,
  PokerTHMessage_PokerTHMessageType_Type_InitAckMessage = 6,
  PokerTHMessage_PokerTHMessageType_Type_AvatarRequestMessage = 7,
  PokerTHMessage_PokerTHMessageType_Type_AvatarHeaderMessage = 8,
  PokerTHMessage_PokerTHMessageType_Type_AvatarDataMessage = 9,
  PokerTHMessage_PokerTHMessageType_Type_AvatarEndMessage = 10,
  PokerTHMessage_PokerTHMessageType_Type_UnknownAvatarMessage = 11,
  PokerTHMessage_PokerTHMessageType_Type_PlayerListMessage = 12,
  PokerTHMessage_PokerTHMessageType_Type_GameListNewMessage = 13,
  PokerTHMessage_PokerTHMessageType_Type_GameListUpdateMessage = 14,
  PokerTHMessage_PokerTHMessageType_Type_GameListPlayerJoinedMessage = 15,
  PokerTHMessage_PokerTHMessageType_Type_GameListPlayerLeftMessage = 16,
  PokerTHMessage_PokerTHMessageType_Type_GameListAdminChangedMessage = 17,
  PokerTHMessage_PokerTHMessageType_Type_PlayerInfoRequestMessage = 18,
  PokerTHMessage_PokerTHMessageType_Type_PlayerInfoReplyMessage = 19,
  PokerTHMessage_PokerTHMessageType_Type_SubscriptionRequestMessage = 20,
  PokerTHMessage_PokerTHMessageType_Type_JoinExistingGameMessage = 21,
  PokerTHMessage_PokerTHMessageType_Type_JoinNewGameMessage = 22,
  PokerTHMessage_PokerTHMessageType_Type_RejoinExistingGameMessage = 23,
  PokerTHMessage_PokerTHMessageType_Type_JoinGameAckMessage = 24,
  PokerTHMessage_PokerTHMessageType_Type_JoinGameFailedMessage = 25,
  PokerTHMessage_PokerTHMessageType_Type_GamePlayerJoinedMessage = 26,
  PokerTHMessage_PokerTHMessageType_Type_GamePlayerLeftMessage = 27,
  PokerTHMessage_PokerTHMessageType_Type_GameAdminChangedMessage = 28,
  PokerTHMessage_PokerTHMessageType_Type_RemovedFromGameMessage = 29,
  PokerTHMessage_PokerTHMessageType_Type_KickPlayerRequestMessage = 30,
  PokerTHMessage_PokerTHMessageType_Type_LeaveGameRequestMessage = 31,
  PokerTHMessage_PokerTHMessageType_Type_InvitePlayerToGameMessage = 32,
  PokerTHMessage_PokerTHMessageType_Type_InviteNotifyMessage = 33,
  PokerTHMessage_PokerTHMessageType_Type_RejectGameInvitationMessage = 34,
  PokerTHMessage_PokerTHMessageType_Type_RejectInvNotifyMessage = 35,
  PokerTHMessage_PokerTHMessageType_Type_StartEventMessage = 36,
  PokerTHMessage_PokerTHMessageType_Type_StartEventAckMessage = 37,
  PokerTHMessage_PokerTHMessageType_Type_GameStartInitialMessage = 38,
  PokerTHMessage_PokerTHMessageType_Type_GameStartRejoinMessage = 39,
  PokerTHMessage_PokerTHMessageType_Type_HandStartMessage = 40,
  PokerTHMessage_PokerTHMessageType_Type_PlayersTurnMessage = 41,
  PokerTHMessage_PokerTHMessageType_Type_MyActionRequestMessage = 42,
  PokerTHMessage_PokerTHMessageType_Type_YourActionRejectedMessage = 43,
  PokerTHMessage_PokerTHMessageType_Type_PlayersActionDoneMessage = 44,
  PokerTHMessage_PokerTHMessageType_Type_DealFlopCardsMessage = 45,
  PokerTHMessage_PokerTHMessageType_Type_DealTurnCardMessage = 46,
  PokerTHMessage_PokerTHMessageType_Type_DealRiverCardMessage = 47,
  PokerTHMessage_PokerTHMessageType_Type_AllInShowCardsMessage = 48,
  PokerTHMessage_PokerTHMessageType_Type_EndOfHandShowCardsMessage = 49,
  PokerTHMessage_PokerTHMessageType_Type_EndOfHandHideCardsMessage = 50,
  PokerTHMessage_PokerTHMessageType_Type_ShowMyCardsRequestMessage = 51,
  PokerTHMessage_PokerTHMessageType_Type_AfterHandShowCardsMessage = 52,
  PokerTHMessage_PokerTHMessageType_Type_EndOfGameMessage = 53,
  PokerTHMessage_PokerTHMessageType_Type_PlayerIdChangedMessage = 54,
  PokerTHMessage_PokerTHMessageType_Type_AskKickPlayerMessage = 55,
  PokerTHMessage_PokerTHMessageType_Type_AskKickDeniedMessage = 56,
  PokerTHMessage_PokerTHMessageType_Type_StartKickPetitionMessage = 57,
  PokerTHMessage_PokerTHMessageType_Type_VoteKickRequestMessage = 58,
  PokerTHMessage_PokerTHMessageType_Type_VoteKickReplyMessage = 59,
  PokerTHMessage_PokerTHMessageType_Type_KickPetitionUpdateMessage = 60,
  PokerTHMessage_PokerTHMessageType_Type_EndKickPetitionMessage = 61,
  PokerTHMessage_PokerTHMessageType_Type_StatisticsMessage = 62,
  PokerTHMessage_PokerTHMessageType_Type_ChatRequestMessage = 63,
  PokerTHMessage_PokerTHMessageType_Type_ChatMessage = 64,
  PokerTHMessage_PokerTHMessageType_Type_ChatRejectMessage = 65,
  PokerTHMessage_PokerTHMessageType_Type_DialogMessage = 66,
  PokerTHMessage_PokerTHMessageType_Type_TimeoutWarningMessage = 67,
  PokerTHMessage_PokerTHMessageType_Type_ResetTimeoutMessage = 68,
  PokerTHMessage_PokerTHMessageType_Type_ReportAvatarMessage = 69,
  PokerTHMessage_PokerTHMessageType_Type_ReportAvatarAckMessage = 70,
  PokerTHMessage_PokerTHMessageType_Type_ReportGameMessage = 71,
  PokerTHMessage_PokerTHMessageType_Type_ReportGameAckMessage = 72,
  PokerTHMessage_PokerTHMessageType_Type_ErrorMessage = 73
};
bool PokerTHMessage_PokerTHMessageType_IsValid(int value);
const PokerTHMessage_PokerTHMessageType PokerTHMessage_PokerTHMessageType_PokerTHMessageType_MIN = PokerTHMessage_PokerTHMessageType_Type_AnnounceMessage;
const PokerTHMessage_PokerTHMessageType PokerTHMessage_PokerTHMessageType_PokerTHMessageType_MAX = PokerTHMessage_PokerTHMessageType_Type_ErrorMessage;
const int PokerTHMessage_PokerTHMessageType_PokerTHMessageType_ARRAYSIZE = PokerTHMessage_PokerTHMessageType_PokerTHMessageType_MAX + 1;

enum NetGameMode {
  netGameCreated = 1,
  netGameStarted = 2,
  netGameClosed = 3
};
bool NetGameMode_IsValid(int value);
const NetGameMode NetGameMode_MIN = netGameCreated;
const NetGameMode NetGameMode_MAX = netGameClosed;
const int NetGameMode_ARRAYSIZE = NetGameMode_MAX + 1;

enum NetGameState {
  netStatePreflop = 0,
  netStateFlop = 1,
  netStateTurn = 2,
  netStateRiver = 3,
  netStatePreflopSmallBlind = 4,
  netStatePreflopBigBlind = 5
};
bool NetGameState_IsValid(int value);
const NetGameState NetGameState_MIN = netStatePreflop;
const NetGameState NetGameState_MAX = netStatePreflopBigBlind;
const int NetGameState_ARRAYSIZE = NetGameState_MAX + 1;

enum NetPlayerAction {
  netActionNone = 0,
  netActionFold = 1,
  netActionCheck = 2,
  netActionCall = 3,
  netActionBet = 4,
  netActionRaise = 5,
  netActionAllIn = 6
};
bool NetPlayerAction_IsValid(int value);
const NetPlayerAction NetPlayerAction_MIN = netActionNone;
const NetPlayerAction NetPlayerAction_MAX = netActionAllIn;
const int NetPlayerAction_ARRAYSIZE = NetPlayerAction_MAX + 1;

enum NetPlayerState {
  netPlayerStateNormal = 0,
  netPlayerStateSessionInactive = 1,
  netPlayerStateNoMoney = 2
};
bool NetPlayerState_IsValid(int value);
const NetPlayerState NetPlayerState_MIN = netPlayerStateNormal;
const NetPlayerState NetPlayerState_MAX = netPlayerStateNoMoney;
const int NetPlayerState_ARRAYSIZE = NetPlayerState_MAX + 1;

enum NetPlayerInfoRights {
  netPlayerRightsGuest = 1,
  netPlayerRightsNormal = 2,
  netPlayerRightsAdmin = 3
};
bool NetPlayerInfoRights_IsValid(int value);
const NetPlayerInfoRights NetPlayerInfoRights_MIN = netPlayerRightsGuest;
const NetPlayerInfoRights NetPlayerInfoRights_MAX = netPlayerRightsAdmin;
const int NetPlayerInfoRights_ARRAYSIZE = NetPlayerInfoRights_MAX + 1;

enum NetAvatarType {
  netAvatarImagePng = 1,
  netAvatarImageJpg = 2,
  netAvatarImageGif = 3
};
bool NetAvatarType_IsValid(int value);
const NetAvatarType NetAvatarType_MIN = netAvatarImagePng;
const NetAvatarType NetAvatarType_MAX = netAvatarImageGif;
const int NetAvatarType_ARRAYSIZE = NetAvatarType_MAX + 1;

// ===================================================================

class NetGameInfo : public ::google::protobuf::MessageLite {
 public:
  NetGameInfo();
  virtual ~NetGameInfo();
  
  NetGameInfo(const NetGameInfo& from);
  
  inline NetGameInfo& operator=(const NetGameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const NetGameInfo& default_instance();
  
  void Swap(NetGameInfo* other);
  
  // implements Message ----------------------------------------------
  
  NetGameInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NetGameInfo& from);
  void MergeFrom(const NetGameInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef NetGameInfo_NetGameType NetGameType;
  static const NetGameType normalGame = NetGameInfo_NetGameType_normalGame;
  static const NetGameType registeredOnlyGame = NetGameInfo_NetGameType_registeredOnlyGame;
  static const NetGameType inviteOnlyGame = NetGameInfo_NetGameType_inviteOnlyGame;
  static const NetGameType rankingGame = NetGameInfo_NetGameType_rankingGame;
  static inline bool NetGameType_IsValid(int value) {
    return NetGameInfo_NetGameType_IsValid(value);
  }
  static const NetGameType NetGameType_MIN =
    NetGameInfo_NetGameType_NetGameType_MIN;
  static const NetGameType NetGameType_MAX =
    NetGameInfo_NetGameType_NetGameType_MAX;
  static const int NetGameType_ARRAYSIZE =
    NetGameInfo_NetGameType_NetGameType_ARRAYSIZE;
  
  typedef NetGameInfo_RaiseIntervalMode RaiseIntervalMode;
  static const RaiseIntervalMode raiseOnHandNum = NetGameInfo_RaiseIntervalMode_raiseOnHandNum;
  static const RaiseIntervalMode raiseOnMinutes = NetGameInfo_RaiseIntervalMode_raiseOnMinutes;
  static inline bool RaiseIntervalMode_IsValid(int value) {
    return NetGameInfo_RaiseIntervalMode_IsValid(value);
  }
  static const RaiseIntervalMode RaiseIntervalMode_MIN =
    NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_MIN;
  static const RaiseIntervalMode RaiseIntervalMode_MAX =
    NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_MAX;
  static const int RaiseIntervalMode_ARRAYSIZE =
    NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_ARRAYSIZE;
  
  typedef NetGameInfo_EndRaiseMode EndRaiseMode;
  static const EndRaiseMode doubleBlinds = NetGameInfo_EndRaiseMode_doubleBlinds;
  static const EndRaiseMode raiseByEndValue = NetGameInfo_EndRaiseMode_raiseByEndValue;
  static const EndRaiseMode keepLastBlind = NetGameInfo_EndRaiseMode_keepLastBlind;
  static inline bool EndRaiseMode_IsValid(int value) {
    return NetGameInfo_EndRaiseMode_IsValid(value);
  }
  static const EndRaiseMode EndRaiseMode_MIN =
    NetGameInfo_EndRaiseMode_EndRaiseMode_MIN;
  static const EndRaiseMode EndRaiseMode_MAX =
    NetGameInfo_EndRaiseMode_EndRaiseMode_MAX;
  static const int EndRaiseMode_ARRAYSIZE =
    NetGameInfo_EndRaiseMode_EndRaiseMode_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required string gameName = 1;
  inline bool has_gamename() const;
  inline void clear_gamename();
  static const int kGameNameFieldNumber = 1;
  inline const ::std::string& gamename() const;
  inline void set_gamename(const ::std::string& value);
  inline void set_gamename(const char* value);
  inline void set_gamename(const char* value, size_t size);
  inline ::std::string* mutable_gamename();
  inline ::std::string* release_gamename();
  
  // required .NetGameInfo.NetGameType netGameType = 2;
  inline bool has_netgametype() const;
  inline void clear_netgametype();
  static const int kNetGameTypeFieldNumber = 2;
  inline ::NetGameInfo_NetGameType netgametype() const;
  inline void set_netgametype(::NetGameInfo_NetGameType value);
  
  // required uint32 maxNumPlayers = 3;
  inline bool has_maxnumplayers() const;
  inline void clear_maxnumplayers();
  static const int kMaxNumPlayersFieldNumber = 3;
  inline ::google::protobuf::uint32 maxnumplayers() const;
  inline void set_maxnumplayers(::google::protobuf::uint32 value);
  
  // required .NetGameInfo.RaiseIntervalMode raiseIntervalMode = 4;
  inline bool has_raiseintervalmode() const;
  inline void clear_raiseintervalmode();
  static const int kRaiseIntervalModeFieldNumber = 4;
  inline ::NetGameInfo_RaiseIntervalMode raiseintervalmode() const;
  inline void set_raiseintervalmode(::NetGameInfo_RaiseIntervalMode value);
  
  // optional uint32 raiseEveryHands = 5;
  inline bool has_raiseeveryhands() const;
  inline void clear_raiseeveryhands();
  static const int kRaiseEveryHandsFieldNumber = 5;
  inline ::google::protobuf::uint32 raiseeveryhands() const;
  inline void set_raiseeveryhands(::google::protobuf::uint32 value);
  
  // optional uint32 raiseEveryMinutes = 6;
  inline bool has_raiseeveryminutes() const;
  inline void clear_raiseeveryminutes();
  static const int kRaiseEveryMinutesFieldNumber = 6;
  inline ::google::protobuf::uint32 raiseeveryminutes() const;
  inline void set_raiseeveryminutes(::google::protobuf::uint32 value);
  
  // required .NetGameInfo.EndRaiseMode endRaiseMode = 7;
  inline bool has_endraisemode() const;
  inline void clear_endraisemode();
  static const int kEndRaiseModeFieldNumber = 7;
  inline ::NetGameInfo_EndRaiseMode endraisemode() const;
  inline void set_endraisemode(::NetGameInfo_EndRaiseMode value);
  
  // optional uint32 endRaiseSmallBlindValue = 8;
  inline bool has_endraisesmallblindvalue() const;
  inline void clear_endraisesmallblindvalue();
  static const int kEndRaiseSmallBlindValueFieldNumber = 8;
  inline ::google::protobuf::uint32 endraisesmallblindvalue() const;
  inline void set_endraisesmallblindvalue(::google::protobuf::uint32 value);
  
  // required uint32 proposedGuiSpeed = 9;
  inline bool has_proposedguispeed() const;
  inline void clear_proposedguispeed();
  static const int kProposedGuiSpeedFieldNumber = 9;
  inline ::google::protobuf::uint32 proposedguispeed() const;
  inline void set_proposedguispeed(::google::protobuf::uint32 value);
  
  // required uint32 delayBetweenHands = 10;
  inline bool has_delaybetweenhands() const;
  inline void clear_delaybetweenhands();
  static const int kDelayBetweenHandsFieldNumber = 10;
  inline ::google::protobuf::uint32 delaybetweenhands() const;
  inline void set_delaybetweenhands(::google::protobuf::uint32 value);
  
  // required uint32 playerActionTimeout = 11;
  inline bool has_playeractiontimeout() const;
  inline void clear_playeractiontimeout();
  static const int kPlayerActionTimeoutFieldNumber = 11;
  inline ::google::protobuf::uint32 playeractiontimeout() const;
  inline void set_playeractiontimeout(::google::protobuf::uint32 value);
  
  // required uint32 firstSmallBlind = 12;
  inline bool has_firstsmallblind() const;
  inline void clear_firstsmallblind();
  static const int kFirstSmallBlindFieldNumber = 12;
  inline ::google::protobuf::uint32 firstsmallblind() const;
  inline void set_firstsmallblind(::google::protobuf::uint32 value);
  
  // required uint32 startMoney = 13;
  inline bool has_startmoney() const;
  inline void clear_startmoney();
  static const int kStartMoneyFieldNumber = 13;
  inline ::google::protobuf::uint32 startmoney() const;
  inline void set_startmoney(::google::protobuf::uint32 value);
  
  // repeated uint32 manualBlinds = 14 [packed = true];
  inline int manualblinds_size() const;
  inline void clear_manualblinds();
  static const int kManualBlindsFieldNumber = 14;
  inline ::google::protobuf::uint32 manualblinds(int index) const;
  inline void set_manualblinds(int index, ::google::protobuf::uint32 value);
  inline void add_manualblinds(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      manualblinds() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_manualblinds();
  
  // @@protoc_insertion_point(class_scope:NetGameInfo)
 private:
  inline void set_has_gamename();
  inline void clear_has_gamename();
  inline void set_has_netgametype();
  inline void clear_has_netgametype();
  inline void set_has_maxnumplayers();
  inline void clear_has_maxnumplayers();
  inline void set_has_raiseintervalmode();
  inline void clear_has_raiseintervalmode();
  inline void set_has_raiseeveryhands();
  inline void clear_has_raiseeveryhands();
  inline void set_has_raiseeveryminutes();
  inline void clear_has_raiseeveryminutes();
  inline void set_has_endraisemode();
  inline void clear_has_endraisemode();
  inline void set_has_endraisesmallblindvalue();
  inline void clear_has_endraisesmallblindvalue();
  inline void set_has_proposedguispeed();
  inline void clear_has_proposedguispeed();
  inline void set_has_delaybetweenhands();
  inline void clear_has_delaybetweenhands();
  inline void set_has_playeractiontimeout();
  inline void clear_has_playeractiontimeout();
  inline void set_has_firstsmallblind();
  inline void clear_has_firstsmallblind();
  inline void set_has_startmoney();
  inline void clear_has_startmoney();
  
  ::std::string* gamename_;
  int netgametype_;
  ::google::protobuf::uint32 maxnumplayers_;
  int raiseintervalmode_;
  ::google::protobuf::uint32 raiseeveryhands_;
  ::google::protobuf::uint32 raiseeveryminutes_;
  int endraisemode_;
  ::google::protobuf::uint32 endraisesmallblindvalue_;
  ::google::protobuf::uint32 proposedguispeed_;
  ::google::protobuf::uint32 delaybetweenhands_;
  ::google::protobuf::uint32 playeractiontimeout_;
  ::google::protobuf::uint32 firstsmallblind_;
  ::google::protobuf::uint32 startmoney_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > manualblinds_;
  mutable int _manualblinds_cached_byte_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static NetGameInfo* default_instance_;
};
// -------------------------------------------------------------------

class PlayerResult : public ::google::protobuf::MessageLite {
 public:
  PlayerResult();
  virtual ~PlayerResult();
  
  PlayerResult(const PlayerResult& from);
  
  inline PlayerResult& operator=(const PlayerResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PlayerResult& default_instance();
  
  void Swap(PlayerResult* other);
  
  // implements Message ----------------------------------------------
  
  PlayerResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerResult& from);
  void MergeFrom(const PlayerResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 playerId = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);
  
  // required uint32 resultCard1 = 2;
  inline bool has_resultcard1() const;
  inline void clear_resultcard1();
  static const int kResultCard1FieldNumber = 2;
  inline ::google::protobuf::uint32 resultcard1() const;
  inline void set_resultcard1(::google::protobuf::uint32 value);
  
  // required uint32 resultCard2 = 3;
  inline bool has_resultcard2() const;
  inline void clear_resultcard2();
  static const int kResultCard2FieldNumber = 3;
  inline ::google::protobuf::uint32 resultcard2() const;
  inline void set_resultcard2(::google::protobuf::uint32 value);
  
  // repeated uint32 bestHandPosition = 4 [packed = true];
  inline int besthandposition_size() const;
  inline void clear_besthandposition();
  static const int kBestHandPositionFieldNumber = 4;
  inline ::google::protobuf::uint32 besthandposition(int index) const;
  inline void set_besthandposition(int index, ::google::protobuf::uint32 value);
  inline void add_besthandposition(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      besthandposition() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_besthandposition();
  
  // required uint32 moneyWon = 5;
  inline bool has_moneywon() const;
  inline void clear_moneywon();
  static const int kMoneyWonFieldNumber = 5;
  inline ::google::protobuf::uint32 moneywon() const;
  inline void set_moneywon(::google::protobuf::uint32 value);
  
  // required uint32 playerMoney = 6;
  inline bool has_playermoney() const;
  inline void clear_playermoney();
  static const int kPlayerMoneyFieldNumber = 6;
  inline ::google::protobuf::uint32 playermoney() const;
  inline void set_playermoney(::google::protobuf::uint32 value);
  
  // optional uint32 cardsValue = 7;
  inline bool has_cardsvalue() const;
  inline void clear_cardsvalue();
  static const int kCardsValueFieldNumber = 7;
  inline ::google::protobuf::uint32 cardsvalue() const;
  inline void set_cardsvalue(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:PlayerResult)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_resultcard1();
  inline void clear_has_resultcard1();
  inline void set_has_resultcard2();
  inline void clear_has_resultcard2();
  inline void set_has_moneywon();
  inline void clear_has_moneywon();
  inline void set_has_playermoney();
  inline void clear_has_playermoney();
  inline void set_has_cardsvalue();
  inline void clear_has_cardsvalue();
  
  ::google::protobuf::uint32 playerid_;
  ::google::protobuf::uint32 resultcard1_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > besthandposition_;
  mutable int _besthandposition_cached_byte_size_;
  ::google::protobuf::uint32 resultcard2_;
  ::google::protobuf::uint32 moneywon_;
  ::google::protobuf::uint32 playermoney_;
  ::google::protobuf::uint32 cardsvalue_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static PlayerResult* default_instance_;
};
// -------------------------------------------------------------------

class AnnounceMessage_Version : public ::google::protobuf::MessageLite {
 public:
  AnnounceMessage_Version();
  virtual ~AnnounceMessage_Version();
  
  AnnounceMessage_Version(const AnnounceMessage_Version& from);
  
  inline AnnounceMessage_Version& operator=(const AnnounceMessage_Version& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const AnnounceMessage_Version& default_instance();
  
  void Swap(AnnounceMessage_Version* other);
  
  // implements Message ----------------------------------------------
  
  AnnounceMessage_Version* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AnnounceMessage_Version& from);
  void MergeFrom(const AnnounceMessage_Version& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 majorVersion = 1;
  inline bool has_majorversion() const;
  inline void clear_majorversion();
  static const int kMajorVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 majorversion() const;
  inline void set_majorversion(::google::protobuf::uint32 value);
  
  // required uint32 minorVersion = 2;
  inline bool has_minorversion() const;
  inline void clear_minorversion();
  static const int kMinorVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 minorversion() const;
  inline void set_minorversion(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:AnnounceMessage.Version)
 private:
  inline void set_has_majorversion();
  inline void clear_has_majorversion();
  inline void set_has_minorversion();
  inline void clear_has_minorversion();
  
  ::google::protobuf::uint32 majorversion_;
  ::google::protobuf::uint32 minorversion_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static AnnounceMessage_Version* default_instance_;
};
// -------------------------------------------------------------------

class AnnounceMessage : public ::google::protobuf::MessageLite {
 public:
  AnnounceMessage();
  virtual ~AnnounceMessage();
  
  AnnounceMessage(const AnnounceMessage& from);
  
  inline AnnounceMessage& operator=(const AnnounceMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const AnnounceMessage& default_instance();
  
  void Swap(AnnounceMessage* other);
  
  // implements Message ----------------------------------------------
  
  AnnounceMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AnnounceMessage& from);
  void MergeFrom(const AnnounceMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef AnnounceMessage_Version Version;
  
  typedef AnnounceMessage_ServerType ServerType;
  static const ServerType serverTypeLAN = AnnounceMessage_ServerType_serverTypeLAN;
  static const ServerType serverTypeInternetNoAuth = AnnounceMessage_ServerType_serverTypeInternetNoAuth;
  static const ServerType serverTypeInternetAuth = AnnounceMessage_ServerType_serverTypeInternetAuth;
  static inline bool ServerType_IsValid(int value) {
    return AnnounceMessage_ServerType_IsValid(value);
  }
  static const ServerType ServerType_MIN =
    AnnounceMessage_ServerType_ServerType_MIN;
  static const ServerType ServerType_MAX =
    AnnounceMessage_ServerType_ServerType_MAX;
  static const int ServerType_ARRAYSIZE =
    AnnounceMessage_ServerType_ServerType_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .AnnounceMessage.Version protocolVersion = 1;
  inline bool has_protocolversion() const;
  inline void clear_protocolversion();
  static const int kProtocolVersionFieldNumber = 1;
  inline const ::AnnounceMessage_Version& protocolversion() const;
  inline ::AnnounceMessage_Version* mutable_protocolversion();
  inline ::AnnounceMessage_Version* release_protocolversion();
  
  // required .AnnounceMessage.Version latestGameVersion = 2;
  inline bool has_latestgameversion() const;
  inline void clear_latestgameversion();
  static const int kLatestGameVersionFieldNumber = 2;
  inline const ::AnnounceMessage_Version& latestgameversion() const;
  inline ::AnnounceMessage_Version* mutable_latestgameversion();
  inline ::AnnounceMessage_Version* release_latestgameversion();
  
  // required uint32 latestBetaRevision = 3;
  inline bool has_latestbetarevision() const;
  inline void clear_latestbetarevision();
  static const int kLatestBetaRevisionFieldNumber = 3;
  inline ::google::protobuf::uint32 latestbetarevision() const;
  inline void set_latestbetarevision(::google::protobuf::uint32 value);
  
  // required .AnnounceMessage.ServerType serverType = 4;
  inline bool has_servertype() const;
  inline void clear_servertype();
  static const int kServerTypeFieldNumber = 4;
  inline ::AnnounceMessage_ServerType servertype() const;
  inline void set_servertype(::AnnounceMessage_ServerType value);
  
  // required uint32 numPlayersOnServer = 5;
  inline bool has_numplayersonserver() const;
  inline void clear_numplayersonserver();
  static const int kNumPlayersOnServerFieldNumber = 5;
  inline ::google::protobuf::uint32 numplayersonserver() const;
  inline void set_numplayersonserver(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:AnnounceMessage)
 private:
  inline void set_has_protocolversion();
  inline void clear_has_protocolversion();
  inline void set_has_latestgameversion();
  inline void clear_has_latestgameversion();
  inline void set_has_latestbetarevision();
  inline void clear_has_latestbetarevision();
  inline void set_has_servertype();
  inline void clear_has_servertype();
  inline void set_has_numplayersonserver();
  inline void clear_has_numplayersonserver();
  
  ::AnnounceMessage_Version* protocolversion_;
  ::AnnounceMessage_Version* latestgameversion_;
  ::google::protobuf::uint32 latestbetarevision_;
  int servertype_;
  ::google::protobuf::uint32 numplayersonserver_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static AnnounceMessage* default_instance_;
};
// -------------------------------------------------------------------

class InitMessage : public ::google::protobuf::MessageLite {
 public:
  InitMessage();
  virtual ~InitMessage();
  
  InitMessage(const InitMessage& from);
  
  inline InitMessage& operator=(const InitMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const InitMessage& default_instance();
  
  void Swap(InitMessage* other);
  
  // implements Message ----------------------------------------------
  
  InitMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InitMessage& from);
  void MergeFrom(const InitMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef InitMessage_LoginType LoginType;
  static const LoginType guestLogin = InitMessage_LoginType_guestLogin;
  static const LoginType authenticatedLogin = InitMessage_LoginType_authenticatedLogin;
  static const LoginType unauthenticatedLogin = InitMessage_LoginType_unauthenticatedLogin;
  static inline bool LoginType_IsValid(int value) {
    return InitMessage_LoginType_IsValid(value);
  }
  static const LoginType LoginType_MIN =
    InitMessage_LoginType_LoginType_MIN;
  static const LoginType LoginType_MAX =
    InitMessage_LoginType_LoginType_MAX;
  static const int LoginType_ARRAYSIZE =
    InitMessage_LoginType_LoginType_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .AnnounceMessage.Version requestedVersion = 1;
  inline bool has_requestedversion() const;
  inline void clear_requestedversion();
  static const int kRequestedVersionFieldNumber = 1;
  inline const ::AnnounceMessage_Version& requestedversion() const;
  inline ::AnnounceMessage_Version* mutable_requestedversion();
  inline ::AnnounceMessage_Version* release_requestedversion();
  
  // required uint32 buildId = 2;
  inline bool has_buildid() const;
  inline void clear_buildid();
  static const int kBuildIdFieldNumber = 2;
  inline ::google::protobuf::uint32 buildid() const;
  inline void set_buildid(::google::protobuf::uint32 value);
  
  // optional bytes myLastSessionId = 3;
  inline bool has_mylastsessionid() const;
  inline void clear_mylastsessionid();
  static const int kMyLastSessionIdFieldNumber = 3;
  inline const ::std::string& mylastsessionid() const;
  inline void set_mylastsessionid(const ::std::string& value);
  inline void set_mylastsessionid(const char* value);
  inline void set_mylastsessionid(const void* value, size_t size);
  inline ::std::string* mutable_mylastsessionid();
  inline ::std::string* release_mylastsessionid();
  
  // optional string authServerPassword = 4;
  inline bool has_authserverpassword() const;
  inline void clear_authserverpassword();
  static const int kAuthServerPasswordFieldNumber = 4;
  inline const ::std::string& authserverpassword() const;
  inline void set_authserverpassword(const ::std::string& value);
  inline void set_authserverpassword(const char* value);
  inline void set_authserverpassword(const char* value, size_t size);
  inline ::std::string* mutable_authserverpassword();
  inline ::std::string* release_authserverpassword();
  
  // required .InitMessage.LoginType login = 5;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 5;
  inline ::InitMessage_LoginType login() const;
  inline void set_login(::InitMessage_LoginType value);
  
  // optional string nickName = 6;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 6;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  
  // optional bytes clientUserData = 7;
  inline bool has_clientuserdata() const;
  inline void clear_clientuserdata();
  static const int kClientUserDataFieldNumber = 7;
  inline const ::std::string& clientuserdata() const;
  inline void set_clientuserdata(const ::std::string& value);
  inline void set_clientuserdata(const char* value);
  inline void set_clientuserdata(const void* value, size_t size);
  inline ::std::string* mutable_clientuserdata();
  inline ::std::string* release_clientuserdata();
  
  // optional bytes avatarHash = 8;
  inline bool has_avatarhash() const;
  inline void clear_avatarhash();
  static const int kAvatarHashFieldNumber = 8;
  inline const ::std::string& avatarhash() const;
  inline void set_avatarhash(const ::std::string& value);
  inline void set_avatarhash(const char* value);
  inline void set_avatarhash(const void* value, size_t size);
  inline ::std::string* mutable_avatarhash();
  inline ::std::string* release_avatarhash();
  
  // @@protoc_insertion_point(class_scope:InitMessage)
 private:
  inline void set_has_requestedversion();
  inline void clear_has_requestedversion();
  inline void set_has_buildid();
  inline void clear_has_buildid();
  inline void set_has_mylastsessionid();
  inline void clear_has_mylastsessionid();
  inline void set_has_authserverpassword();
  inline void clear_has_authserverpassword();
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_clientuserdata();
  inline void clear_has_clientuserdata();
  inline void set_has_avatarhash();
  inline void clear_has_avatarhash();
  
  ::AnnounceMessage_Version* requestedversion_;
  ::std::string* mylastsessionid_;
  ::google::protobuf::uint32 buildid_;
  int login_;
  ::std::string* authserverpassword_;
  ::std::string* nickname_;
  ::std::string* clientuserdata_;
  ::std::string* avatarhash_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static InitMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthServerChallengeMessage : public ::google::protobuf::MessageLite {
 public:
  AuthServerChallengeMessage();
  virtual ~AuthServerChallengeMessage();
  
  AuthServerChallengeMessage(const AuthServerChallengeMessage& from);
  
  inline AuthServerChallengeMessage& operator=(const AuthServerChallengeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const AuthServerChallengeMessage& default_instance();
  
  void Swap(AuthServerChallengeMessage* other);
  
  // implements Message ----------------------------------------------
  
  AuthServerChallengeMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthServerChallengeMessage& from);
  void MergeFrom(const AuthServerChallengeMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes serverChallenge = 1;
  inline bool has_serverchallenge() const;
  inline void clear_serverchallenge();
  static const int kServerChallengeFieldNumber = 1;
  inline const ::std::string& serverchallenge() const;
  inline void set_serverchallenge(const ::std::string& value);
  inline void set_serverchallenge(const char* value);
  inline void set_serverchallenge(const void* value, size_t size);
  inline ::std::string* mutable_serverchallenge();
  inline ::std::string* release_serverchallenge();
  
  // @@protoc_insertion_point(class_scope:AuthServerChallengeMessage)
 private:
  inline void set_has_serverchallenge();
  inline void clear_has_serverchallenge();
  
  ::std::string* serverchallenge_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static AuthServerChallengeMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthClientResponseMessage : public ::google::protobuf::MessageLite {
 public:
  AuthClientResponseMessage();
  virtual ~AuthClientResponseMessage();
  
  AuthClientResponseMessage(const AuthClientResponseMessage& from);
  
  inline AuthClientResponseMessage& operator=(const AuthClientResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const AuthClientResponseMessage& default_instance();
  
  void Swap(AuthClientResponseMessage* other);
  
  // implements Message ----------------------------------------------
  
  AuthClientResponseMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthClientResponseMessage& from);
  void MergeFrom(const AuthClientResponseMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes clientResponse = 1;
  inline bool has_clientresponse() const;
  inline void clear_clientresponse();
  static const int kClientResponseFieldNumber = 1;
  inline const ::std::string& clientresponse() const;
  inline void set_clientresponse(const ::std::string& value);
  inline void set_clientresponse(const char* value);
  inline void set_clientresponse(const void* value, size_t size);
  inline ::std::string* mutable_clientresponse();
  inline ::std::string* release_clientresponse();
  
  // @@protoc_insertion_point(class_scope:AuthClientResponseMessage)
 private:
  inline void set_has_clientresponse();
  inline void clear_has_clientresponse();
  
  ::std::string* clientresponse_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static AuthClientResponseMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthServerVerificationMessage : public ::google::protobuf::MessageLite {
 public:
  AuthServerVerificationMessage();
  virtual ~AuthServerVerificationMessage();
  
  AuthServerVerificationMessage(const AuthServerVerificationMessage& from);
  
  inline AuthServerVerificationMessage& operator=(const AuthServerVerificationMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const AuthServerVerificationMessage& default_instance();
  
  void Swap(AuthServerVerificationMessage* other);
  
  // implements Message ----------------------------------------------
  
  AuthServerVerificationMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthServerVerificationMessage& from);
  void MergeFrom(const AuthServerVerificationMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes serverVerification = 1;
  inline bool has_serververification() const;
  inline void clear_serververification();
  static const int kServerVerificationFieldNumber = 1;
  inline const ::std::string& serververification() const;
  inline void set_serververification(const ::std::string& value);
  inline void set_serververification(const char* value);
  inline void set_serververification(const void* value, size_t size);
  inline ::std::string* mutable_serververification();
  inline ::std::string* release_serververification();
  
  // @@protoc_insertion_point(class_scope:AuthServerVerificationMessage)
 private:
  inline void set_has_serververification();
  inline void clear_has_serververification();
  
  ::std::string* serververification_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static AuthServerVerificationMessage* default_instance_;
};
// -------------------------------------------------------------------

class InitAckMessage : public ::google::protobuf::MessageLite {
 public:
  InitAckMessage();
  virtual ~InitAckMessage();
  
  InitAckMessage(const InitAckMessage& from);
  
  inline InitAckMessage& operator=(const InitAckMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const InitAckMessage& default_instance();
  
  void Swap(InitAckMessage* other);
  
  // implements Message ----------------------------------------------
  
  InitAckMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InitAckMessage& from);
  void MergeFrom(const InitAckMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes yourSessionId = 1;
  inline bool has_yoursessionid() const;
  inline void clear_yoursessionid();
  static const int kYourSessionIdFieldNumber = 1;
  inline const ::std::string& yoursessionid() const;
  inline void set_yoursessionid(const ::std::string& value);
  inline void set_yoursessionid(const char* value);
  inline void set_yoursessionid(const void* value, size_t size);
  inline ::std::string* mutable_yoursessionid();
  inline ::std::string* release_yoursessionid();
  
  // required uint32 yourPlayerId = 2;
  inline bool has_yourplayerid() const;
  inline void clear_yourplayerid();
  static const int kYourPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 yourplayerid() const;
  inline void set_yourplayerid(::google::protobuf::uint32 value);
  
  // optional bytes yourAvatarHash = 3;
  inline bool has_youravatarhash() const;
  inline void clear_youravatarhash();
  static const int kYourAvatarHashFieldNumber = 3;
  inline const ::std::string& youravatarhash() const;
  inline void set_youravatarhash(const ::std::string& value);
  inline void set_youravatarhash(const char* value);
  inline void set_youravatarhash(const void* value, size_t size);
  inline ::std::string* mutable_youravatarhash();
  inline ::std::string* release_youravatarhash();
  
  // optional uint32 rejoinGameId = 4;
  inline bool has_rejoingameid() const;
  inline void clear_rejoingameid();
  static const int kRejoinGameIdFieldNumber = 4;
  inline ::google::protobuf::uint32 rejoingameid() const;
  inline void set_rejoingameid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:InitAckMessage)
 private:
  inline void set_has_yoursessionid();
  inline void clear_has_yoursessionid();
  inline void set_has_yourplayerid();
  inline void clear_has_yourplayerid();
  inline void set_has_youravatarhash();
  inline void clear_has_youravatarhash();
  inline void set_has_rejoingameid();
  inline void clear_has_rejoingameid();
  
  ::std::string* yoursessionid_;
  ::std::string* youravatarhash_;
  ::google::protobuf::uint32 yourplayerid_;
  ::google::protobuf::uint32 rejoingameid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static InitAckMessage* default_instance_;
};
// -------------------------------------------------------------------

class AvatarRequestMessage : public ::google::protobuf::MessageLite {
 public:
  AvatarRequestMessage();
  virtual ~AvatarRequestMessage();
  
  AvatarRequestMessage(const AvatarRequestMessage& from);
  
  inline AvatarRequestMessage& operator=(const AvatarRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const AvatarRequestMessage& default_instance();
  
  void Swap(AvatarRequestMessage* other);
  
  // implements Message ----------------------------------------------
  
  AvatarRequestMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AvatarRequestMessage& from);
  void MergeFrom(const AvatarRequestMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 requestId = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint32 requestid() const;
  inline void set_requestid(::google::protobuf::uint32 value);
  
  // required bytes avatarHash = 2;
  inline bool has_avatarhash() const;
  inline void clear_avatarhash();
  static const int kAvatarHashFieldNumber = 2;
  inline const ::std::string& avatarhash() const;
  inline void set_avatarhash(const ::std::string& value);
  inline void set_avatarhash(const char* value);
  inline void set_avatarhash(const void* value, size_t size);
  inline ::std::string* mutable_avatarhash();
  inline ::std::string* release_avatarhash();
  
  // @@protoc_insertion_point(class_scope:AvatarRequestMessage)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_avatarhash();
  inline void clear_has_avatarhash();
  
  ::std::string* avatarhash_;
  ::google::protobuf::uint32 requestid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static AvatarRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class AvatarHeaderMessage : public ::google::protobuf::MessageLite {
 public:
  AvatarHeaderMessage();
  virtual ~AvatarHeaderMessage();
  
  AvatarHeaderMessage(const AvatarHeaderMessage& from);
  
  inline AvatarHeaderMessage& operator=(const AvatarHeaderMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const AvatarHeaderMessage& default_instance();
  
  void Swap(AvatarHeaderMessage* other);
  
  // implements Message ----------------------------------------------
  
  AvatarHeaderMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AvatarHeaderMessage& from);
  void MergeFrom(const AvatarHeaderMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 requestId = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint32 requestid() const;
  inline void set_requestid(::google::protobuf::uint32 value);
  
  // required .NetAvatarType avatarType = 2;
  inline bool has_avatartype() const;
  inline void clear_avatartype();
  static const int kAvatarTypeFieldNumber = 2;
  inline NetAvatarType avatartype() const;
  inline void set_avatartype(NetAvatarType value);
  
  // required uint32 avatarSize = 3;
  inline bool has_avatarsize() const;
  inline void clear_avatarsize();
  static const int kAvatarSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 avatarsize() const;
  inline void set_avatarsize(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:AvatarHeaderMessage)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_avatartype();
  inline void clear_has_avatartype();
  inline void set_has_avatarsize();
  inline void clear_has_avatarsize();
  
  ::google::protobuf::uint32 requestid_;
  int avatartype_;
  ::google::protobuf::uint32 avatarsize_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static AvatarHeaderMessage* default_instance_;
};
// -------------------------------------------------------------------

class AvatarDataMessage : public ::google::protobuf::MessageLite {
 public:
  AvatarDataMessage();
  virtual ~AvatarDataMessage();
  
  AvatarDataMessage(const AvatarDataMessage& from);
  
  inline AvatarDataMessage& operator=(const AvatarDataMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const AvatarDataMessage& default_instance();
  
  void Swap(AvatarDataMessage* other);
  
  // implements Message ----------------------------------------------
  
  AvatarDataMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AvatarDataMessage& from);
  void MergeFrom(const AvatarDataMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 requestId = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint32 requestid() const;
  inline void set_requestid(::google::protobuf::uint32 value);
  
  // required bytes avatarBlock = 2;
  inline bool has_avatarblock() const;
  inline void clear_avatarblock();
  static const int kAvatarBlockFieldNumber = 2;
  inline const ::std::string& avatarblock() const;
  inline void set_avatarblock(const ::std::string& value);
  inline void set_avatarblock(const char* value);
  inline void set_avatarblock(const void* value, size_t size);
  inline ::std::string* mutable_avatarblock();
  inline ::std::string* release_avatarblock();
  
  // @@protoc_insertion_point(class_scope:AvatarDataMessage)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_avatarblock();
  inline void clear_has_avatarblock();
  
  ::std::string* avatarblock_;
  ::google::protobuf::uint32 requestid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static AvatarDataMessage* default_instance_;
};
// -------------------------------------------------------------------

class AvatarEndMessage : public ::google::protobuf::MessageLite {
 public:
  AvatarEndMessage();
  virtual ~AvatarEndMessage();
  
  AvatarEndMessage(const AvatarEndMessage& from);
  
  inline AvatarEndMessage& operator=(const AvatarEndMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const AvatarEndMessage& default_instance();
  
  void Swap(AvatarEndMessage* other);
  
  // implements Message ----------------------------------------------
  
  AvatarEndMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AvatarEndMessage& from);
  void MergeFrom(const AvatarEndMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 requestId = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint32 requestid() const;
  inline void set_requestid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:AvatarEndMessage)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  
  ::google::protobuf::uint32 requestid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static AvatarEndMessage* default_instance_;
};
// -------------------------------------------------------------------

class UnknownAvatarMessage : public ::google::protobuf::MessageLite {
 public:
  UnknownAvatarMessage();
  virtual ~UnknownAvatarMessage();
  
  UnknownAvatarMessage(const UnknownAvatarMessage& from);
  
  inline UnknownAvatarMessage& operator=(const UnknownAvatarMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UnknownAvatarMessage& default_instance();
  
  void Swap(UnknownAvatarMessage* other);
  
  // implements Message ----------------------------------------------
  
  UnknownAvatarMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnknownAvatarMessage& from);
  void MergeFrom(const UnknownAvatarMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 requestId = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint32 requestid() const;
  inline void set_requestid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:UnknownAvatarMessage)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  
  ::google::protobuf::uint32 requestid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static UnknownAvatarMessage* default_instance_;
};
// -------------------------------------------------------------------

class PlayerListMessage : public ::google::protobuf::MessageLite {
 public:
  PlayerListMessage();
  virtual ~PlayerListMessage();
  
  PlayerListMessage(const PlayerListMessage& from);
  
  inline PlayerListMessage& operator=(const PlayerListMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PlayerListMessage& default_instance();
  
  void Swap(PlayerListMessage* other);
  
  // implements Message ----------------------------------------------
  
  PlayerListMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerListMessage& from);
  void MergeFrom(const PlayerListMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef PlayerListMessage_PlayerListNotification PlayerListNotification;
  static const PlayerListNotification playerListNew = PlayerListMessage_PlayerListNotification_playerListNew;
  static const PlayerListNotification playerListLeft = PlayerListMessage_PlayerListNotification_playerListLeft;
  static inline bool PlayerListNotification_IsValid(int value) {
    return PlayerListMessage_PlayerListNotification_IsValid(value);
  }
  static const PlayerListNotification PlayerListNotification_MIN =
    PlayerListMessage_PlayerListNotification_PlayerListNotification_MIN;
  static const PlayerListNotification PlayerListNotification_MAX =
    PlayerListMessage_PlayerListNotification_PlayerListNotification_MAX;
  static const int PlayerListNotification_ARRAYSIZE =
    PlayerListMessage_PlayerListNotification_PlayerListNotification_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required uint32 playerId = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);
  
  // required .PlayerListMessage.PlayerListNotification playerListNotification = 2;
  inline bool has_playerlistnotification() const;
  inline void clear_playerlistnotification();
  static const int kPlayerListNotificationFieldNumber = 2;
  inline ::PlayerListMessage_PlayerListNotification playerlistnotification() const;
  inline void set_playerlistnotification(::PlayerListMessage_PlayerListNotification value);
  
  // @@protoc_insertion_point(class_scope:PlayerListMessage)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_playerlistnotification();
  inline void clear_has_playerlistnotification();
  
  ::google::protobuf::uint32 playerid_;
  int playerlistnotification_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static PlayerListMessage* default_instance_;
};
// -------------------------------------------------------------------

class GameListNewMessage : public ::google::protobuf::MessageLite {
 public:
  GameListNewMessage();
  virtual ~GameListNewMessage();
  
  GameListNewMessage(const GameListNewMessage& from);
  
  inline GameListNewMessage& operator=(const GameListNewMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GameListNewMessage& default_instance();
  
  void Swap(GameListNewMessage* other);
  
  // implements Message ----------------------------------------------
  
  GameListNewMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameListNewMessage& from);
  void MergeFrom(const GameListNewMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required .NetGameMode gameMode = 2;
  inline bool has_gamemode() const;
  inline void clear_gamemode();
  static const int kGameModeFieldNumber = 2;
  inline NetGameMode gamemode() const;
  inline void set_gamemode(NetGameMode value);
  
  // required bool isPrivate = 3;
  inline bool has_isprivate() const;
  inline void clear_isprivate();
  static const int kIsPrivateFieldNumber = 3;
  inline bool isprivate() const;
  inline void set_isprivate(bool value);
  
  // repeated uint32 playerIds = 4 [packed = true];
  inline int playerids_size() const;
  inline void clear_playerids();
  static const int kPlayerIdsFieldNumber = 4;
  inline ::google::protobuf::uint32 playerids(int index) const;
  inline void set_playerids(int index, ::google::protobuf::uint32 value);
  inline void add_playerids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      playerids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_playerids();
  
  // required uint32 adminPlayerId = 5;
  inline bool has_adminplayerid() const;
  inline void clear_adminplayerid();
  static const int kAdminPlayerIdFieldNumber = 5;
  inline ::google::protobuf::uint32 adminplayerid() const;
  inline void set_adminplayerid(::google::protobuf::uint32 value);
  
  // required .NetGameInfo gameInfo = 6;
  inline bool has_gameinfo() const;
  inline void clear_gameinfo();
  static const int kGameInfoFieldNumber = 6;
  inline const ::NetGameInfo& gameinfo() const;
  inline ::NetGameInfo* mutable_gameinfo();
  inline ::NetGameInfo* release_gameinfo();
  
  // @@protoc_insertion_point(class_scope:GameListNewMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gamemode();
  inline void clear_has_gamemode();
  inline void set_has_isprivate();
  inline void clear_has_isprivate();
  inline void set_has_adminplayerid();
  inline void clear_has_adminplayerid();
  inline void set_has_gameinfo();
  inline void clear_has_gameinfo();
  
  ::google::protobuf::uint32 gameid_;
  int gamemode_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > playerids_;
  mutable int _playerids_cached_byte_size_;
  bool isprivate_;
  ::google::protobuf::uint32 adminplayerid_;
  ::NetGameInfo* gameinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static GameListNewMessage* default_instance_;
};
// -------------------------------------------------------------------

class GameListUpdateMessage : public ::google::protobuf::MessageLite {
 public:
  GameListUpdateMessage();
  virtual ~GameListUpdateMessage();
  
  GameListUpdateMessage(const GameListUpdateMessage& from);
  
  inline GameListUpdateMessage& operator=(const GameListUpdateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GameListUpdateMessage& default_instance();
  
  void Swap(GameListUpdateMessage* other);
  
  // implements Message ----------------------------------------------
  
  GameListUpdateMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameListUpdateMessage& from);
  void MergeFrom(const GameListUpdateMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required .NetGameMode gameMode = 2;
  inline bool has_gamemode() const;
  inline void clear_gamemode();
  static const int kGameModeFieldNumber = 2;
  inline NetGameMode gamemode() const;
  inline void set_gamemode(NetGameMode value);
  
  // @@protoc_insertion_point(class_scope:GameListUpdateMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gamemode();
  inline void clear_has_gamemode();
  
  ::google::protobuf::uint32 gameid_;
  int gamemode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static GameListUpdateMessage* default_instance_;
};
// -------------------------------------------------------------------

class GameListPlayerJoinedMessage : public ::google::protobuf::MessageLite {
 public:
  GameListPlayerJoinedMessage();
  virtual ~GameListPlayerJoinedMessage();
  
  GameListPlayerJoinedMessage(const GameListPlayerJoinedMessage& from);
  
  inline GameListPlayerJoinedMessage& operator=(const GameListPlayerJoinedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GameListPlayerJoinedMessage& default_instance();
  
  void Swap(GameListPlayerJoinedMessage* other);
  
  // implements Message ----------------------------------------------
  
  GameListPlayerJoinedMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameListPlayerJoinedMessage& from);
  void MergeFrom(const GameListPlayerJoinedMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:GameListPlayerJoinedMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static GameListPlayerJoinedMessage* default_instance_;
};
// -------------------------------------------------------------------

class GameListPlayerLeftMessage : public ::google::protobuf::MessageLite {
 public:
  GameListPlayerLeftMessage();
  virtual ~GameListPlayerLeftMessage();
  
  GameListPlayerLeftMessage(const GameListPlayerLeftMessage& from);
  
  inline GameListPlayerLeftMessage& operator=(const GameListPlayerLeftMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GameListPlayerLeftMessage& default_instance();
  
  void Swap(GameListPlayerLeftMessage* other);
  
  // implements Message ----------------------------------------------
  
  GameListPlayerLeftMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameListPlayerLeftMessage& from);
  void MergeFrom(const GameListPlayerLeftMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:GameListPlayerLeftMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static GameListPlayerLeftMessage* default_instance_;
};
// -------------------------------------------------------------------

class GameListAdminChangedMessage : public ::google::protobuf::MessageLite {
 public:
  GameListAdminChangedMessage();
  virtual ~GameListAdminChangedMessage();
  
  GameListAdminChangedMessage(const GameListAdminChangedMessage& from);
  
  inline GameListAdminChangedMessage& operator=(const GameListAdminChangedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GameListAdminChangedMessage& default_instance();
  
  void Swap(GameListAdminChangedMessage* other);
  
  // implements Message ----------------------------------------------
  
  GameListAdminChangedMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameListAdminChangedMessage& from);
  void MergeFrom(const GameListAdminChangedMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 newAdminPlayerId = 2;
  inline bool has_newadminplayerid() const;
  inline void clear_newadminplayerid();
  static const int kNewAdminPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 newadminplayerid() const;
  inline void set_newadminplayerid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:GameListAdminChangedMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_newadminplayerid();
  inline void clear_has_newadminplayerid();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 newadminplayerid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static GameListAdminChangedMessage* default_instance_;
};
// -------------------------------------------------------------------

class PlayerInfoRequestMessage : public ::google::protobuf::MessageLite {
 public:
  PlayerInfoRequestMessage();
  virtual ~PlayerInfoRequestMessage();
  
  PlayerInfoRequestMessage(const PlayerInfoRequestMessage& from);
  
  inline PlayerInfoRequestMessage& operator=(const PlayerInfoRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PlayerInfoRequestMessage& default_instance();
  
  void Swap(PlayerInfoRequestMessage* other);
  
  // implements Message ----------------------------------------------
  
  PlayerInfoRequestMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerInfoRequestMessage& from);
  void MergeFrom(const PlayerInfoRequestMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated uint32 playerId = 1 [packed = true];
  inline int playerid_size() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 playerid(int index) const;
  inline void set_playerid(int index, ::google::protobuf::uint32 value);
  inline void add_playerid(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      playerid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_playerid();
  
  // @@protoc_insertion_point(class_scope:PlayerInfoRequestMessage)
 private:
  
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > playerid_;
  mutable int _playerid_cached_byte_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static PlayerInfoRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class PlayerInfoReplyMessage_PlayerInfoData_AvatarData : public ::google::protobuf::MessageLite {
 public:
  PlayerInfoReplyMessage_PlayerInfoData_AvatarData();
  virtual ~PlayerInfoReplyMessage_PlayerInfoData_AvatarData();
  
  PlayerInfoReplyMessage_PlayerInfoData_AvatarData(const PlayerInfoReplyMessage_PlayerInfoData_AvatarData& from);
  
  inline PlayerInfoReplyMessage_PlayerInfoData_AvatarData& operator=(const PlayerInfoReplyMessage_PlayerInfoData_AvatarData& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PlayerInfoReplyMessage_PlayerInfoData_AvatarData& default_instance();
  
  void Swap(PlayerInfoReplyMessage_PlayerInfoData_AvatarData* other);
  
  // implements Message ----------------------------------------------
  
  PlayerInfoReplyMessage_PlayerInfoData_AvatarData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerInfoReplyMessage_PlayerInfoData_AvatarData& from);
  void MergeFrom(const PlayerInfoReplyMessage_PlayerInfoData_AvatarData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .NetAvatarType avatarType = 1;
  inline bool has_avatartype() const;
  inline void clear_avatartype();
  static const int kAvatarTypeFieldNumber = 1;
  inline NetAvatarType avatartype() const;
  inline void set_avatartype(NetAvatarType value);
  
  // required bytes avatarHash = 2;
  inline bool has_avatarhash() const;
  inline void clear_avatarhash();
  static const int kAvatarHashFieldNumber = 2;
  inline const ::std::string& avatarhash() const;
  inline void set_avatarhash(const ::std::string& value);
  inline void set_avatarhash(const char* value);
  inline void set_avatarhash(const void* value, size_t size);
  inline ::std::string* mutable_avatarhash();
  inline ::std::string* release_avatarhash();
  
  // @@protoc_insertion_point(class_scope:PlayerInfoReplyMessage.PlayerInfoData.AvatarData)
 private:
  inline void set_has_avatartype();
  inline void clear_has_avatartype();
  inline void set_has_avatarhash();
  inline void clear_has_avatarhash();
  
  ::std::string* avatarhash_;
  int avatartype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static PlayerInfoReplyMessage_PlayerInfoData_AvatarData* default_instance_;
};
// -------------------------------------------------------------------

class PlayerInfoReplyMessage_PlayerInfoData : public ::google::protobuf::MessageLite {
 public:
  PlayerInfoReplyMessage_PlayerInfoData();
  virtual ~PlayerInfoReplyMessage_PlayerInfoData();
  
  PlayerInfoReplyMessage_PlayerInfoData(const PlayerInfoReplyMessage_PlayerInfoData& from);
  
  inline PlayerInfoReplyMessage_PlayerInfoData& operator=(const PlayerInfoReplyMessage_PlayerInfoData& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PlayerInfoReplyMessage_PlayerInfoData& default_instance();
  
  void Swap(PlayerInfoReplyMessage_PlayerInfoData* other);
  
  // implements Message ----------------------------------------------
  
  PlayerInfoReplyMessage_PlayerInfoData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerInfoReplyMessage_PlayerInfoData& from);
  void MergeFrom(const PlayerInfoReplyMessage_PlayerInfoData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef PlayerInfoReplyMessage_PlayerInfoData_AvatarData AvatarData;
  
  // accessors -------------------------------------------------------
  
  // required string playerName = 1;
  inline bool has_playername() const;
  inline void clear_playername();
  static const int kPlayerNameFieldNumber = 1;
  inline const ::std::string& playername() const;
  inline void set_playername(const ::std::string& value);
  inline void set_playername(const char* value);
  inline void set_playername(const char* value, size_t size);
  inline ::std::string* mutable_playername();
  inline ::std::string* release_playername();
  
  // required bool isHuman = 2;
  inline bool has_ishuman() const;
  inline void clear_ishuman();
  static const int kIsHumanFieldNumber = 2;
  inline bool ishuman() const;
  inline void set_ishuman(bool value);
  
  // required .NetPlayerInfoRights playerRights = 3;
  inline bool has_playerrights() const;
  inline void clear_playerrights();
  static const int kPlayerRightsFieldNumber = 3;
  inline NetPlayerInfoRights playerrights() const;
  inline void set_playerrights(NetPlayerInfoRights value);
  
  // optional string countryCode = 4;
  inline bool has_countrycode() const;
  inline void clear_countrycode();
  static const int kCountryCodeFieldNumber = 4;
  inline const ::std::string& countrycode() const;
  inline void set_countrycode(const ::std::string& value);
  inline void set_countrycode(const char* value);
  inline void set_countrycode(const char* value, size_t size);
  inline ::std::string* mutable_countrycode();
  inline ::std::string* release_countrycode();
  
  // optional .PlayerInfoReplyMessage.PlayerInfoData.AvatarData avatarData = 5;
  inline bool has_avatardata() const;
  inline void clear_avatardata();
  static const int kAvatarDataFieldNumber = 5;
  inline const ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData& avatardata() const;
  inline ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* mutable_avatardata();
  inline ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* release_avatardata();
  
  // @@protoc_insertion_point(class_scope:PlayerInfoReplyMessage.PlayerInfoData)
 private:
  inline void set_has_playername();
  inline void clear_has_playername();
  inline void set_has_ishuman();
  inline void clear_has_ishuman();
  inline void set_has_playerrights();
  inline void clear_has_playerrights();
  inline void set_has_countrycode();
  inline void clear_has_countrycode();
  inline void set_has_avatardata();
  inline void clear_has_avatardata();
  
  ::std::string* playername_;
  bool ishuman_;
  int playerrights_;
  ::std::string* countrycode_;
  ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* avatardata_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static PlayerInfoReplyMessage_PlayerInfoData* default_instance_;
};
// -------------------------------------------------------------------

class PlayerInfoReplyMessage : public ::google::protobuf::MessageLite {
 public:
  PlayerInfoReplyMessage();
  virtual ~PlayerInfoReplyMessage();
  
  PlayerInfoReplyMessage(const PlayerInfoReplyMessage& from);
  
  inline PlayerInfoReplyMessage& operator=(const PlayerInfoReplyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PlayerInfoReplyMessage& default_instance();
  
  void Swap(PlayerInfoReplyMessage* other);
  
  // implements Message ----------------------------------------------
  
  PlayerInfoReplyMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerInfoReplyMessage& from);
  void MergeFrom(const PlayerInfoReplyMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef PlayerInfoReplyMessage_PlayerInfoData PlayerInfoData;
  
  // accessors -------------------------------------------------------
  
  // required uint32 playerId = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);
  
  // optional .PlayerInfoReplyMessage.PlayerInfoData playerInfoData = 2;
  inline bool has_playerinfodata() const;
  inline void clear_playerinfodata();
  static const int kPlayerInfoDataFieldNumber = 2;
  inline const ::PlayerInfoReplyMessage_PlayerInfoData& playerinfodata() const;
  inline ::PlayerInfoReplyMessage_PlayerInfoData* mutable_playerinfodata();
  inline ::PlayerInfoReplyMessage_PlayerInfoData* release_playerinfodata();
  
  // @@protoc_insertion_point(class_scope:PlayerInfoReplyMessage)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_playerinfodata();
  inline void clear_has_playerinfodata();
  
  ::PlayerInfoReplyMessage_PlayerInfoData* playerinfodata_;
  ::google::protobuf::uint32 playerid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static PlayerInfoReplyMessage* default_instance_;
};
// -------------------------------------------------------------------

class SubscriptionRequestMessage : public ::google::protobuf::MessageLite {
 public:
  SubscriptionRequestMessage();
  virtual ~SubscriptionRequestMessage();
  
  SubscriptionRequestMessage(const SubscriptionRequestMessage& from);
  
  inline SubscriptionRequestMessage& operator=(const SubscriptionRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const SubscriptionRequestMessage& default_instance();
  
  void Swap(SubscriptionRequestMessage* other);
  
  // implements Message ----------------------------------------------
  
  SubscriptionRequestMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SubscriptionRequestMessage& from);
  void MergeFrom(const SubscriptionRequestMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef SubscriptionRequestMessage_SubscriptionAction SubscriptionAction;
  static const SubscriptionAction unsubscribeGameList = SubscriptionRequestMessage_SubscriptionAction_unsubscribeGameList;
  static const SubscriptionAction resubscribeGameList = SubscriptionRequestMessage_SubscriptionAction_resubscribeGameList;
  static inline bool SubscriptionAction_IsValid(int value) {
    return SubscriptionRequestMessage_SubscriptionAction_IsValid(value);
  }
  static const SubscriptionAction SubscriptionAction_MIN =
    SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_MIN;
  static const SubscriptionAction SubscriptionAction_MAX =
    SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_MAX;
  static const int SubscriptionAction_ARRAYSIZE =
    SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .SubscriptionRequestMessage.SubscriptionAction subscriptionAction = 1;
  inline bool has_subscriptionaction() const;
  inline void clear_subscriptionaction();
  static const int kSubscriptionActionFieldNumber = 1;
  inline ::SubscriptionRequestMessage_SubscriptionAction subscriptionaction() const;
  inline void set_subscriptionaction(::SubscriptionRequestMessage_SubscriptionAction value);
  
  // @@protoc_insertion_point(class_scope:SubscriptionRequestMessage)
 private:
  inline void set_has_subscriptionaction();
  inline void clear_has_subscriptionaction();
  
  int subscriptionaction_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static SubscriptionRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class JoinExistingGameMessage : public ::google::protobuf::MessageLite {
 public:
  JoinExistingGameMessage();
  virtual ~JoinExistingGameMessage();
  
  JoinExistingGameMessage(const JoinExistingGameMessage& from);
  
  inline JoinExistingGameMessage& operator=(const JoinExistingGameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const JoinExistingGameMessage& default_instance();
  
  void Swap(JoinExistingGameMessage* other);
  
  // implements Message ----------------------------------------------
  
  JoinExistingGameMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const JoinExistingGameMessage& from);
  void MergeFrom(const JoinExistingGameMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // optional bool autoLeave = 3;
  inline bool has_autoleave() const;
  inline void clear_autoleave();
  static const int kAutoLeaveFieldNumber = 3;
  inline bool autoleave() const;
  inline void set_autoleave(bool value);
  
  // @@protoc_insertion_point(class_scope:JoinExistingGameMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_autoleave();
  inline void clear_has_autoleave();
  
  ::std::string* password_;
  ::google::protobuf::uint32 gameid_;
  bool autoleave_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static JoinExistingGameMessage* default_instance_;
};
// -------------------------------------------------------------------

class JoinNewGameMessage : public ::google::protobuf::MessageLite {
 public:
  JoinNewGameMessage();
  virtual ~JoinNewGameMessage();
  
  JoinNewGameMessage(const JoinNewGameMessage& from);
  
  inline JoinNewGameMessage& operator=(const JoinNewGameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const JoinNewGameMessage& default_instance();
  
  void Swap(JoinNewGameMessage* other);
  
  // implements Message ----------------------------------------------
  
  JoinNewGameMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const JoinNewGameMessage& from);
  void MergeFrom(const JoinNewGameMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .NetGameInfo gameInfo = 1;
  inline bool has_gameinfo() const;
  inline void clear_gameinfo();
  static const int kGameInfoFieldNumber = 1;
  inline const ::NetGameInfo& gameinfo() const;
  inline ::NetGameInfo* mutable_gameinfo();
  inline ::NetGameInfo* release_gameinfo();
  
  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // optional bool autoLeave = 3;
  inline bool has_autoleave() const;
  inline void clear_autoleave();
  static const int kAutoLeaveFieldNumber = 3;
  inline bool autoleave() const;
  inline void set_autoleave(bool value);
  
  // @@protoc_insertion_point(class_scope:JoinNewGameMessage)
 private:
  inline void set_has_gameinfo();
  inline void clear_has_gameinfo();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_autoleave();
  inline void clear_has_autoleave();
  
  ::NetGameInfo* gameinfo_;
  ::std::string* password_;
  bool autoleave_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static JoinNewGameMessage* default_instance_;
};
// -------------------------------------------------------------------

class RejoinExistingGameMessage : public ::google::protobuf::MessageLite {
 public:
  RejoinExistingGameMessage();
  virtual ~RejoinExistingGameMessage();
  
  RejoinExistingGameMessage(const RejoinExistingGameMessage& from);
  
  inline RejoinExistingGameMessage& operator=(const RejoinExistingGameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const RejoinExistingGameMessage& default_instance();
  
  void Swap(RejoinExistingGameMessage* other);
  
  // implements Message ----------------------------------------------
  
  RejoinExistingGameMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RejoinExistingGameMessage& from);
  void MergeFrom(const RejoinExistingGameMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // optional bool autoLeave = 2;
  inline bool has_autoleave() const;
  inline void clear_autoleave();
  static const int kAutoLeaveFieldNumber = 2;
  inline bool autoleave() const;
  inline void set_autoleave(bool value);
  
  // @@protoc_insertion_point(class_scope:RejoinExistingGameMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_autoleave();
  inline void clear_has_autoleave();
  
  ::google::protobuf::uint32 gameid_;
  bool autoleave_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static RejoinExistingGameMessage* default_instance_;
};
// -------------------------------------------------------------------

class JoinGameAckMessage : public ::google::protobuf::MessageLite {
 public:
  JoinGameAckMessage();
  virtual ~JoinGameAckMessage();
  
  JoinGameAckMessage(const JoinGameAckMessage& from);
  
  inline JoinGameAckMessage& operator=(const JoinGameAckMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const JoinGameAckMessage& default_instance();
  
  void Swap(JoinGameAckMessage* other);
  
  // implements Message ----------------------------------------------
  
  JoinGameAckMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const JoinGameAckMessage& from);
  void MergeFrom(const JoinGameAckMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required bool areYouGameAdmin = 2;
  inline bool has_areyougameadmin() const;
  inline void clear_areyougameadmin();
  static const int kAreYouGameAdminFieldNumber = 2;
  inline bool areyougameadmin() const;
  inline void set_areyougameadmin(bool value);
  
  // required .NetGameInfo gameInfo = 3;
  inline bool has_gameinfo() const;
  inline void clear_gameinfo();
  static const int kGameInfoFieldNumber = 3;
  inline const ::NetGameInfo& gameinfo() const;
  inline ::NetGameInfo* mutable_gameinfo();
  inline ::NetGameInfo* release_gameinfo();
  
  // @@protoc_insertion_point(class_scope:JoinGameAckMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_areyougameadmin();
  inline void clear_has_areyougameadmin();
  inline void set_has_gameinfo();
  inline void clear_has_gameinfo();
  
  ::google::protobuf::uint32 gameid_;
  bool areyougameadmin_;
  ::NetGameInfo* gameinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static JoinGameAckMessage* default_instance_;
};
// -------------------------------------------------------------------

class JoinGameFailedMessage : public ::google::protobuf::MessageLite {
 public:
  JoinGameFailedMessage();
  virtual ~JoinGameFailedMessage();
  
  JoinGameFailedMessage(const JoinGameFailedMessage& from);
  
  inline JoinGameFailedMessage& operator=(const JoinGameFailedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const JoinGameFailedMessage& default_instance();
  
  void Swap(JoinGameFailedMessage* other);
  
  // implements Message ----------------------------------------------
  
  JoinGameFailedMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const JoinGameFailedMessage& from);
  void MergeFrom(const JoinGameFailedMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef JoinGameFailedMessage_JoinGameFailureReason JoinGameFailureReason;
  static const JoinGameFailureReason invalidGame = JoinGameFailedMessage_JoinGameFailureReason_invalidGame;
  static const JoinGameFailureReason gameIsFull = JoinGameFailedMessage_JoinGameFailureReason_gameIsFull;
  static const JoinGameFailureReason gameIsRunning = JoinGameFailedMessage_JoinGameFailureReason_gameIsRunning;
  static const JoinGameFailureReason invalidPassword = JoinGameFailedMessage_JoinGameFailureReason_invalidPassword;
  static const JoinGameFailureReason notAllowedAsGuest = JoinGameFailedMessage_JoinGameFailureReason_notAllowedAsGuest;
  static const JoinGameFailureReason notInvited = JoinGameFailedMessage_JoinGameFailureReason_notInvited;
  static const JoinGameFailureReason gameNameInUse = JoinGameFailedMessage_JoinGameFailureReason_gameNameInUse;
  static const JoinGameFailureReason badGameName = JoinGameFailedMessage_JoinGameFailureReason_badGameName;
  static const JoinGameFailureReason invalidSettings = JoinGameFailedMessage_JoinGameFailureReason_invalidSettings;
  static const JoinGameFailureReason ipAddressBlocked = JoinGameFailedMessage_JoinGameFailureReason_ipAddressBlocked;
  static const JoinGameFailureReason rejoinFailed = JoinGameFailedMessage_JoinGameFailureReason_rejoinFailed;
  static inline bool JoinGameFailureReason_IsValid(int value) {
    return JoinGameFailedMessage_JoinGameFailureReason_IsValid(value);
  }
  static const JoinGameFailureReason JoinGameFailureReason_MIN =
    JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_MIN;
  static const JoinGameFailureReason JoinGameFailureReason_MAX =
    JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_MAX;
  static const int JoinGameFailureReason_ARRAYSIZE =
    JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required .JoinGameFailedMessage.JoinGameFailureReason joinGameFailureReason = 2;
  inline bool has_joingamefailurereason() const;
  inline void clear_joingamefailurereason();
  static const int kJoinGameFailureReasonFieldNumber = 2;
  inline ::JoinGameFailedMessage_JoinGameFailureReason joingamefailurereason() const;
  inline void set_joingamefailurereason(::JoinGameFailedMessage_JoinGameFailureReason value);
  
  // @@protoc_insertion_point(class_scope:JoinGameFailedMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_joingamefailurereason();
  inline void clear_has_joingamefailurereason();
  
  ::google::protobuf::uint32 gameid_;
  int joingamefailurereason_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static JoinGameFailedMessage* default_instance_;
};
// -------------------------------------------------------------------

class GamePlayerJoinedMessage : public ::google::protobuf::MessageLite {
 public:
  GamePlayerJoinedMessage();
  virtual ~GamePlayerJoinedMessage();
  
  GamePlayerJoinedMessage(const GamePlayerJoinedMessage& from);
  
  inline GamePlayerJoinedMessage& operator=(const GamePlayerJoinedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GamePlayerJoinedMessage& default_instance();
  
  void Swap(GamePlayerJoinedMessage* other);
  
  // implements Message ----------------------------------------------
  
  GamePlayerJoinedMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GamePlayerJoinedMessage& from);
  void MergeFrom(const GamePlayerJoinedMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);
  
  // required bool isGameAdmin = 3;
  inline bool has_isgameadmin() const;
  inline void clear_isgameadmin();
  static const int kIsGameAdminFieldNumber = 3;
  inline bool isgameadmin() const;
  inline void set_isgameadmin(bool value);
  
  // @@protoc_insertion_point(class_scope:GamePlayerJoinedMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_isgameadmin();
  inline void clear_has_isgameadmin();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  bool isgameadmin_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static GamePlayerJoinedMessage* default_instance_;
};
// -------------------------------------------------------------------

class GamePlayerLeftMessage : public ::google::protobuf::MessageLite {
 public:
  GamePlayerLeftMessage();
  virtual ~GamePlayerLeftMessage();
  
  GamePlayerLeftMessage(const GamePlayerLeftMessage& from);
  
  inline GamePlayerLeftMessage& operator=(const GamePlayerLeftMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GamePlayerLeftMessage& default_instance();
  
  void Swap(GamePlayerLeftMessage* other);
  
  // implements Message ----------------------------------------------
  
  GamePlayerLeftMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GamePlayerLeftMessage& from);
  void MergeFrom(const GamePlayerLeftMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GamePlayerLeftMessage_GamePlayerLeftReason GamePlayerLeftReason;
  static const GamePlayerLeftReason leftOnRequest = GamePlayerLeftMessage_GamePlayerLeftReason_leftOnRequest;
  static const GamePlayerLeftReason leftKicked = GamePlayerLeftMessage_GamePlayerLeftReason_leftKicked;
  static const GamePlayerLeftReason leftError = GamePlayerLeftMessage_GamePlayerLeftReason_leftError;
  static inline bool GamePlayerLeftReason_IsValid(int value) {
    return GamePlayerLeftMessage_GamePlayerLeftReason_IsValid(value);
  }
  static const GamePlayerLeftReason GamePlayerLeftReason_MIN =
    GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_MIN;
  static const GamePlayerLeftReason GamePlayerLeftReason_MAX =
    GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_MAX;
  static const int GamePlayerLeftReason_ARRAYSIZE =
    GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);
  
  // required .GamePlayerLeftMessage.GamePlayerLeftReason gamePlayerLeftReason = 3;
  inline bool has_gameplayerleftreason() const;
  inline void clear_gameplayerleftreason();
  static const int kGamePlayerLeftReasonFieldNumber = 3;
  inline ::GamePlayerLeftMessage_GamePlayerLeftReason gameplayerleftreason() const;
  inline void set_gameplayerleftreason(::GamePlayerLeftMessage_GamePlayerLeftReason value);
  
  // @@protoc_insertion_point(class_scope:GamePlayerLeftMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_gameplayerleftreason();
  inline void clear_has_gameplayerleftreason();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  int gameplayerleftreason_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static GamePlayerLeftMessage* default_instance_;
};
// -------------------------------------------------------------------

class GameAdminChangedMessage : public ::google::protobuf::MessageLite {
 public:
  GameAdminChangedMessage();
  virtual ~GameAdminChangedMessage();
  
  GameAdminChangedMessage(const GameAdminChangedMessage& from);
  
  inline GameAdminChangedMessage& operator=(const GameAdminChangedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GameAdminChangedMessage& default_instance();
  
  void Swap(GameAdminChangedMessage* other);
  
  // implements Message ----------------------------------------------
  
  GameAdminChangedMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameAdminChangedMessage& from);
  void MergeFrom(const GameAdminChangedMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 newAdminPlayerId = 2;
  inline bool has_newadminplayerid() const;
  inline void clear_newadminplayerid();
  static const int kNewAdminPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 newadminplayerid() const;
  inline void set_newadminplayerid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:GameAdminChangedMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_newadminplayerid();
  inline void clear_has_newadminplayerid();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 newadminplayerid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static GameAdminChangedMessage* default_instance_;
};
// -------------------------------------------------------------------

class RemovedFromGameMessage : public ::google::protobuf::MessageLite {
 public:
  RemovedFromGameMessage();
  virtual ~RemovedFromGameMessage();
  
  RemovedFromGameMessage(const RemovedFromGameMessage& from);
  
  inline RemovedFromGameMessage& operator=(const RemovedFromGameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const RemovedFromGameMessage& default_instance();
  
  void Swap(RemovedFromGameMessage* other);
  
  // implements Message ----------------------------------------------
  
  RemovedFromGameMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RemovedFromGameMessage& from);
  void MergeFrom(const RemovedFromGameMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameReason;
  static const RemovedFromGameReason removedOnRequest = RemovedFromGameMessage_RemovedFromGameReason_removedOnRequest;
  static const RemovedFromGameReason kickedFromGame = RemovedFromGameMessage_RemovedFromGameReason_kickedFromGame;
  static const RemovedFromGameReason gameIsFull = RemovedFromGameMessage_RemovedFromGameReason_gameIsFull;
  static const RemovedFromGameReason gameIsRunning = RemovedFromGameMessage_RemovedFromGameReason_gameIsRunning;
  static const RemovedFromGameReason gameTimeout = RemovedFromGameMessage_RemovedFromGameReason_gameTimeout;
  static const RemovedFromGameReason removedStartFailed = RemovedFromGameMessage_RemovedFromGameReason_removedStartFailed;
  static inline bool RemovedFromGameReason_IsValid(int value) {
    return RemovedFromGameMessage_RemovedFromGameReason_IsValid(value);
  }
  static const RemovedFromGameReason RemovedFromGameReason_MIN =
    RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_MIN;
  static const RemovedFromGameReason RemovedFromGameReason_MAX =
    RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_MAX;
  static const int RemovedFromGameReason_ARRAYSIZE =
    RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required .RemovedFromGameMessage.RemovedFromGameReason removedFromGameReason = 2;
  inline bool has_removedfromgamereason() const;
  inline void clear_removedfromgamereason();
  static const int kRemovedFromGameReasonFieldNumber = 2;
  inline ::RemovedFromGameMessage_RemovedFromGameReason removedfromgamereason() const;
  inline void set_removedfromgamereason(::RemovedFromGameMessage_RemovedFromGameReason value);
  
  // @@protoc_insertion_point(class_scope:RemovedFromGameMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_removedfromgamereason();
  inline void clear_has_removedfromgamereason();
  
  ::google::protobuf::uint32 gameid_;
  int removedfromgamereason_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static RemovedFromGameMessage* default_instance_;
};
// -------------------------------------------------------------------

class KickPlayerRequestMessage : public ::google::protobuf::MessageLite {
 public:
  KickPlayerRequestMessage();
  virtual ~KickPlayerRequestMessage();
  
  KickPlayerRequestMessage(const KickPlayerRequestMessage& from);
  
  inline KickPlayerRequestMessage& operator=(const KickPlayerRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const KickPlayerRequestMessage& default_instance();
  
  void Swap(KickPlayerRequestMessage* other);
  
  // implements Message ----------------------------------------------
  
  KickPlayerRequestMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const KickPlayerRequestMessage& from);
  void MergeFrom(const KickPlayerRequestMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:KickPlayerRequestMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static KickPlayerRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class LeaveGameRequestMessage : public ::google::protobuf::MessageLite {
 public:
  LeaveGameRequestMessage();
  virtual ~LeaveGameRequestMessage();
  
  LeaveGameRequestMessage(const LeaveGameRequestMessage& from);
  
  inline LeaveGameRequestMessage& operator=(const LeaveGameRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const LeaveGameRequestMessage& default_instance();
  
  void Swap(LeaveGameRequestMessage* other);
  
  // implements Message ----------------------------------------------
  
  LeaveGameRequestMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LeaveGameRequestMessage& from);
  void MergeFrom(const LeaveGameRequestMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:LeaveGameRequestMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  
  ::google::protobuf::uint32 gameid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static LeaveGameRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class InvitePlayerToGameMessage : public ::google::protobuf::MessageLite {
 public:
  InvitePlayerToGameMessage();
  virtual ~InvitePlayerToGameMessage();
  
  InvitePlayerToGameMessage(const InvitePlayerToGameMessage& from);
  
  inline InvitePlayerToGameMessage& operator=(const InvitePlayerToGameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const InvitePlayerToGameMessage& default_instance();
  
  void Swap(InvitePlayerToGameMessage* other);
  
  // implements Message ----------------------------------------------
  
  InvitePlayerToGameMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InvitePlayerToGameMessage& from);
  void MergeFrom(const InvitePlayerToGameMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:InvitePlayerToGameMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static InvitePlayerToGameMessage* default_instance_;
};
// -------------------------------------------------------------------

class InviteNotifyMessage : public ::google::protobuf::MessageLite {
 public:
  InviteNotifyMessage();
  virtual ~InviteNotifyMessage();
  
  InviteNotifyMessage(const InviteNotifyMessage& from);
  
  inline InviteNotifyMessage& operator=(const InviteNotifyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const InviteNotifyMessage& default_instance();
  
  void Swap(InviteNotifyMessage* other);
  
  // implements Message ----------------------------------------------
  
  InviteNotifyMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InviteNotifyMessage& from);
  void MergeFrom(const InviteNotifyMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 playerIdWho = 2;
  inline bool has_playeridwho() const;
  inline void clear_playeridwho();
  static const int kPlayerIdWhoFieldNumber = 2;
  inline ::google::protobuf::uint32 playeridwho() const;
  inline void set_playeridwho(::google::protobuf::uint32 value);
  
  // required uint32 playerIdByWhom = 3;
  inline bool has_playeridbywhom() const;
  inline void clear_playeridbywhom();
  static const int kPlayerIdByWhomFieldNumber = 3;
  inline ::google::protobuf::uint32 playeridbywhom() const;
  inline void set_playeridbywhom(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:InviteNotifyMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playeridwho();
  inline void clear_has_playeridwho();
  inline void set_has_playeridbywhom();
  inline void clear_has_playeridbywhom();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playeridwho_;
  ::google::protobuf::uint32 playeridbywhom_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static InviteNotifyMessage* default_instance_;
};
// -------------------------------------------------------------------

class RejectGameInvitationMessage : public ::google::protobuf::MessageLite {
 public:
  RejectGameInvitationMessage();
  virtual ~RejectGameInvitationMessage();
  
  RejectGameInvitationMessage(const RejectGameInvitationMessage& from);
  
  inline RejectGameInvitationMessage& operator=(const RejectGameInvitationMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const RejectGameInvitationMessage& default_instance();
  
  void Swap(RejectGameInvitationMessage* other);
  
  // implements Message ----------------------------------------------
  
  RejectGameInvitationMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RejectGameInvitationMessage& from);
  void MergeFrom(const RejectGameInvitationMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef RejectGameInvitationMessage_RejectGameInvReason RejectGameInvReason;
  static const RejectGameInvReason rejectReasonNo = RejectGameInvitationMessage_RejectGameInvReason_rejectReasonNo;
  static const RejectGameInvReason rejectReasonBusy = RejectGameInvitationMessage_RejectGameInvReason_rejectReasonBusy;
  static inline bool RejectGameInvReason_IsValid(int value) {
    return RejectGameInvitationMessage_RejectGameInvReason_IsValid(value);
  }
  static const RejectGameInvReason RejectGameInvReason_MIN =
    RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_MIN;
  static const RejectGameInvReason RejectGameInvReason_MAX =
    RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_MAX;
  static const int RejectGameInvReason_ARRAYSIZE =
    RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required .RejectGameInvitationMessage.RejectGameInvReason myRejectReason = 2;
  inline bool has_myrejectreason() const;
  inline void clear_myrejectreason();
  static const int kMyRejectReasonFieldNumber = 2;
  inline ::RejectGameInvitationMessage_RejectGameInvReason myrejectreason() const;
  inline void set_myrejectreason(::RejectGameInvitationMessage_RejectGameInvReason value);
  
  // @@protoc_insertion_point(class_scope:RejectGameInvitationMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_myrejectreason();
  inline void clear_has_myrejectreason();
  
  ::google::protobuf::uint32 gameid_;
  int myrejectreason_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static RejectGameInvitationMessage* default_instance_;
};
// -------------------------------------------------------------------

class RejectInvNotifyMessage : public ::google::protobuf::MessageLite {
 public:
  RejectInvNotifyMessage();
  virtual ~RejectInvNotifyMessage();
  
  RejectInvNotifyMessage(const RejectInvNotifyMessage& from);
  
  inline RejectInvNotifyMessage& operator=(const RejectInvNotifyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const RejectInvNotifyMessage& default_instance();
  
  void Swap(RejectInvNotifyMessage* other);
  
  // implements Message ----------------------------------------------
  
  RejectInvNotifyMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RejectInvNotifyMessage& from);
  void MergeFrom(const RejectInvNotifyMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);
  
  // required .RejectGameInvitationMessage.RejectGameInvReason playerRejectReason = 3;
  inline bool has_playerrejectreason() const;
  inline void clear_playerrejectreason();
  static const int kPlayerRejectReasonFieldNumber = 3;
  inline ::RejectGameInvitationMessage_RejectGameInvReason playerrejectreason() const;
  inline void set_playerrejectreason(::RejectGameInvitationMessage_RejectGameInvReason value);
  
  // @@protoc_insertion_point(class_scope:RejectInvNotifyMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_playerrejectreason();
  inline void clear_has_playerrejectreason();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  int playerrejectreason_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static RejectInvNotifyMessage* default_instance_;
};
// -------------------------------------------------------------------

class StartEventMessage : public ::google::protobuf::MessageLite {
 public:
  StartEventMessage();
  virtual ~StartEventMessage();
  
  StartEventMessage(const StartEventMessage& from);
  
  inline StartEventMessage& operator=(const StartEventMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const StartEventMessage& default_instance();
  
  void Swap(StartEventMessage* other);
  
  // implements Message ----------------------------------------------
  
  StartEventMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartEventMessage& from);
  void MergeFrom(const StartEventMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef StartEventMessage_StartEventType StartEventType;
  static const StartEventType startEvent = StartEventMessage_StartEventType_startEvent;
  static const StartEventType rejoinEvent = StartEventMessage_StartEventType_rejoinEvent;
  static inline bool StartEventType_IsValid(int value) {
    return StartEventMessage_StartEventType_IsValid(value);
  }
  static const StartEventType StartEventType_MIN =
    StartEventMessage_StartEventType_StartEventType_MIN;
  static const StartEventType StartEventType_MAX =
    StartEventMessage_StartEventType_StartEventType_MAX;
  static const int StartEventType_ARRAYSIZE =
    StartEventMessage_StartEventType_StartEventType_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required .StartEventMessage.StartEventType startEventType = 2;
  inline bool has_starteventtype() const;
  inline void clear_starteventtype();
  static const int kStartEventTypeFieldNumber = 2;
  inline ::StartEventMessage_StartEventType starteventtype() const;
  inline void set_starteventtype(::StartEventMessage_StartEventType value);
  
  // optional bool fillWithComputerPlayers = 3;
  inline bool has_fillwithcomputerplayers() const;
  inline void clear_fillwithcomputerplayers();
  static const int kFillWithComputerPlayersFieldNumber = 3;
  inline bool fillwithcomputerplayers() const;
  inline void set_fillwithcomputerplayers(bool value);
  
  // @@protoc_insertion_point(class_scope:StartEventMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_starteventtype();
  inline void clear_has_starteventtype();
  inline void set_has_fillwithcomputerplayers();
  inline void clear_has_fillwithcomputerplayers();
  
  ::google::protobuf::uint32 gameid_;
  int starteventtype_;
  bool fillwithcomputerplayers_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static StartEventMessage* default_instance_;
};
// -------------------------------------------------------------------

class StartEventAckMessage : public ::google::protobuf::MessageLite {
 public:
  StartEventAckMessage();
  virtual ~StartEventAckMessage();
  
  StartEventAckMessage(const StartEventAckMessage& from);
  
  inline StartEventAckMessage& operator=(const StartEventAckMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const StartEventAckMessage& default_instance();
  
  void Swap(StartEventAckMessage* other);
  
  // implements Message ----------------------------------------------
  
  StartEventAckMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartEventAckMessage& from);
  void MergeFrom(const StartEventAckMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:StartEventAckMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  
  ::google::protobuf::uint32 gameid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static StartEventAckMessage* default_instance_;
};
// -------------------------------------------------------------------

class GameStartInitialMessage : public ::google::protobuf::MessageLite {
 public:
  GameStartInitialMessage();
  virtual ~GameStartInitialMessage();
  
  GameStartInitialMessage(const GameStartInitialMessage& from);
  
  inline GameStartInitialMessage& operator=(const GameStartInitialMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GameStartInitialMessage& default_instance();
  
  void Swap(GameStartInitialMessage* other);
  
  // implements Message ----------------------------------------------
  
  GameStartInitialMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameStartInitialMessage& from);
  void MergeFrom(const GameStartInitialMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 startDealerPlayerId = 2;
  inline bool has_startdealerplayerid() const;
  inline void clear_startdealerplayerid();
  static const int kStartDealerPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 startdealerplayerid() const;
  inline void set_startdealerplayerid(::google::protobuf::uint32 value);
  
  // repeated uint32 playerSeats = 3 [packed = true];
  inline int playerseats_size() const;
  inline void clear_playerseats();
  static const int kPlayerSeatsFieldNumber = 3;
  inline ::google::protobuf::uint32 playerseats(int index) const;
  inline void set_playerseats(int index, ::google::protobuf::uint32 value);
  inline void add_playerseats(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      playerseats() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_playerseats();
  
  // @@protoc_insertion_point(class_scope:GameStartInitialMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_startdealerplayerid();
  inline void clear_has_startdealerplayerid();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 startdealerplayerid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > playerseats_;
  mutable int _playerseats_cached_byte_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static GameStartInitialMessage* default_instance_;
};
// -------------------------------------------------------------------

class GameStartRejoinMessage_RejoinPlayerData : public ::google::protobuf::MessageLite {
 public:
  GameStartRejoinMessage_RejoinPlayerData();
  virtual ~GameStartRejoinMessage_RejoinPlayerData();
  
  GameStartRejoinMessage_RejoinPlayerData(const GameStartRejoinMessage_RejoinPlayerData& from);
  
  inline GameStartRejoinMessage_RejoinPlayerData& operator=(const GameStartRejoinMessage_RejoinPlayerData& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GameStartRejoinMessage_RejoinPlayerData& default_instance();
  
  void Swap(GameStartRejoinMessage_RejoinPlayerData* other);
  
  // implements Message ----------------------------------------------
  
  GameStartRejoinMessage_RejoinPlayerData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameStartRejoinMessage_RejoinPlayerData& from);
  void MergeFrom(const GameStartRejoinMessage_RejoinPlayerData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 playerId = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);
  
  // required uint32 playerMoney = 2;
  inline bool has_playermoney() const;
  inline void clear_playermoney();
  static const int kPlayerMoneyFieldNumber = 2;
  inline ::google::protobuf::uint32 playermoney() const;
  inline void set_playermoney(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:GameStartRejoinMessage.RejoinPlayerData)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_playermoney();
  inline void clear_has_playermoney();
  
  ::google::protobuf::uint32 playerid_;
  ::google::protobuf::uint32 playermoney_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static GameStartRejoinMessage_RejoinPlayerData* default_instance_;
};
// -------------------------------------------------------------------

class GameStartRejoinMessage : public ::google::protobuf::MessageLite {
 public:
  GameStartRejoinMessage();
  virtual ~GameStartRejoinMessage();
  
  GameStartRejoinMessage(const GameStartRejoinMessage& from);
  
  inline GameStartRejoinMessage& operator=(const GameStartRejoinMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GameStartRejoinMessage& default_instance();
  
  void Swap(GameStartRejoinMessage* other);
  
  // implements Message ----------------------------------------------
  
  GameStartRejoinMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameStartRejoinMessage& from);
  void MergeFrom(const GameStartRejoinMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GameStartRejoinMessage_RejoinPlayerData RejoinPlayerData;
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 startDealerPlayerId = 2;
  inline bool has_startdealerplayerid() const;
  inline void clear_startdealerplayerid();
  static const int kStartDealerPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 startdealerplayerid() const;
  inline void set_startdealerplayerid(::google::protobuf::uint32 value);
  
  // required uint32 handNum = 3;
  inline bool has_handnum() const;
  inline void clear_handnum();
  static const int kHandNumFieldNumber = 3;
  inline ::google::protobuf::uint32 handnum() const;
  inline void set_handnum(::google::protobuf::uint32 value);
  
  // repeated .GameStartRejoinMessage.RejoinPlayerData rejoinPlayerData = 4;
  inline int rejoinplayerdata_size() const;
  inline void clear_rejoinplayerdata();
  static const int kRejoinPlayerDataFieldNumber = 4;
  inline const ::GameStartRejoinMessage_RejoinPlayerData& rejoinplayerdata(int index) const;
  inline ::GameStartRejoinMessage_RejoinPlayerData* mutable_rejoinplayerdata(int index);
  inline ::GameStartRejoinMessage_RejoinPlayerData* add_rejoinplayerdata();
  inline const ::google::protobuf::RepeatedPtrField< ::GameStartRejoinMessage_RejoinPlayerData >&
      rejoinplayerdata() const;
  inline ::google::protobuf::RepeatedPtrField< ::GameStartRejoinMessage_RejoinPlayerData >*
      mutable_rejoinplayerdata();
  
  // @@protoc_insertion_point(class_scope:GameStartRejoinMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_startdealerplayerid();
  inline void clear_has_startdealerplayerid();
  inline void set_has_handnum();
  inline void clear_has_handnum();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 startdealerplayerid_;
  ::google::protobuf::RepeatedPtrField< ::GameStartRejoinMessage_RejoinPlayerData > rejoinplayerdata_;
  ::google::protobuf::uint32 handnum_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static GameStartRejoinMessage* default_instance_;
};
// -------------------------------------------------------------------

class HandStartMessage_PlainCards : public ::google::protobuf::MessageLite {
 public:
  HandStartMessage_PlainCards();
  virtual ~HandStartMessage_PlainCards();
  
  HandStartMessage_PlainCards(const HandStartMessage_PlainCards& from);
  
  inline HandStartMessage_PlainCards& operator=(const HandStartMessage_PlainCards& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const HandStartMessage_PlainCards& default_instance();
  
  void Swap(HandStartMessage_PlainCards* other);
  
  // implements Message ----------------------------------------------
  
  HandStartMessage_PlainCards* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HandStartMessage_PlainCards& from);
  void MergeFrom(const HandStartMessage_PlainCards& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 plainCard1 = 1;
  inline bool has_plaincard1() const;
  inline void clear_plaincard1();
  static const int kPlainCard1FieldNumber = 1;
  inline ::google::protobuf::uint32 plaincard1() const;
  inline void set_plaincard1(::google::protobuf::uint32 value);
  
  // required uint32 plainCard2 = 2;
  inline bool has_plaincard2() const;
  inline void clear_plaincard2();
  static const int kPlainCard2FieldNumber = 2;
  inline ::google::protobuf::uint32 plaincard2() const;
  inline void set_plaincard2(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:HandStartMessage.PlainCards)
 private:
  inline void set_has_plaincard1();
  inline void clear_has_plaincard1();
  inline void set_has_plaincard2();
  inline void clear_has_plaincard2();
  
  ::google::protobuf::uint32 plaincard1_;
  ::google::protobuf::uint32 plaincard2_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static HandStartMessage_PlainCards* default_instance_;
};
// -------------------------------------------------------------------

class HandStartMessage : public ::google::protobuf::MessageLite {
 public:
  HandStartMessage();
  virtual ~HandStartMessage();
  
  HandStartMessage(const HandStartMessage& from);
  
  inline HandStartMessage& operator=(const HandStartMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const HandStartMessage& default_instance();
  
  void Swap(HandStartMessage* other);
  
  // implements Message ----------------------------------------------
  
  HandStartMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HandStartMessage& from);
  void MergeFrom(const HandStartMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef HandStartMessage_PlainCards PlainCards;
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // optional .HandStartMessage.PlainCards plainCards = 2;
  inline bool has_plaincards() const;
  inline void clear_plaincards();
  static const int kPlainCardsFieldNumber = 2;
  inline const ::HandStartMessage_PlainCards& plaincards() const;
  inline ::HandStartMessage_PlainCards* mutable_plaincards();
  inline ::HandStartMessage_PlainCards* release_plaincards();
  
  // optional bytes encryptedCards = 3;
  inline bool has_encryptedcards() const;
  inline void clear_encryptedcards();
  static const int kEncryptedCardsFieldNumber = 3;
  inline const ::std::string& encryptedcards() const;
  inline void set_encryptedcards(const ::std::string& value);
  inline void set_encryptedcards(const char* value);
  inline void set_encryptedcards(const void* value, size_t size);
  inline ::std::string* mutable_encryptedcards();
  inline ::std::string* release_encryptedcards();
  
  // required uint32 smallBlind = 4;
  inline bool has_smallblind() const;
  inline void clear_smallblind();
  static const int kSmallBlindFieldNumber = 4;
  inline ::google::protobuf::uint32 smallblind() const;
  inline void set_smallblind(::google::protobuf::uint32 value);
  
  // repeated .NetPlayerState seatStates = 5;
  inline int seatstates_size() const;
  inline void clear_seatstates();
  static const int kSeatStatesFieldNumber = 5;
  inline NetPlayerState seatstates(int index) const;
  inline void set_seatstates(int index, NetPlayerState value);
  inline void add_seatstates(NetPlayerState value);
  inline const ::google::protobuf::RepeatedField<int>& seatstates() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_seatstates();
  
  // @@protoc_insertion_point(class_scope:HandStartMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_plaincards();
  inline void clear_has_plaincards();
  inline void set_has_encryptedcards();
  inline void clear_has_encryptedcards();
  inline void set_has_smallblind();
  inline void clear_has_smallblind();
  
  ::HandStartMessage_PlainCards* plaincards_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 smallblind_;
  ::std::string* encryptedcards_;
  ::google::protobuf::RepeatedField<int> seatstates_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static HandStartMessage* default_instance_;
};
// -------------------------------------------------------------------

class PlayersTurnMessage : public ::google::protobuf::MessageLite {
 public:
  PlayersTurnMessage();
  virtual ~PlayersTurnMessage();
  
  PlayersTurnMessage(const PlayersTurnMessage& from);
  
  inline PlayersTurnMessage& operator=(const PlayersTurnMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PlayersTurnMessage& default_instance();
  
  void Swap(PlayersTurnMessage* other);
  
  // implements Message ----------------------------------------------
  
  PlayersTurnMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayersTurnMessage& from);
  void MergeFrom(const PlayersTurnMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);
  
  // required .NetGameState gameState = 3;
  inline bool has_gamestate() const;
  inline void clear_gamestate();
  static const int kGameStateFieldNumber = 3;
  inline NetGameState gamestate() const;
  inline void set_gamestate(NetGameState value);
  
  // @@protoc_insertion_point(class_scope:PlayersTurnMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_gamestate();
  inline void clear_has_gamestate();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  int gamestate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static PlayersTurnMessage* default_instance_;
};
// -------------------------------------------------------------------

class MyActionRequestMessage : public ::google::protobuf::MessageLite {
 public:
  MyActionRequestMessage();
  virtual ~MyActionRequestMessage();
  
  MyActionRequestMessage(const MyActionRequestMessage& from);
  
  inline MyActionRequestMessage& operator=(const MyActionRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const MyActionRequestMessage& default_instance();
  
  void Swap(MyActionRequestMessage* other);
  
  // implements Message ----------------------------------------------
  
  MyActionRequestMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MyActionRequestMessage& from);
  void MergeFrom(const MyActionRequestMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 handNum = 2;
  inline bool has_handnum() const;
  inline void clear_handnum();
  static const int kHandNumFieldNumber = 2;
  inline ::google::protobuf::uint32 handnum() const;
  inline void set_handnum(::google::protobuf::uint32 value);
  
  // required .NetGameState gameState = 3;
  inline bool has_gamestate() const;
  inline void clear_gamestate();
  static const int kGameStateFieldNumber = 3;
  inline NetGameState gamestate() const;
  inline void set_gamestate(NetGameState value);
  
  // required .NetPlayerAction myAction = 4;
  inline bool has_myaction() const;
  inline void clear_myaction();
  static const int kMyActionFieldNumber = 4;
  inline NetPlayerAction myaction() const;
  inline void set_myaction(NetPlayerAction value);
  
  // required uint32 myRelativeBet = 5;
  inline bool has_myrelativebet() const;
  inline void clear_myrelativebet();
  static const int kMyRelativeBetFieldNumber = 5;
  inline ::google::protobuf::uint32 myrelativebet() const;
  inline void set_myrelativebet(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:MyActionRequestMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_handnum();
  inline void clear_has_handnum();
  inline void set_has_gamestate();
  inline void clear_has_gamestate();
  inline void set_has_myaction();
  inline void clear_has_myaction();
  inline void set_has_myrelativebet();
  inline void clear_has_myrelativebet();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 handnum_;
  int gamestate_;
  int myaction_;
  ::google::protobuf::uint32 myrelativebet_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static MyActionRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class YourActionRejectedMessage : public ::google::protobuf::MessageLite {
 public:
  YourActionRejectedMessage();
  virtual ~YourActionRejectedMessage();
  
  YourActionRejectedMessage(const YourActionRejectedMessage& from);
  
  inline YourActionRejectedMessage& operator=(const YourActionRejectedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const YourActionRejectedMessage& default_instance();
  
  void Swap(YourActionRejectedMessage* other);
  
  // implements Message ----------------------------------------------
  
  YourActionRejectedMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const YourActionRejectedMessage& from);
  void MergeFrom(const YourActionRejectedMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef YourActionRejectedMessage_RejectionReason RejectionReason;
  static const RejectionReason rejectedInvalidGameState = YourActionRejectedMessage_RejectionReason_rejectedInvalidGameState;
  static const RejectionReason rejectedNotYourTurn = YourActionRejectedMessage_RejectionReason_rejectedNotYourTurn;
  static const RejectionReason rejectedActionNotAllowed = YourActionRejectedMessage_RejectionReason_rejectedActionNotAllowed;
  static inline bool RejectionReason_IsValid(int value) {
    return YourActionRejectedMessage_RejectionReason_IsValid(value);
  }
  static const RejectionReason RejectionReason_MIN =
    YourActionRejectedMessage_RejectionReason_RejectionReason_MIN;
  static const RejectionReason RejectionReason_MAX =
    YourActionRejectedMessage_RejectionReason_RejectionReason_MAX;
  static const int RejectionReason_ARRAYSIZE =
    YourActionRejectedMessage_RejectionReason_RejectionReason_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required .NetGameState gameState = 2;
  inline bool has_gamestate() const;
  inline void clear_gamestate();
  static const int kGameStateFieldNumber = 2;
  inline NetGameState gamestate() const;
  inline void set_gamestate(NetGameState value);
  
  // required .NetPlayerAction yourAction = 3;
  inline bool has_youraction() const;
  inline void clear_youraction();
  static const int kYourActionFieldNumber = 3;
  inline NetPlayerAction youraction() const;
  inline void set_youraction(NetPlayerAction value);
  
  // required uint32 yourRelativeBet = 4;
  inline bool has_yourrelativebet() const;
  inline void clear_yourrelativebet();
  static const int kYourRelativeBetFieldNumber = 4;
  inline ::google::protobuf::uint32 yourrelativebet() const;
  inline void set_yourrelativebet(::google::protobuf::uint32 value);
  
  // required .YourActionRejectedMessage.RejectionReason rejectionReason = 5;
  inline bool has_rejectionreason() const;
  inline void clear_rejectionreason();
  static const int kRejectionReasonFieldNumber = 5;
  inline ::YourActionRejectedMessage_RejectionReason rejectionreason() const;
  inline void set_rejectionreason(::YourActionRejectedMessage_RejectionReason value);
  
  // @@protoc_insertion_point(class_scope:YourActionRejectedMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gamestate();
  inline void clear_has_gamestate();
  inline void set_has_youraction();
  inline void clear_has_youraction();
  inline void set_has_yourrelativebet();
  inline void clear_has_yourrelativebet();
  inline void set_has_rejectionreason();
  inline void clear_has_rejectionreason();
  
  ::google::protobuf::uint32 gameid_;
  int gamestate_;
  int youraction_;
  ::google::protobuf::uint32 yourrelativebet_;
  int rejectionreason_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static YourActionRejectedMessage* default_instance_;
};
// -------------------------------------------------------------------

class PlayersActionDoneMessage : public ::google::protobuf::MessageLite {
 public:
  PlayersActionDoneMessage();
  virtual ~PlayersActionDoneMessage();
  
  PlayersActionDoneMessage(const PlayersActionDoneMessage& from);
  
  inline PlayersActionDoneMessage& operator=(const PlayersActionDoneMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PlayersActionDoneMessage& default_instance();
  
  void Swap(PlayersActionDoneMessage* other);
  
  // implements Message ----------------------------------------------
  
  PlayersActionDoneMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayersActionDoneMessage& from);
  void MergeFrom(const PlayersActionDoneMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);
  
  // required .NetGameState gameState = 3;
  inline bool has_gamestate() const;
  inline void clear_gamestate();
  static const int kGameStateFieldNumber = 3;
  inline NetGameState gamestate() const;
  inline void set_gamestate(NetGameState value);
  
  // required .NetPlayerAction playerAction = 4;
  inline bool has_playeraction() const;
  inline void clear_playeraction();
  static const int kPlayerActionFieldNumber = 4;
  inline NetPlayerAction playeraction() const;
  inline void set_playeraction(NetPlayerAction value);
  
  // required uint32 totalPlayerBet = 5;
  inline bool has_totalplayerbet() const;
  inline void clear_totalplayerbet();
  static const int kTotalPlayerBetFieldNumber = 5;
  inline ::google::protobuf::uint32 totalplayerbet() const;
  inline void set_totalplayerbet(::google::protobuf::uint32 value);
  
  // required uint32 playerMoney = 6;
  inline bool has_playermoney() const;
  inline void clear_playermoney();
  static const int kPlayerMoneyFieldNumber = 6;
  inline ::google::protobuf::uint32 playermoney() const;
  inline void set_playermoney(::google::protobuf::uint32 value);
  
  // required uint32 highestSet = 7;
  inline bool has_highestset() const;
  inline void clear_highestset();
  static const int kHighestSetFieldNumber = 7;
  inline ::google::protobuf::uint32 highestset() const;
  inline void set_highestset(::google::protobuf::uint32 value);
  
  // required uint32 minimumRaise = 8;
  inline bool has_minimumraise() const;
  inline void clear_minimumraise();
  static const int kMinimumRaiseFieldNumber = 8;
  inline ::google::protobuf::uint32 minimumraise() const;
  inline void set_minimumraise(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:PlayersActionDoneMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_gamestate();
  inline void clear_has_gamestate();
  inline void set_has_playeraction();
  inline void clear_has_playeraction();
  inline void set_has_totalplayerbet();
  inline void clear_has_totalplayerbet();
  inline void set_has_playermoney();
  inline void clear_has_playermoney();
  inline void set_has_highestset();
  inline void clear_has_highestset();
  inline void set_has_minimumraise();
  inline void clear_has_minimumraise();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  int gamestate_;
  int playeraction_;
  ::google::protobuf::uint32 totalplayerbet_;
  ::google::protobuf::uint32 playermoney_;
  ::google::protobuf::uint32 highestset_;
  ::google::protobuf::uint32 minimumraise_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static PlayersActionDoneMessage* default_instance_;
};
// -------------------------------------------------------------------

class DealFlopCardsMessage : public ::google::protobuf::MessageLite {
 public:
  DealFlopCardsMessage();
  virtual ~DealFlopCardsMessage();
  
  DealFlopCardsMessage(const DealFlopCardsMessage& from);
  
  inline DealFlopCardsMessage& operator=(const DealFlopCardsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const DealFlopCardsMessage& default_instance();
  
  void Swap(DealFlopCardsMessage* other);
  
  // implements Message ----------------------------------------------
  
  DealFlopCardsMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DealFlopCardsMessage& from);
  void MergeFrom(const DealFlopCardsMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 flopCard1 = 2;
  inline bool has_flopcard1() const;
  inline void clear_flopcard1();
  static const int kFlopCard1FieldNumber = 2;
  inline ::google::protobuf::uint32 flopcard1() const;
  inline void set_flopcard1(::google::protobuf::uint32 value);
  
  // required uint32 flopCard2 = 3;
  inline bool has_flopcard2() const;
  inline void clear_flopcard2();
  static const int kFlopCard2FieldNumber = 3;
  inline ::google::protobuf::uint32 flopcard2() const;
  inline void set_flopcard2(::google::protobuf::uint32 value);
  
  // required uint32 flopCard3 = 4;
  inline bool has_flopcard3() const;
  inline void clear_flopcard3();
  static const int kFlopCard3FieldNumber = 4;
  inline ::google::protobuf::uint32 flopcard3() const;
  inline void set_flopcard3(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:DealFlopCardsMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_flopcard1();
  inline void clear_has_flopcard1();
  inline void set_has_flopcard2();
  inline void clear_has_flopcard2();
  inline void set_has_flopcard3();
  inline void clear_has_flopcard3();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 flopcard1_;
  ::google::protobuf::uint32 flopcard2_;
  ::google::protobuf::uint32 flopcard3_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static DealFlopCardsMessage* default_instance_;
};
// -------------------------------------------------------------------

class DealTurnCardMessage : public ::google::protobuf::MessageLite {
 public:
  DealTurnCardMessage();
  virtual ~DealTurnCardMessage();
  
  DealTurnCardMessage(const DealTurnCardMessage& from);
  
  inline DealTurnCardMessage& operator=(const DealTurnCardMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const DealTurnCardMessage& default_instance();
  
  void Swap(DealTurnCardMessage* other);
  
  // implements Message ----------------------------------------------
  
  DealTurnCardMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DealTurnCardMessage& from);
  void MergeFrom(const DealTurnCardMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 turnCard = 2;
  inline bool has_turncard() const;
  inline void clear_turncard();
  static const int kTurnCardFieldNumber = 2;
  inline ::google::protobuf::uint32 turncard() const;
  inline void set_turncard(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:DealTurnCardMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_turncard();
  inline void clear_has_turncard();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 turncard_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static DealTurnCardMessage* default_instance_;
};
// -------------------------------------------------------------------

class DealRiverCardMessage : public ::google::protobuf::MessageLite {
 public:
  DealRiverCardMessage();
  virtual ~DealRiverCardMessage();
  
  DealRiverCardMessage(const DealRiverCardMessage& from);
  
  inline DealRiverCardMessage& operator=(const DealRiverCardMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const DealRiverCardMessage& default_instance();
  
  void Swap(DealRiverCardMessage* other);
  
  // implements Message ----------------------------------------------
  
  DealRiverCardMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DealRiverCardMessage& from);
  void MergeFrom(const DealRiverCardMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 riverCard = 2;
  inline bool has_rivercard() const;
  inline void clear_rivercard();
  static const int kRiverCardFieldNumber = 2;
  inline ::google::protobuf::uint32 rivercard() const;
  inline void set_rivercard(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:DealRiverCardMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_rivercard();
  inline void clear_has_rivercard();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 rivercard_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static DealRiverCardMessage* default_instance_;
};
// -------------------------------------------------------------------

class AllInShowCardsMessage_PlayerAllIn : public ::google::protobuf::MessageLite {
 public:
  AllInShowCardsMessage_PlayerAllIn();
  virtual ~AllInShowCardsMessage_PlayerAllIn();
  
  AllInShowCardsMessage_PlayerAllIn(const AllInShowCardsMessage_PlayerAllIn& from);
  
  inline AllInShowCardsMessage_PlayerAllIn& operator=(const AllInShowCardsMessage_PlayerAllIn& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const AllInShowCardsMessage_PlayerAllIn& default_instance();
  
  void Swap(AllInShowCardsMessage_PlayerAllIn* other);
  
  // implements Message ----------------------------------------------
  
  AllInShowCardsMessage_PlayerAllIn* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AllInShowCardsMessage_PlayerAllIn& from);
  void MergeFrom(const AllInShowCardsMessage_PlayerAllIn& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 playerId = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);
  
  // required uint32 allInCard1 = 2;
  inline bool has_allincard1() const;
  inline void clear_allincard1();
  static const int kAllInCard1FieldNumber = 2;
  inline ::google::protobuf::uint32 allincard1() const;
  inline void set_allincard1(::google::protobuf::uint32 value);
  
  // required uint32 allInCard2 = 3;
  inline bool has_allincard2() const;
  inline void clear_allincard2();
  static const int kAllInCard2FieldNumber = 3;
  inline ::google::protobuf::uint32 allincard2() const;
  inline void set_allincard2(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:AllInShowCardsMessage.PlayerAllIn)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_allincard1();
  inline void clear_has_allincard1();
  inline void set_has_allincard2();
  inline void clear_has_allincard2();
  
  ::google::protobuf::uint32 playerid_;
  ::google::protobuf::uint32 allincard1_;
  ::google::protobuf::uint32 allincard2_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static AllInShowCardsMessage_PlayerAllIn* default_instance_;
};
// -------------------------------------------------------------------

class AllInShowCardsMessage : public ::google::protobuf::MessageLite {
 public:
  AllInShowCardsMessage();
  virtual ~AllInShowCardsMessage();
  
  AllInShowCardsMessage(const AllInShowCardsMessage& from);
  
  inline AllInShowCardsMessage& operator=(const AllInShowCardsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const AllInShowCardsMessage& default_instance();
  
  void Swap(AllInShowCardsMessage* other);
  
  // implements Message ----------------------------------------------
  
  AllInShowCardsMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AllInShowCardsMessage& from);
  void MergeFrom(const AllInShowCardsMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef AllInShowCardsMessage_PlayerAllIn PlayerAllIn;
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // repeated .AllInShowCardsMessage.PlayerAllIn playersAllIn = 2;
  inline int playersallin_size() const;
  inline void clear_playersallin();
  static const int kPlayersAllInFieldNumber = 2;
  inline const ::AllInShowCardsMessage_PlayerAllIn& playersallin(int index) const;
  inline ::AllInShowCardsMessage_PlayerAllIn* mutable_playersallin(int index);
  inline ::AllInShowCardsMessage_PlayerAllIn* add_playersallin();
  inline const ::google::protobuf::RepeatedPtrField< ::AllInShowCardsMessage_PlayerAllIn >&
      playersallin() const;
  inline ::google::protobuf::RepeatedPtrField< ::AllInShowCardsMessage_PlayerAllIn >*
      mutable_playersallin();
  
  // @@protoc_insertion_point(class_scope:AllInShowCardsMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  
  ::google::protobuf::RepeatedPtrField< ::AllInShowCardsMessage_PlayerAllIn > playersallin_;
  ::google::protobuf::uint32 gameid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static AllInShowCardsMessage* default_instance_;
};
// -------------------------------------------------------------------

class EndOfHandShowCardsMessage : public ::google::protobuf::MessageLite {
 public:
  EndOfHandShowCardsMessage();
  virtual ~EndOfHandShowCardsMessage();
  
  EndOfHandShowCardsMessage(const EndOfHandShowCardsMessage& from);
  
  inline EndOfHandShowCardsMessage& operator=(const EndOfHandShowCardsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const EndOfHandShowCardsMessage& default_instance();
  
  void Swap(EndOfHandShowCardsMessage* other);
  
  // implements Message ----------------------------------------------
  
  EndOfHandShowCardsMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EndOfHandShowCardsMessage& from);
  void MergeFrom(const EndOfHandShowCardsMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // repeated .PlayerResult playerResults = 2;
  inline int playerresults_size() const;
  inline void clear_playerresults();
  static const int kPlayerResultsFieldNumber = 2;
  inline const ::PlayerResult& playerresults(int index) const;
  inline ::PlayerResult* mutable_playerresults(int index);
  inline ::PlayerResult* add_playerresults();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerResult >&
      playerresults() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerResult >*
      mutable_playerresults();
  
  // @@protoc_insertion_point(class_scope:EndOfHandShowCardsMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  
  ::google::protobuf::RepeatedPtrField< ::PlayerResult > playerresults_;
  ::google::protobuf::uint32 gameid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static EndOfHandShowCardsMessage* default_instance_;
};
// -------------------------------------------------------------------

class EndOfHandHideCardsMessage : public ::google::protobuf::MessageLite {
 public:
  EndOfHandHideCardsMessage();
  virtual ~EndOfHandHideCardsMessage();
  
  EndOfHandHideCardsMessage(const EndOfHandHideCardsMessage& from);
  
  inline EndOfHandHideCardsMessage& operator=(const EndOfHandHideCardsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const EndOfHandHideCardsMessage& default_instance();
  
  void Swap(EndOfHandHideCardsMessage* other);
  
  // implements Message ----------------------------------------------
  
  EndOfHandHideCardsMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EndOfHandHideCardsMessage& from);
  void MergeFrom(const EndOfHandHideCardsMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);
  
  // required uint32 moneyWon = 3;
  inline bool has_moneywon() const;
  inline void clear_moneywon();
  static const int kMoneyWonFieldNumber = 3;
  inline ::google::protobuf::uint32 moneywon() const;
  inline void set_moneywon(::google::protobuf::uint32 value);
  
  // required uint32 playerMoney = 4;
  inline bool has_playermoney() const;
  inline void clear_playermoney();
  static const int kPlayerMoneyFieldNumber = 4;
  inline ::google::protobuf::uint32 playermoney() const;
  inline void set_playermoney(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:EndOfHandHideCardsMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_moneywon();
  inline void clear_has_moneywon();
  inline void set_has_playermoney();
  inline void clear_has_playermoney();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  ::google::protobuf::uint32 moneywon_;
  ::google::protobuf::uint32 playermoney_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static EndOfHandHideCardsMessage* default_instance_;
};
// -------------------------------------------------------------------

class ShowMyCardsRequestMessage : public ::google::protobuf::MessageLite {
 public:
  ShowMyCardsRequestMessage();
  virtual ~ShowMyCardsRequestMessage();
  
  ShowMyCardsRequestMessage(const ShowMyCardsRequestMessage& from);
  
  inline ShowMyCardsRequestMessage& operator=(const ShowMyCardsRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ShowMyCardsRequestMessage& default_instance();
  
  void Swap(ShowMyCardsRequestMessage* other);
  
  // implements Message ----------------------------------------------
  
  ShowMyCardsRequestMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShowMyCardsRequestMessage& from);
  void MergeFrom(const ShowMyCardsRequestMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:ShowMyCardsRequestMessage)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static ShowMyCardsRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class AfterHandShowCardsMessage : public ::google::protobuf::MessageLite {
 public:
  AfterHandShowCardsMessage();
  virtual ~AfterHandShowCardsMessage();
  
  AfterHandShowCardsMessage(const AfterHandShowCardsMessage& from);
  
  inline AfterHandShowCardsMessage& operator=(const AfterHandShowCardsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const AfterHandShowCardsMessage& default_instance();
  
  void Swap(AfterHandShowCardsMessage* other);
  
  // implements Message ----------------------------------------------
  
  AfterHandShowCardsMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AfterHandShowCardsMessage& from);
  void MergeFrom(const AfterHandShowCardsMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .PlayerResult playerResult = 1;
  inline bool has_playerresult() const;
  inline void clear_playerresult();
  static const int kPlayerResultFieldNumber = 1;
  inline const ::PlayerResult& playerresult() const;
  inline ::PlayerResult* mutable_playerresult();
  inline ::PlayerResult* release_playerresult();
  
  // @@protoc_insertion_point(class_scope:AfterHandShowCardsMessage)
 private:
  inline void set_has_playerresult();
  inline void clear_has_playerresult();
  
  ::PlayerResult* playerresult_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static AfterHandShowCardsMessage* default_instance_;
};
// -------------------------------------------------------------------

class EndOfGameMessage : public ::google::protobuf::MessageLite {
 public:
  EndOfGameMessage();
  virtual ~EndOfGameMessage();
  
  EndOfGameMessage(const EndOfGameMessage& from);
  
  inline EndOfGameMessage& operator=(const EndOfGameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const EndOfGameMessage& default_instance();
  
  void Swap(EndOfGameMessage* other);
  
  // implements Message ----------------------------------------------
  
  EndOfGameMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EndOfGameMessage& from);
  void MergeFrom(const EndOfGameMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 winnerPlayerId = 2;
  inline bool has_winnerplayerid() const;
  inline void clear_winnerplayerid();
  static const int kWinnerPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 winnerplayerid() const;
  inline void set_winnerplayerid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:EndOfGameMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_winnerplayerid();
  inline void clear_has_winnerplayerid();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 winnerplayerid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static EndOfGameMessage* default_instance_;
};
// -------------------------------------------------------------------

class PlayerIdChangedMessage : public ::google::protobuf::MessageLite {
 public:
  PlayerIdChangedMessage();
  virtual ~PlayerIdChangedMessage();
  
  PlayerIdChangedMessage(const PlayerIdChangedMessage& from);
  
  inline PlayerIdChangedMessage& operator=(const PlayerIdChangedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PlayerIdChangedMessage& default_instance();
  
  void Swap(PlayerIdChangedMessage* other);
  
  // implements Message ----------------------------------------------
  
  PlayerIdChangedMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerIdChangedMessage& from);
  void MergeFrom(const PlayerIdChangedMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 oldPlayerId = 1;
  inline bool has_oldplayerid() const;
  inline void clear_oldplayerid();
  static const int kOldPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 oldplayerid() const;
  inline void set_oldplayerid(::google::protobuf::uint32 value);
  
  // required uint32 newPlayerId = 2;
  inline bool has_newplayerid() const;
  inline void clear_newplayerid();
  static const int kNewPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 newplayerid() const;
  inline void set_newplayerid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:PlayerIdChangedMessage)
 private:
  inline void set_has_oldplayerid();
  inline void clear_has_oldplayerid();
  inline void set_has_newplayerid();
  inline void clear_has_newplayerid();
  
  ::google::protobuf::uint32 oldplayerid_;
  ::google::protobuf::uint32 newplayerid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static PlayerIdChangedMessage* default_instance_;
};
// -------------------------------------------------------------------

class AskKickPlayerMessage : public ::google::protobuf::MessageLite {
 public:
  AskKickPlayerMessage();
  virtual ~AskKickPlayerMessage();
  
  AskKickPlayerMessage(const AskKickPlayerMessage& from);
  
  inline AskKickPlayerMessage& operator=(const AskKickPlayerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const AskKickPlayerMessage& default_instance();
  
  void Swap(AskKickPlayerMessage* other);
  
  // implements Message ----------------------------------------------
  
  AskKickPlayerMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AskKickPlayerMessage& from);
  void MergeFrom(const AskKickPlayerMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:AskKickPlayerMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static AskKickPlayerMessage* default_instance_;
};
// -------------------------------------------------------------------

class AskKickDeniedMessage : public ::google::protobuf::MessageLite {
 public:
  AskKickDeniedMessage();
  virtual ~AskKickDeniedMessage();
  
  AskKickDeniedMessage(const AskKickDeniedMessage& from);
  
  inline AskKickDeniedMessage& operator=(const AskKickDeniedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const AskKickDeniedMessage& default_instance();
  
  void Swap(AskKickDeniedMessage* other);
  
  // implements Message ----------------------------------------------
  
  AskKickDeniedMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AskKickDeniedMessage& from);
  void MergeFrom(const AskKickDeniedMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef AskKickDeniedMessage_KickDeniedReason KickDeniedReason;
  static const KickDeniedReason kickDeniedInvalidGameState = AskKickDeniedMessage_KickDeniedReason_kickDeniedInvalidGameState;
  static const KickDeniedReason kickDeniedNotPossible = AskKickDeniedMessage_KickDeniedReason_kickDeniedNotPossible;
  static const KickDeniedReason kickDeniedTryAgainLater = AskKickDeniedMessage_KickDeniedReason_kickDeniedTryAgainLater;
  static const KickDeniedReason kickDeniedAlreadyInProgress = AskKickDeniedMessage_KickDeniedReason_kickDeniedAlreadyInProgress;
  static const KickDeniedReason kickDeniedInvalidPlayerId = AskKickDeniedMessage_KickDeniedReason_kickDeniedInvalidPlayerId;
  static inline bool KickDeniedReason_IsValid(int value) {
    return AskKickDeniedMessage_KickDeniedReason_IsValid(value);
  }
  static const KickDeniedReason KickDeniedReason_MIN =
    AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_MIN;
  static const KickDeniedReason KickDeniedReason_MAX =
    AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_MAX;
  static const int KickDeniedReason_ARRAYSIZE =
    AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);
  
  // required .AskKickDeniedMessage.KickDeniedReason kickDeniedReason = 3;
  inline bool has_kickdeniedreason() const;
  inline void clear_kickdeniedreason();
  static const int kKickDeniedReasonFieldNumber = 3;
  inline ::AskKickDeniedMessage_KickDeniedReason kickdeniedreason() const;
  inline void set_kickdeniedreason(::AskKickDeniedMessage_KickDeniedReason value);
  
  // @@protoc_insertion_point(class_scope:AskKickDeniedMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_kickdeniedreason();
  inline void clear_has_kickdeniedreason();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  int kickdeniedreason_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static AskKickDeniedMessage* default_instance_;
};
// -------------------------------------------------------------------

class StartKickPetitionMessage : public ::google::protobuf::MessageLite {
 public:
  StartKickPetitionMessage();
  virtual ~StartKickPetitionMessage();
  
  StartKickPetitionMessage(const StartKickPetitionMessage& from);
  
  inline StartKickPetitionMessage& operator=(const StartKickPetitionMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const StartKickPetitionMessage& default_instance();
  
  void Swap(StartKickPetitionMessage* other);
  
  // implements Message ----------------------------------------------
  
  StartKickPetitionMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartKickPetitionMessage& from);
  void MergeFrom(const StartKickPetitionMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 petitionId = 2;
  inline bool has_petitionid() const;
  inline void clear_petitionid();
  static const int kPetitionIdFieldNumber = 2;
  inline ::google::protobuf::uint32 petitionid() const;
  inline void set_petitionid(::google::protobuf::uint32 value);
  
  // required uint32 proposingPlayerId = 3;
  inline bool has_proposingplayerid() const;
  inline void clear_proposingplayerid();
  static const int kProposingPlayerIdFieldNumber = 3;
  inline ::google::protobuf::uint32 proposingplayerid() const;
  inline void set_proposingplayerid(::google::protobuf::uint32 value);
  
  // required uint32 kickPlayerId = 4;
  inline bool has_kickplayerid() const;
  inline void clear_kickplayerid();
  static const int kKickPlayerIdFieldNumber = 4;
  inline ::google::protobuf::uint32 kickplayerid() const;
  inline void set_kickplayerid(::google::protobuf::uint32 value);
  
  // required uint32 kickTimeoutSec = 5;
  inline bool has_kicktimeoutsec() const;
  inline void clear_kicktimeoutsec();
  static const int kKickTimeoutSecFieldNumber = 5;
  inline ::google::protobuf::uint32 kicktimeoutsec() const;
  inline void set_kicktimeoutsec(::google::protobuf::uint32 value);
  
  // required uint32 numVotesNeededToKick = 6;
  inline bool has_numvotesneededtokick() const;
  inline void clear_numvotesneededtokick();
  static const int kNumVotesNeededToKickFieldNumber = 6;
  inline ::google::protobuf::uint32 numvotesneededtokick() const;
  inline void set_numvotesneededtokick(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:StartKickPetitionMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_petitionid();
  inline void clear_has_petitionid();
  inline void set_has_proposingplayerid();
  inline void clear_has_proposingplayerid();
  inline void set_has_kickplayerid();
  inline void clear_has_kickplayerid();
  inline void set_has_kicktimeoutsec();
  inline void clear_has_kicktimeoutsec();
  inline void set_has_numvotesneededtokick();
  inline void clear_has_numvotesneededtokick();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 petitionid_;
  ::google::protobuf::uint32 proposingplayerid_;
  ::google::protobuf::uint32 kickplayerid_;
  ::google::protobuf::uint32 kicktimeoutsec_;
  ::google::protobuf::uint32 numvotesneededtokick_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static StartKickPetitionMessage* default_instance_;
};
// -------------------------------------------------------------------

class VoteKickRequestMessage : public ::google::protobuf::MessageLite {
 public:
  VoteKickRequestMessage();
  virtual ~VoteKickRequestMessage();
  
  VoteKickRequestMessage(const VoteKickRequestMessage& from);
  
  inline VoteKickRequestMessage& operator=(const VoteKickRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const VoteKickRequestMessage& default_instance();
  
  void Swap(VoteKickRequestMessage* other);
  
  // implements Message ----------------------------------------------
  
  VoteKickRequestMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VoteKickRequestMessage& from);
  void MergeFrom(const VoteKickRequestMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 petitionId = 2;
  inline bool has_petitionid() const;
  inline void clear_petitionid();
  static const int kPetitionIdFieldNumber = 2;
  inline ::google::protobuf::uint32 petitionid() const;
  inline void set_petitionid(::google::protobuf::uint32 value);
  
  // required bool voteKick = 3;
  inline bool has_votekick() const;
  inline void clear_votekick();
  static const int kVoteKickFieldNumber = 3;
  inline bool votekick() const;
  inline void set_votekick(bool value);
  
  // @@protoc_insertion_point(class_scope:VoteKickRequestMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_petitionid();
  inline void clear_has_petitionid();
  inline void set_has_votekick();
  inline void clear_has_votekick();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 petitionid_;
  bool votekick_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static VoteKickRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class VoteKickReplyMessage : public ::google::protobuf::MessageLite {
 public:
  VoteKickReplyMessage();
  virtual ~VoteKickReplyMessage();
  
  VoteKickReplyMessage(const VoteKickReplyMessage& from);
  
  inline VoteKickReplyMessage& operator=(const VoteKickReplyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const VoteKickReplyMessage& default_instance();
  
  void Swap(VoteKickReplyMessage* other);
  
  // implements Message ----------------------------------------------
  
  VoteKickReplyMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VoteKickReplyMessage& from);
  void MergeFrom(const VoteKickReplyMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef VoteKickReplyMessage_VoteKickReplyType VoteKickReplyType;
  static const VoteKickReplyType voteKickAck = VoteKickReplyMessage_VoteKickReplyType_voteKickAck;
  static const VoteKickReplyType voteKickDeniedInvalid = VoteKickReplyMessage_VoteKickReplyType_voteKickDeniedInvalid;
  static const VoteKickReplyType voteKickDeniedAlreadyVoted = VoteKickReplyMessage_VoteKickReplyType_voteKickDeniedAlreadyVoted;
  static inline bool VoteKickReplyType_IsValid(int value) {
    return VoteKickReplyMessage_VoteKickReplyType_IsValid(value);
  }
  static const VoteKickReplyType VoteKickReplyType_MIN =
    VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_MIN;
  static const VoteKickReplyType VoteKickReplyType_MAX =
    VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_MAX;
  static const int VoteKickReplyType_ARRAYSIZE =
    VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 petitionId = 2;
  inline bool has_petitionid() const;
  inline void clear_petitionid();
  static const int kPetitionIdFieldNumber = 2;
  inline ::google::protobuf::uint32 petitionid() const;
  inline void set_petitionid(::google::protobuf::uint32 value);
  
  // required .VoteKickReplyMessage.VoteKickReplyType voteKickReplyType = 3;
  inline bool has_votekickreplytype() const;
  inline void clear_votekickreplytype();
  static const int kVoteKickReplyTypeFieldNumber = 3;
  inline ::VoteKickReplyMessage_VoteKickReplyType votekickreplytype() const;
  inline void set_votekickreplytype(::VoteKickReplyMessage_VoteKickReplyType value);
  
  // @@protoc_insertion_point(class_scope:VoteKickReplyMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_petitionid();
  inline void clear_has_petitionid();
  inline void set_has_votekickreplytype();
  inline void clear_has_votekickreplytype();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 petitionid_;
  int votekickreplytype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static VoteKickReplyMessage* default_instance_;
};
// -------------------------------------------------------------------

class KickPetitionUpdateMessage : public ::google::protobuf::MessageLite {
 public:
  KickPetitionUpdateMessage();
  virtual ~KickPetitionUpdateMessage();
  
  KickPetitionUpdateMessage(const KickPetitionUpdateMessage& from);
  
  inline KickPetitionUpdateMessage& operator=(const KickPetitionUpdateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const KickPetitionUpdateMessage& default_instance();
  
  void Swap(KickPetitionUpdateMessage* other);
  
  // implements Message ----------------------------------------------
  
  KickPetitionUpdateMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const KickPetitionUpdateMessage& from);
  void MergeFrom(const KickPetitionUpdateMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 petitionId = 2;
  inline bool has_petitionid() const;
  inline void clear_petitionid();
  static const int kPetitionIdFieldNumber = 2;
  inline ::google::protobuf::uint32 petitionid() const;
  inline void set_petitionid(::google::protobuf::uint32 value);
  
  // required uint32 numVotesAgainstKicking = 3;
  inline bool has_numvotesagainstkicking() const;
  inline void clear_numvotesagainstkicking();
  static const int kNumVotesAgainstKickingFieldNumber = 3;
  inline ::google::protobuf::uint32 numvotesagainstkicking() const;
  inline void set_numvotesagainstkicking(::google::protobuf::uint32 value);
  
  // required uint32 numVotesInFavourOfKicking = 4;
  inline bool has_numvotesinfavourofkicking() const;
  inline void clear_numvotesinfavourofkicking();
  static const int kNumVotesInFavourOfKickingFieldNumber = 4;
  inline ::google::protobuf::uint32 numvotesinfavourofkicking() const;
  inline void set_numvotesinfavourofkicking(::google::protobuf::uint32 value);
  
  // required uint32 numVotesNeededToKick = 5;
  inline bool has_numvotesneededtokick() const;
  inline void clear_numvotesneededtokick();
  static const int kNumVotesNeededToKickFieldNumber = 5;
  inline ::google::protobuf::uint32 numvotesneededtokick() const;
  inline void set_numvotesneededtokick(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:KickPetitionUpdateMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_petitionid();
  inline void clear_has_petitionid();
  inline void set_has_numvotesagainstkicking();
  inline void clear_has_numvotesagainstkicking();
  inline void set_has_numvotesinfavourofkicking();
  inline void clear_has_numvotesinfavourofkicking();
  inline void set_has_numvotesneededtokick();
  inline void clear_has_numvotesneededtokick();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 petitionid_;
  ::google::protobuf::uint32 numvotesagainstkicking_;
  ::google::protobuf::uint32 numvotesinfavourofkicking_;
  ::google::protobuf::uint32 numvotesneededtokick_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static KickPetitionUpdateMessage* default_instance_;
};
// -------------------------------------------------------------------

class EndKickPetitionMessage : public ::google::protobuf::MessageLite {
 public:
  EndKickPetitionMessage();
  virtual ~EndKickPetitionMessage();
  
  EndKickPetitionMessage(const EndKickPetitionMessage& from);
  
  inline EndKickPetitionMessage& operator=(const EndKickPetitionMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const EndKickPetitionMessage& default_instance();
  
  void Swap(EndKickPetitionMessage* other);
  
  // implements Message ----------------------------------------------
  
  EndKickPetitionMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EndKickPetitionMessage& from);
  void MergeFrom(const EndKickPetitionMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef EndKickPetitionMessage_PetitionEndReason PetitionEndReason;
  static const PetitionEndReason petitionEndEnoughVotes = EndKickPetitionMessage_PetitionEndReason_petitionEndEnoughVotes;
  static const PetitionEndReason petitionEndTooFewPlayers = EndKickPetitionMessage_PetitionEndReason_petitionEndTooFewPlayers;
  static const PetitionEndReason petitionEndPlayerLeft = EndKickPetitionMessage_PetitionEndReason_petitionEndPlayerLeft;
  static const PetitionEndReason petitionEndTimeout = EndKickPetitionMessage_PetitionEndReason_petitionEndTimeout;
  static inline bool PetitionEndReason_IsValid(int value) {
    return EndKickPetitionMessage_PetitionEndReason_IsValid(value);
  }
  static const PetitionEndReason PetitionEndReason_MIN =
    EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_MIN;
  static const PetitionEndReason PetitionEndReason_MAX =
    EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_MAX;
  static const int PetitionEndReason_ARRAYSIZE =
    EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // required uint32 petitionId = 2;
  inline bool has_petitionid() const;
  inline void clear_petitionid();
  static const int kPetitionIdFieldNumber = 2;
  inline ::google::protobuf::uint32 petitionid() const;
  inline void set_petitionid(::google::protobuf::uint32 value);
  
  // required uint32 numVotesAgainstKicking = 3;
  inline bool has_numvotesagainstkicking() const;
  inline void clear_numvotesagainstkicking();
  static const int kNumVotesAgainstKickingFieldNumber = 3;
  inline ::google::protobuf::uint32 numvotesagainstkicking() const;
  inline void set_numvotesagainstkicking(::google::protobuf::uint32 value);
  
  // required uint32 numVotesInFavourOfKicking = 4;
  inline bool has_numvotesinfavourofkicking() const;
  inline void clear_numvotesinfavourofkicking();
  static const int kNumVotesInFavourOfKickingFieldNumber = 4;
  inline ::google::protobuf::uint32 numvotesinfavourofkicking() const;
  inline void set_numvotesinfavourofkicking(::google::protobuf::uint32 value);
  
  // required uint32 resultPlayerKicked = 5;
  inline bool has_resultplayerkicked() const;
  inline void clear_resultplayerkicked();
  static const int kResultPlayerKickedFieldNumber = 5;
  inline ::google::protobuf::uint32 resultplayerkicked() const;
  inline void set_resultplayerkicked(::google::protobuf::uint32 value);
  
  // required .EndKickPetitionMessage.PetitionEndReason petitionEndReason = 6;
  inline bool has_petitionendreason() const;
  inline void clear_petitionendreason();
  static const int kPetitionEndReasonFieldNumber = 6;
  inline ::EndKickPetitionMessage_PetitionEndReason petitionendreason() const;
  inline void set_petitionendreason(::EndKickPetitionMessage_PetitionEndReason value);
  
  // @@protoc_insertion_point(class_scope:EndKickPetitionMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_petitionid();
  inline void clear_has_petitionid();
  inline void set_has_numvotesagainstkicking();
  inline void clear_has_numvotesagainstkicking();
  inline void set_has_numvotesinfavourofkicking();
  inline void clear_has_numvotesinfavourofkicking();
  inline void set_has_resultplayerkicked();
  inline void clear_has_resultplayerkicked();
  inline void set_has_petitionendreason();
  inline void clear_has_petitionendreason();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 petitionid_;
  ::google::protobuf::uint32 numvotesagainstkicking_;
  ::google::protobuf::uint32 numvotesinfavourofkicking_;
  ::google::protobuf::uint32 resultplayerkicked_;
  int petitionendreason_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static EndKickPetitionMessage* default_instance_;
};
// -------------------------------------------------------------------

class StatisticsMessage_StatisticsData : public ::google::protobuf::MessageLite {
 public:
  StatisticsMessage_StatisticsData();
  virtual ~StatisticsMessage_StatisticsData();
  
  StatisticsMessage_StatisticsData(const StatisticsMessage_StatisticsData& from);
  
  inline StatisticsMessage_StatisticsData& operator=(const StatisticsMessage_StatisticsData& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const StatisticsMessage_StatisticsData& default_instance();
  
  void Swap(StatisticsMessage_StatisticsData* other);
  
  // implements Message ----------------------------------------------
  
  StatisticsMessage_StatisticsData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StatisticsMessage_StatisticsData& from);
  void MergeFrom(const StatisticsMessage_StatisticsData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef StatisticsMessage_StatisticsData_StatisticsType StatisticsType;
  static const StatisticsType statNumberOfPlayers = StatisticsMessage_StatisticsData_StatisticsType_statNumberOfPlayers;
  static inline bool StatisticsType_IsValid(int value) {
    return StatisticsMessage_StatisticsData_StatisticsType_IsValid(value);
  }
  static const StatisticsType StatisticsType_MIN =
    StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_MIN;
  static const StatisticsType StatisticsType_MAX =
    StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_MAX;
  static const int StatisticsType_ARRAYSIZE =
    StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .StatisticsMessage.StatisticsData.StatisticsType statisticsType = 1;
  inline bool has_statisticstype() const;
  inline void clear_statisticstype();
  static const int kStatisticsTypeFieldNumber = 1;
  inline ::StatisticsMessage_StatisticsData_StatisticsType statisticstype() const;
  inline void set_statisticstype(::StatisticsMessage_StatisticsData_StatisticsType value);
  
  // required uint32 statisticsValue = 2;
  inline bool has_statisticsvalue() const;
  inline void clear_statisticsvalue();
  static const int kStatisticsValueFieldNumber = 2;
  inline ::google::protobuf::uint32 statisticsvalue() const;
  inline void set_statisticsvalue(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:StatisticsMessage.StatisticsData)
 private:
  inline void set_has_statisticstype();
  inline void clear_has_statisticstype();
  inline void set_has_statisticsvalue();
  inline void clear_has_statisticsvalue();
  
  int statisticstype_;
  ::google::protobuf::uint32 statisticsvalue_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static StatisticsMessage_StatisticsData* default_instance_;
};
// -------------------------------------------------------------------

class StatisticsMessage : public ::google::protobuf::MessageLite {
 public:
  StatisticsMessage();
  virtual ~StatisticsMessage();
  
  StatisticsMessage(const StatisticsMessage& from);
  
  inline StatisticsMessage& operator=(const StatisticsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const StatisticsMessage& default_instance();
  
  void Swap(StatisticsMessage* other);
  
  // implements Message ----------------------------------------------
  
  StatisticsMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StatisticsMessage& from);
  void MergeFrom(const StatisticsMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef StatisticsMessage_StatisticsData StatisticsData;
  
  // accessors -------------------------------------------------------
  
  // repeated .StatisticsMessage.StatisticsData statisticsData = 1;
  inline int statisticsdata_size() const;
  inline void clear_statisticsdata();
  static const int kStatisticsDataFieldNumber = 1;
  inline const ::StatisticsMessage_StatisticsData& statisticsdata(int index) const;
  inline ::StatisticsMessage_StatisticsData* mutable_statisticsdata(int index);
  inline ::StatisticsMessage_StatisticsData* add_statisticsdata();
  inline const ::google::protobuf::RepeatedPtrField< ::StatisticsMessage_StatisticsData >&
      statisticsdata() const;
  inline ::google::protobuf::RepeatedPtrField< ::StatisticsMessage_StatisticsData >*
      mutable_statisticsdata();
  
  // @@protoc_insertion_point(class_scope:StatisticsMessage)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::StatisticsMessage_StatisticsData > statisticsdata_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static StatisticsMessage* default_instance_;
};
// -------------------------------------------------------------------

class ChatRequestMessage : public ::google::protobuf::MessageLite {
 public:
  ChatRequestMessage();
  virtual ~ChatRequestMessage();
  
  ChatRequestMessage(const ChatRequestMessage& from);
  
  inline ChatRequestMessage& operator=(const ChatRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ChatRequestMessage& default_instance();
  
  void Swap(ChatRequestMessage* other);
  
  // implements Message ----------------------------------------------
  
  ChatRequestMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChatRequestMessage& from);
  void MergeFrom(const ChatRequestMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 targetGameId = 1;
  inline bool has_targetgameid() const;
  inline void clear_targetgameid();
  static const int kTargetGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 targetgameid() const;
  inline void set_targetgameid(::google::protobuf::uint32 value);
  
  // optional uint32 targetPlayerId = 2;
  inline bool has_targetplayerid() const;
  inline void clear_targetplayerid();
  static const int kTargetPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 targetplayerid() const;
  inline void set_targetplayerid(::google::protobuf::uint32 value);
  
  // required string chatText = 3;
  inline bool has_chattext() const;
  inline void clear_chattext();
  static const int kChatTextFieldNumber = 3;
  inline const ::std::string& chattext() const;
  inline void set_chattext(const ::std::string& value);
  inline void set_chattext(const char* value);
  inline void set_chattext(const char* value, size_t size);
  inline ::std::string* mutable_chattext();
  inline ::std::string* release_chattext();
  
  // @@protoc_insertion_point(class_scope:ChatRequestMessage)
 private:
  inline void set_has_targetgameid();
  inline void clear_has_targetgameid();
  inline void set_has_targetplayerid();
  inline void clear_has_targetplayerid();
  inline void set_has_chattext();
  inline void clear_has_chattext();
  
  ::google::protobuf::uint32 targetgameid_;
  ::google::protobuf::uint32 targetplayerid_;
  ::std::string* chattext_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static ChatRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class ChatMessage : public ::google::protobuf::MessageLite {
 public:
  ChatMessage();
  virtual ~ChatMessage();
  
  ChatMessage(const ChatMessage& from);
  
  inline ChatMessage& operator=(const ChatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ChatMessage& default_instance();
  
  void Swap(ChatMessage* other);
  
  // implements Message ----------------------------------------------
  
  ChatMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChatMessage& from);
  void MergeFrom(const ChatMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef ChatMessage_ChatType ChatType;
  static const ChatType chatTypeLobby = ChatMessage_ChatType_chatTypeLobby;
  static const ChatType chatTypeGame = ChatMessage_ChatType_chatTypeGame;
  static const ChatType chatTypeBot = ChatMessage_ChatType_chatTypeBot;
  static const ChatType chatTypeBroadcast = ChatMessage_ChatType_chatTypeBroadcast;
  static const ChatType chatTypePrivate = ChatMessage_ChatType_chatTypePrivate;
  static inline bool ChatType_IsValid(int value) {
    return ChatMessage_ChatType_IsValid(value);
  }
  static const ChatType ChatType_MIN =
    ChatMessage_ChatType_ChatType_MIN;
  static const ChatType ChatType_MAX =
    ChatMessage_ChatType_ChatType_MAX;
  static const int ChatType_ARRAYSIZE =
    ChatMessage_ChatType_ChatType_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // optional uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);
  
  // required .ChatMessage.ChatType chatType = 3;
  inline bool has_chattype() const;
  inline void clear_chattype();
  static const int kChatTypeFieldNumber = 3;
  inline ::ChatMessage_ChatType chattype() const;
  inline void set_chattype(::ChatMessage_ChatType value);
  
  // required string chatText = 4;
  inline bool has_chattext() const;
  inline void clear_chattext();
  static const int kChatTextFieldNumber = 4;
  inline const ::std::string& chattext() const;
  inline void set_chattext(const ::std::string& value);
  inline void set_chattext(const char* value);
  inline void set_chattext(const char* value, size_t size);
  inline ::std::string* mutable_chattext();
  inline ::std::string* release_chattext();
  
  // @@protoc_insertion_point(class_scope:ChatMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_chattype();
  inline void clear_has_chattype();
  inline void set_has_chattext();
  inline void clear_has_chattext();
  
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  ::std::string* chattext_;
  int chattype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static ChatMessage* default_instance_;
};
// -------------------------------------------------------------------

class ChatRejectMessage : public ::google::protobuf::MessageLite {
 public:
  ChatRejectMessage();
  virtual ~ChatRejectMessage();
  
  ChatRejectMessage(const ChatRejectMessage& from);
  
  inline ChatRejectMessage& operator=(const ChatRejectMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ChatRejectMessage& default_instance();
  
  void Swap(ChatRejectMessage* other);
  
  // implements Message ----------------------------------------------
  
  ChatRejectMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChatRejectMessage& from);
  void MergeFrom(const ChatRejectMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string chatText = 1;
  inline bool has_chattext() const;
  inline void clear_chattext();
  static const int kChatTextFieldNumber = 1;
  inline const ::std::string& chattext() const;
  inline void set_chattext(const ::std::string& value);
  inline void set_chattext(const char* value);
  inline void set_chattext(const char* value, size_t size);
  inline ::std::string* mutable_chattext();
  inline ::std::string* release_chattext();
  
  // @@protoc_insertion_point(class_scope:ChatRejectMessage)
 private:
  inline void set_has_chattext();
  inline void clear_has_chattext();
  
  ::std::string* chattext_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static ChatRejectMessage* default_instance_;
};
// -------------------------------------------------------------------

class DialogMessage : public ::google::protobuf::MessageLite {
 public:
  DialogMessage();
  virtual ~DialogMessage();
  
  DialogMessage(const DialogMessage& from);
  
  inline DialogMessage& operator=(const DialogMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const DialogMessage& default_instance();
  
  void Swap(DialogMessage* other);
  
  // implements Message ----------------------------------------------
  
  DialogMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DialogMessage& from);
  void MergeFrom(const DialogMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string notificationText = 1;
  inline bool has_notificationtext() const;
  inline void clear_notificationtext();
  static const int kNotificationTextFieldNumber = 1;
  inline const ::std::string& notificationtext() const;
  inline void set_notificationtext(const ::std::string& value);
  inline void set_notificationtext(const char* value);
  inline void set_notificationtext(const char* value, size_t size);
  inline ::std::string* mutable_notificationtext();
  inline ::std::string* release_notificationtext();
  
  // @@protoc_insertion_point(class_scope:DialogMessage)
 private:
  inline void set_has_notificationtext();
  inline void clear_has_notificationtext();
  
  ::std::string* notificationtext_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static DialogMessage* default_instance_;
};
// -------------------------------------------------------------------

class TimeoutWarningMessage : public ::google::protobuf::MessageLite {
 public:
  TimeoutWarningMessage();
  virtual ~TimeoutWarningMessage();
  
  TimeoutWarningMessage(const TimeoutWarningMessage& from);
  
  inline TimeoutWarningMessage& operator=(const TimeoutWarningMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const TimeoutWarningMessage& default_instance();
  
  void Swap(TimeoutWarningMessage* other);
  
  // implements Message ----------------------------------------------
  
  TimeoutWarningMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TimeoutWarningMessage& from);
  void MergeFrom(const TimeoutWarningMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef TimeoutWarningMessage_TimeoutReason TimeoutReason;
  static const TimeoutReason timeoutNoDataReceived = TimeoutWarningMessage_TimeoutReason_timeoutNoDataReceived;
  static const TimeoutReason timeoutInactiveGame = TimeoutWarningMessage_TimeoutReason_timeoutInactiveGame;
  static const TimeoutReason timeoutKickAfterAutofold = TimeoutWarningMessage_TimeoutReason_timeoutKickAfterAutofold;
  static inline bool TimeoutReason_IsValid(int value) {
    return TimeoutWarningMessage_TimeoutReason_IsValid(value);
  }
  static const TimeoutReason TimeoutReason_MIN =
    TimeoutWarningMessage_TimeoutReason_TimeoutReason_MIN;
  static const TimeoutReason TimeoutReason_MAX =
    TimeoutWarningMessage_TimeoutReason_TimeoutReason_MAX;
  static const int TimeoutReason_ARRAYSIZE =
    TimeoutWarningMessage_TimeoutReason_TimeoutReason_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .TimeoutWarningMessage.TimeoutReason timeoutReason = 1;
  inline bool has_timeoutreason() const;
  inline void clear_timeoutreason();
  static const int kTimeoutReasonFieldNumber = 1;
  inline ::TimeoutWarningMessage_TimeoutReason timeoutreason() const;
  inline void set_timeoutreason(::TimeoutWarningMessage_TimeoutReason value);
  
  // required uint32 remainingSeconds = 2;
  inline bool has_remainingseconds() const;
  inline void clear_remainingseconds();
  static const int kRemainingSecondsFieldNumber = 2;
  inline ::google::protobuf::uint32 remainingseconds() const;
  inline void set_remainingseconds(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:TimeoutWarningMessage)
 private:
  inline void set_has_timeoutreason();
  inline void clear_has_timeoutreason();
  inline void set_has_remainingseconds();
  inline void clear_has_remainingseconds();
  
  int timeoutreason_;
  ::google::protobuf::uint32 remainingseconds_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static TimeoutWarningMessage* default_instance_;
};
// -------------------------------------------------------------------

class ResetTimeoutMessage : public ::google::protobuf::MessageLite {
 public:
  ResetTimeoutMessage();
  virtual ~ResetTimeoutMessage();
  
  ResetTimeoutMessage(const ResetTimeoutMessage& from);
  
  inline ResetTimeoutMessage& operator=(const ResetTimeoutMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ResetTimeoutMessage& default_instance();
  
  void Swap(ResetTimeoutMessage* other);
  
  // implements Message ----------------------------------------------
  
  ResetTimeoutMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResetTimeoutMessage& from);
  void MergeFrom(const ResetTimeoutMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:ResetTimeoutMessage)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static ResetTimeoutMessage* default_instance_;
};
// -------------------------------------------------------------------

class ReportAvatarMessage : public ::google::protobuf::MessageLite {
 public:
  ReportAvatarMessage();
  virtual ~ReportAvatarMessage();
  
  ReportAvatarMessage(const ReportAvatarMessage& from);
  
  inline ReportAvatarMessage& operator=(const ReportAvatarMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ReportAvatarMessage& default_instance();
  
  void Swap(ReportAvatarMessage* other);
  
  // implements Message ----------------------------------------------
  
  ReportAvatarMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReportAvatarMessage& from);
  void MergeFrom(const ReportAvatarMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 reportedPlayerId = 1;
  inline bool has_reportedplayerid() const;
  inline void clear_reportedplayerid();
  static const int kReportedPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 reportedplayerid() const;
  inline void set_reportedplayerid(::google::protobuf::uint32 value);
  
  // required bytes reportedAvatarHash = 2;
  inline bool has_reportedavatarhash() const;
  inline void clear_reportedavatarhash();
  static const int kReportedAvatarHashFieldNumber = 2;
  inline const ::std::string& reportedavatarhash() const;
  inline void set_reportedavatarhash(const ::std::string& value);
  inline void set_reportedavatarhash(const char* value);
  inline void set_reportedavatarhash(const void* value, size_t size);
  inline ::std::string* mutable_reportedavatarhash();
  inline ::std::string* release_reportedavatarhash();
  
  // @@protoc_insertion_point(class_scope:ReportAvatarMessage)
 private:
  inline void set_has_reportedplayerid();
  inline void clear_has_reportedplayerid();
  inline void set_has_reportedavatarhash();
  inline void clear_has_reportedavatarhash();
  
  ::std::string* reportedavatarhash_;
  ::google::protobuf::uint32 reportedplayerid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static ReportAvatarMessage* default_instance_;
};
// -------------------------------------------------------------------

class ReportAvatarAckMessage : public ::google::protobuf::MessageLite {
 public:
  ReportAvatarAckMessage();
  virtual ~ReportAvatarAckMessage();
  
  ReportAvatarAckMessage(const ReportAvatarAckMessage& from);
  
  inline ReportAvatarAckMessage& operator=(const ReportAvatarAckMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ReportAvatarAckMessage& default_instance();
  
  void Swap(ReportAvatarAckMessage* other);
  
  // implements Message ----------------------------------------------
  
  ReportAvatarAckMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReportAvatarAckMessage& from);
  void MergeFrom(const ReportAvatarAckMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef ReportAvatarAckMessage_ReportAvatarResult ReportAvatarResult;
  static const ReportAvatarResult avatarReportAccepted = ReportAvatarAckMessage_ReportAvatarResult_avatarReportAccepted;
  static const ReportAvatarResult avatarReportDuplicate = ReportAvatarAckMessage_ReportAvatarResult_avatarReportDuplicate;
  static const ReportAvatarResult avatarReportInvalid = ReportAvatarAckMessage_ReportAvatarResult_avatarReportInvalid;
  static inline bool ReportAvatarResult_IsValid(int value) {
    return ReportAvatarAckMessage_ReportAvatarResult_IsValid(value);
  }
  static const ReportAvatarResult ReportAvatarResult_MIN =
    ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_MIN;
  static const ReportAvatarResult ReportAvatarResult_MAX =
    ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_MAX;
  static const int ReportAvatarResult_ARRAYSIZE =
    ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required uint32 reportedPlayerId = 1;
  inline bool has_reportedplayerid() const;
  inline void clear_reportedplayerid();
  static const int kReportedPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 reportedplayerid() const;
  inline void set_reportedplayerid(::google::protobuf::uint32 value);
  
  // required .ReportAvatarAckMessage.ReportAvatarResult reportAvatarResult = 2;
  inline bool has_reportavatarresult() const;
  inline void clear_reportavatarresult();
  static const int kReportAvatarResultFieldNumber = 2;
  inline ::ReportAvatarAckMessage_ReportAvatarResult reportavatarresult() const;
  inline void set_reportavatarresult(::ReportAvatarAckMessage_ReportAvatarResult value);
  
  // @@protoc_insertion_point(class_scope:ReportAvatarAckMessage)
 private:
  inline void set_has_reportedplayerid();
  inline void clear_has_reportedplayerid();
  inline void set_has_reportavatarresult();
  inline void clear_has_reportavatarresult();
  
  ::google::protobuf::uint32 reportedplayerid_;
  int reportavatarresult_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static ReportAvatarAckMessage* default_instance_;
};
// -------------------------------------------------------------------

class ReportGameMessage : public ::google::protobuf::MessageLite {
 public:
  ReportGameMessage();
  virtual ~ReportGameMessage();
  
  ReportGameMessage(const ReportGameMessage& from);
  
  inline ReportGameMessage& operator=(const ReportGameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ReportGameMessage& default_instance();
  
  void Swap(ReportGameMessage* other);
  
  // implements Message ----------------------------------------------
  
  ReportGameMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReportGameMessage& from);
  void MergeFrom(const ReportGameMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 reportedGameId = 1;
  inline bool has_reportedgameid() const;
  inline void clear_reportedgameid();
  static const int kReportedGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 reportedgameid() const;
  inline void set_reportedgameid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:ReportGameMessage)
 private:
  inline void set_has_reportedgameid();
  inline void clear_has_reportedgameid();
  
  ::google::protobuf::uint32 reportedgameid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static ReportGameMessage* default_instance_;
};
// -------------------------------------------------------------------

class ReportGameAckMessage : public ::google::protobuf::MessageLite {
 public:
  ReportGameAckMessage();
  virtual ~ReportGameAckMessage();
  
  ReportGameAckMessage(const ReportGameAckMessage& from);
  
  inline ReportGameAckMessage& operator=(const ReportGameAckMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ReportGameAckMessage& default_instance();
  
  void Swap(ReportGameAckMessage* other);
  
  // implements Message ----------------------------------------------
  
  ReportGameAckMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReportGameAckMessage& from);
  void MergeFrom(const ReportGameAckMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef ReportGameAckMessage_ReportGameResult ReportGameResult;
  static const ReportGameResult gameReportAccepted = ReportGameAckMessage_ReportGameResult_gameReportAccepted;
  static const ReportGameResult gameReportDuplicate = ReportGameAckMessage_ReportGameResult_gameReportDuplicate;
  static const ReportGameResult gameReportInvalid = ReportGameAckMessage_ReportGameResult_gameReportInvalid;
  static inline bool ReportGameResult_IsValid(int value) {
    return ReportGameAckMessage_ReportGameResult_IsValid(value);
  }
  static const ReportGameResult ReportGameResult_MIN =
    ReportGameAckMessage_ReportGameResult_ReportGameResult_MIN;
  static const ReportGameResult ReportGameResult_MAX =
    ReportGameAckMessage_ReportGameResult_ReportGameResult_MAX;
  static const int ReportGameResult_ARRAYSIZE =
    ReportGameAckMessage_ReportGameResult_ReportGameResult_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required uint32 reportedGameId = 1;
  inline bool has_reportedgameid() const;
  inline void clear_reportedgameid();
  static const int kReportedGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 reportedgameid() const;
  inline void set_reportedgameid(::google::protobuf::uint32 value);
  
  // required .ReportGameAckMessage.ReportGameResult reportGameResult = 2;
  inline bool has_reportgameresult() const;
  inline void clear_reportgameresult();
  static const int kReportGameResultFieldNumber = 2;
  inline ::ReportGameAckMessage_ReportGameResult reportgameresult() const;
  inline void set_reportgameresult(::ReportGameAckMessage_ReportGameResult value);
  
  // @@protoc_insertion_point(class_scope:ReportGameAckMessage)
 private:
  inline void set_has_reportedgameid();
  inline void clear_has_reportedgameid();
  inline void set_has_reportgameresult();
  inline void clear_has_reportgameresult();
  
  ::google::protobuf::uint32 reportedgameid_;
  int reportgameresult_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static ReportGameAckMessage* default_instance_;
};
// -------------------------------------------------------------------

class ErrorMessage : public ::google::protobuf::MessageLite {
 public:
  ErrorMessage();
  virtual ~ErrorMessage();
  
  ErrorMessage(const ErrorMessage& from);
  
  inline ErrorMessage& operator=(const ErrorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ErrorMessage& default_instance();
  
  void Swap(ErrorMessage* other);
  
  // implements Message ----------------------------------------------
  
  ErrorMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ErrorMessage& from);
  void MergeFrom(const ErrorMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef ErrorMessage_ErrorReason ErrorReason;
  static const ErrorReason reserved = ErrorMessage_ErrorReason_reserved;
  static const ErrorReason initVersionNotSupported = ErrorMessage_ErrorReason_initVersionNotSupported;
  static const ErrorReason initServerFull = ErrorMessage_ErrorReason_initServerFull;
  static const ErrorReason initAuthFailure = ErrorMessage_ErrorReason_initAuthFailure;
  static const ErrorReason initPlayerNameInUse = ErrorMessage_ErrorReason_initPlayerNameInUse;
  static const ErrorReason initInvalidPlayerName = ErrorMessage_ErrorReason_initInvalidPlayerName;
  static const ErrorReason initServerMaintenance = ErrorMessage_ErrorReason_initServerMaintenance;
  static const ErrorReason initBlocked = ErrorMessage_ErrorReason_initBlocked;
  static const ErrorReason avatarTooLarge = ErrorMessage_ErrorReason_avatarTooLarge;
  static const ErrorReason invalidPacket = ErrorMessage_ErrorReason_invalidPacket;
  static const ErrorReason invalidState = ErrorMessage_ErrorReason_invalidState;
  static const ErrorReason kickedFromServer = ErrorMessage_ErrorReason_kickedFromServer;
  static const ErrorReason bannedFromServer = ErrorMessage_ErrorReason_bannedFromServer;
  static const ErrorReason blockedByServer = ErrorMessage_ErrorReason_blockedByServer;
  static const ErrorReason sessionTimeout = ErrorMessage_ErrorReason_sessionTimeout;
  static inline bool ErrorReason_IsValid(int value) {
    return ErrorMessage_ErrorReason_IsValid(value);
  }
  static const ErrorReason ErrorReason_MIN =
    ErrorMessage_ErrorReason_ErrorReason_MIN;
  static const ErrorReason ErrorReason_MAX =
    ErrorMessage_ErrorReason_ErrorReason_MAX;
  static const int ErrorReason_ARRAYSIZE =
    ErrorMessage_ErrorReason_ErrorReason_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .ErrorMessage.ErrorReason errorReason = 1;
  inline bool has_errorreason() const;
  inline void clear_errorreason();
  static const int kErrorReasonFieldNumber = 1;
  inline ::ErrorMessage_ErrorReason errorreason() const;
  inline void set_errorreason(::ErrorMessage_ErrorReason value);
  
  // @@protoc_insertion_point(class_scope:ErrorMessage)
 private:
  inline void set_has_errorreason();
  inline void clear_has_errorreason();
  
  int errorreason_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static ErrorMessage* default_instance_;
};
// -------------------------------------------------------------------

class PokerTHMessage : public ::google::protobuf::MessageLite {
 public:
  PokerTHMessage();
  virtual ~PokerTHMessage();
  
  PokerTHMessage(const PokerTHMessage& from);
  
  inline PokerTHMessage& operator=(const PokerTHMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PokerTHMessage& default_instance();
  
  void Swap(PokerTHMessage* other);
  
  // implements Message ----------------------------------------------
  
  PokerTHMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PokerTHMessage& from);
  void MergeFrom(const PokerTHMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef PokerTHMessage_PokerTHMessageType PokerTHMessageType;
  static const PokerTHMessageType Type_AnnounceMessage = PokerTHMessage_PokerTHMessageType_Type_AnnounceMessage;
  static const PokerTHMessageType Type_InitMessage = PokerTHMessage_PokerTHMessageType_Type_InitMessage;
  static const PokerTHMessageType Type_AuthServerChallengeMessage = PokerTHMessage_PokerTHMessageType_Type_AuthServerChallengeMessage;
  static const PokerTHMessageType Type_AuthClientResponseMessage = PokerTHMessage_PokerTHMessageType_Type_AuthClientResponseMessage;
  static const PokerTHMessageType Type_AuthServerVerificationMessage = PokerTHMessage_PokerTHMessageType_Type_AuthServerVerificationMessage;
  static const PokerTHMessageType Type_InitAckMessage = PokerTHMessage_PokerTHMessageType_Type_InitAckMessage;
  static const PokerTHMessageType Type_AvatarRequestMessage = PokerTHMessage_PokerTHMessageType_Type_AvatarRequestMessage;
  static const PokerTHMessageType Type_AvatarHeaderMessage = PokerTHMessage_PokerTHMessageType_Type_AvatarHeaderMessage;
  static const PokerTHMessageType Type_AvatarDataMessage = PokerTHMessage_PokerTHMessageType_Type_AvatarDataMessage;
  static const PokerTHMessageType Type_AvatarEndMessage = PokerTHMessage_PokerTHMessageType_Type_AvatarEndMessage;
  static const PokerTHMessageType Type_UnknownAvatarMessage = PokerTHMessage_PokerTHMessageType_Type_UnknownAvatarMessage;
  static const PokerTHMessageType Type_PlayerListMessage = PokerTHMessage_PokerTHMessageType_Type_PlayerListMessage;
  static const PokerTHMessageType Type_GameListNewMessage = PokerTHMessage_PokerTHMessageType_Type_GameListNewMessage;
  static const PokerTHMessageType Type_GameListUpdateMessage = PokerTHMessage_PokerTHMessageType_Type_GameListUpdateMessage;
  static const PokerTHMessageType Type_GameListPlayerJoinedMessage = PokerTHMessage_PokerTHMessageType_Type_GameListPlayerJoinedMessage;
  static const PokerTHMessageType Type_GameListPlayerLeftMessage = PokerTHMessage_PokerTHMessageType_Type_GameListPlayerLeftMessage;
  static const PokerTHMessageType Type_GameListAdminChangedMessage = PokerTHMessage_PokerTHMessageType_Type_GameListAdminChangedMessage;
  static const PokerTHMessageType Type_PlayerInfoRequestMessage = PokerTHMessage_PokerTHMessageType_Type_PlayerInfoRequestMessage;
  static const PokerTHMessageType Type_PlayerInfoReplyMessage = PokerTHMessage_PokerTHMessageType_Type_PlayerInfoReplyMessage;
  static const PokerTHMessageType Type_SubscriptionRequestMessage = PokerTHMessage_PokerTHMessageType_Type_SubscriptionRequestMessage;
  static const PokerTHMessageType Type_JoinExistingGameMessage = PokerTHMessage_PokerTHMessageType_Type_JoinExistingGameMessage;
  static const PokerTHMessageType Type_JoinNewGameMessage = PokerTHMessage_PokerTHMessageType_Type_JoinNewGameMessage;
  static const PokerTHMessageType Type_RejoinExistingGameMessage = PokerTHMessage_PokerTHMessageType_Type_RejoinExistingGameMessage;
  static const PokerTHMessageType Type_JoinGameAckMessage = PokerTHMessage_PokerTHMessageType_Type_JoinGameAckMessage;
  static const PokerTHMessageType Type_JoinGameFailedMessage = PokerTHMessage_PokerTHMessageType_Type_JoinGameFailedMessage;
  static const PokerTHMessageType Type_GamePlayerJoinedMessage = PokerTHMessage_PokerTHMessageType_Type_GamePlayerJoinedMessage;
  static const PokerTHMessageType Type_GamePlayerLeftMessage = PokerTHMessage_PokerTHMessageType_Type_GamePlayerLeftMessage;
  static const PokerTHMessageType Type_GameAdminChangedMessage = PokerTHMessage_PokerTHMessageType_Type_GameAdminChangedMessage;
  static const PokerTHMessageType Type_RemovedFromGameMessage = PokerTHMessage_PokerTHMessageType_Type_RemovedFromGameMessage;
  static const PokerTHMessageType Type_KickPlayerRequestMessage = PokerTHMessage_PokerTHMessageType_Type_KickPlayerRequestMessage;
  static const PokerTHMessageType Type_LeaveGameRequestMessage = PokerTHMessage_PokerTHMessageType_Type_LeaveGameRequestMessage;
  static const PokerTHMessageType Type_InvitePlayerToGameMessage = PokerTHMessage_PokerTHMessageType_Type_InvitePlayerToGameMessage;
  static const PokerTHMessageType Type_InviteNotifyMessage = PokerTHMessage_PokerTHMessageType_Type_InviteNotifyMessage;
  static const PokerTHMessageType Type_RejectGameInvitationMessage = PokerTHMessage_PokerTHMessageType_Type_RejectGameInvitationMessage;
  static const PokerTHMessageType Type_RejectInvNotifyMessage = PokerTHMessage_PokerTHMessageType_Type_RejectInvNotifyMessage;
  static const PokerTHMessageType Type_StartEventMessage = PokerTHMessage_PokerTHMessageType_Type_StartEventMessage;
  static const PokerTHMessageType Type_StartEventAckMessage = PokerTHMessage_PokerTHMessageType_Type_StartEventAckMessage;
  static const PokerTHMessageType Type_GameStartInitialMessage = PokerTHMessage_PokerTHMessageType_Type_GameStartInitialMessage;
  static const PokerTHMessageType Type_GameStartRejoinMessage = PokerTHMessage_PokerTHMessageType_Type_GameStartRejoinMessage;
  static const PokerTHMessageType Type_HandStartMessage = PokerTHMessage_PokerTHMessageType_Type_HandStartMessage;
  static const PokerTHMessageType Type_PlayersTurnMessage = PokerTHMessage_PokerTHMessageType_Type_PlayersTurnMessage;
  static const PokerTHMessageType Type_MyActionRequestMessage = PokerTHMessage_PokerTHMessageType_Type_MyActionRequestMessage;
  static const PokerTHMessageType Type_YourActionRejectedMessage = PokerTHMessage_PokerTHMessageType_Type_YourActionRejectedMessage;
  static const PokerTHMessageType Type_PlayersActionDoneMessage = PokerTHMessage_PokerTHMessageType_Type_PlayersActionDoneMessage;
  static const PokerTHMessageType Type_DealFlopCardsMessage = PokerTHMessage_PokerTHMessageType_Type_DealFlopCardsMessage;
  static const PokerTHMessageType Type_DealTurnCardMessage = PokerTHMessage_PokerTHMessageType_Type_DealTurnCardMessage;
  static const PokerTHMessageType Type_DealRiverCardMessage = PokerTHMessage_PokerTHMessageType_Type_DealRiverCardMessage;
  static const PokerTHMessageType Type_AllInShowCardsMessage = PokerTHMessage_PokerTHMessageType_Type_AllInShowCardsMessage;
  static const PokerTHMessageType Type_EndOfHandShowCardsMessage = PokerTHMessage_PokerTHMessageType_Type_EndOfHandShowCardsMessage;
  static const PokerTHMessageType Type_EndOfHandHideCardsMessage = PokerTHMessage_PokerTHMessageType_Type_EndOfHandHideCardsMessage;
  static const PokerTHMessageType Type_ShowMyCardsRequestMessage = PokerTHMessage_PokerTHMessageType_Type_ShowMyCardsRequestMessage;
  static const PokerTHMessageType Type_AfterHandShowCardsMessage = PokerTHMessage_PokerTHMessageType_Type_AfterHandShowCardsMessage;
  static const PokerTHMessageType Type_EndOfGameMessage = PokerTHMessage_PokerTHMessageType_Type_EndOfGameMessage;
  static const PokerTHMessageType Type_PlayerIdChangedMessage = PokerTHMessage_PokerTHMessageType_Type_PlayerIdChangedMessage;
  static const PokerTHMessageType Type_AskKickPlayerMessage = PokerTHMessage_PokerTHMessageType_Type_AskKickPlayerMessage;
  static const PokerTHMessageType Type_AskKickDeniedMessage = PokerTHMessage_PokerTHMessageType_Type_AskKickDeniedMessage;
  static const PokerTHMessageType Type_StartKickPetitionMessage = PokerTHMessage_PokerTHMessageType_Type_StartKickPetitionMessage;
  static const PokerTHMessageType Type_VoteKickRequestMessage = PokerTHMessage_PokerTHMessageType_Type_VoteKickRequestMessage;
  static const PokerTHMessageType Type_VoteKickReplyMessage = PokerTHMessage_PokerTHMessageType_Type_VoteKickReplyMessage;
  static const PokerTHMessageType Type_KickPetitionUpdateMessage = PokerTHMessage_PokerTHMessageType_Type_KickPetitionUpdateMessage;
  static const PokerTHMessageType Type_EndKickPetitionMessage = PokerTHMessage_PokerTHMessageType_Type_EndKickPetitionMessage;
  static const PokerTHMessageType Type_StatisticsMessage = PokerTHMessage_PokerTHMessageType_Type_StatisticsMessage;
  static const PokerTHMessageType Type_ChatRequestMessage = PokerTHMessage_PokerTHMessageType_Type_ChatRequestMessage;
  static const PokerTHMessageType Type_ChatMessage = PokerTHMessage_PokerTHMessageType_Type_ChatMessage;
  static const PokerTHMessageType Type_ChatRejectMessage = PokerTHMessage_PokerTHMessageType_Type_ChatRejectMessage;
  static const PokerTHMessageType Type_DialogMessage = PokerTHMessage_PokerTHMessageType_Type_DialogMessage;
  static const PokerTHMessageType Type_TimeoutWarningMessage = PokerTHMessage_PokerTHMessageType_Type_TimeoutWarningMessage;
  static const PokerTHMessageType Type_ResetTimeoutMessage = PokerTHMessage_PokerTHMessageType_Type_ResetTimeoutMessage;
  static const PokerTHMessageType Type_ReportAvatarMessage = PokerTHMessage_PokerTHMessageType_Type_ReportAvatarMessage;
  static const PokerTHMessageType Type_ReportAvatarAckMessage = PokerTHMessage_PokerTHMessageType_Type_ReportAvatarAckMessage;
  static const PokerTHMessageType Type_ReportGameMessage = PokerTHMessage_PokerTHMessageType_Type_ReportGameMessage;
  static const PokerTHMessageType Type_ReportGameAckMessage = PokerTHMessage_PokerTHMessageType_Type_ReportGameAckMessage;
  static const PokerTHMessageType Type_ErrorMessage = PokerTHMessage_PokerTHMessageType_Type_ErrorMessage;
  static inline bool PokerTHMessageType_IsValid(int value) {
    return PokerTHMessage_PokerTHMessageType_IsValid(value);
  }
  static const PokerTHMessageType PokerTHMessageType_MIN =
    PokerTHMessage_PokerTHMessageType_PokerTHMessageType_MIN;
  static const PokerTHMessageType PokerTHMessageType_MAX =
    PokerTHMessage_PokerTHMessageType_PokerTHMessageType_MAX;
  static const int PokerTHMessageType_ARRAYSIZE =
    PokerTHMessage_PokerTHMessageType_PokerTHMessageType_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .PokerTHMessage.PokerTHMessageType messageType = 1;
  inline bool has_messagetype() const;
  inline void clear_messagetype();
  static const int kMessageTypeFieldNumber = 1;
  inline ::PokerTHMessage_PokerTHMessageType messagetype() const;
  inline void set_messagetype(::PokerTHMessage_PokerTHMessageType value);
  
  // optional .AnnounceMessage announceMessage = 2;
  inline bool has_announcemessage() const;
  inline void clear_announcemessage();
  static const int kAnnounceMessageFieldNumber = 2;
  inline const ::AnnounceMessage& announcemessage() const;
  inline ::AnnounceMessage* mutable_announcemessage();
  inline ::AnnounceMessage* release_announcemessage();
  
  // optional .InitMessage initMessage = 3;
  inline bool has_initmessage() const;
  inline void clear_initmessage();
  static const int kInitMessageFieldNumber = 3;
  inline const ::InitMessage& initmessage() const;
  inline ::InitMessage* mutable_initmessage();
  inline ::InitMessage* release_initmessage();
  
  // optional .AuthServerChallengeMessage authServerChallengeMessage = 4;
  inline bool has_authserverchallengemessage() const;
  inline void clear_authserverchallengemessage();
  static const int kAuthServerChallengeMessageFieldNumber = 4;
  inline const ::AuthServerChallengeMessage& authserverchallengemessage() const;
  inline ::AuthServerChallengeMessage* mutable_authserverchallengemessage();
  inline ::AuthServerChallengeMessage* release_authserverchallengemessage();
  
  // optional .AuthClientResponseMessage authClientResponseMessage = 5;
  inline bool has_authclientresponsemessage() const;
  inline void clear_authclientresponsemessage();
  static const int kAuthClientResponseMessageFieldNumber = 5;
  inline const ::AuthClientResponseMessage& authclientresponsemessage() const;
  inline ::AuthClientResponseMessage* mutable_authclientresponsemessage();
  inline ::AuthClientResponseMessage* release_authclientresponsemessage();
  
  // optional .AuthServerVerificationMessage authServerVerificationMessage = 6;
  inline bool has_authserververificationmessage() const;
  inline void clear_authserververificationmessage();
  static const int kAuthServerVerificationMessageFieldNumber = 6;
  inline const ::AuthServerVerificationMessage& authserververificationmessage() const;
  inline ::AuthServerVerificationMessage* mutable_authserververificationmessage();
  inline ::AuthServerVerificationMessage* release_authserververificationmessage();
  
  // optional .InitAckMessage initAckMessage = 7;
  inline bool has_initackmessage() const;
  inline void clear_initackmessage();
  static const int kInitAckMessageFieldNumber = 7;
  inline const ::InitAckMessage& initackmessage() const;
  inline ::InitAckMessage* mutable_initackmessage();
  inline ::InitAckMessage* release_initackmessage();
  
  // optional .AvatarRequestMessage avatarRequestMessage = 8;
  inline bool has_avatarrequestmessage() const;
  inline void clear_avatarrequestmessage();
  static const int kAvatarRequestMessageFieldNumber = 8;
  inline const ::AvatarRequestMessage& avatarrequestmessage() const;
  inline ::AvatarRequestMessage* mutable_avatarrequestmessage();
  inline ::AvatarRequestMessage* release_avatarrequestmessage();
  
  // optional .AvatarHeaderMessage avatarHeaderMessage = 9;
  inline bool has_avatarheadermessage() const;
  inline void clear_avatarheadermessage();
  static const int kAvatarHeaderMessageFieldNumber = 9;
  inline const ::AvatarHeaderMessage& avatarheadermessage() const;
  inline ::AvatarHeaderMessage* mutable_avatarheadermessage();
  inline ::AvatarHeaderMessage* release_avatarheadermessage();
  
  // optional .AvatarDataMessage avatarDataMessage = 10;
  inline bool has_avatardatamessage() const;
  inline void clear_avatardatamessage();
  static const int kAvatarDataMessageFieldNumber = 10;
  inline const ::AvatarDataMessage& avatardatamessage() const;
  inline ::AvatarDataMessage* mutable_avatardatamessage();
  inline ::AvatarDataMessage* release_avatardatamessage();
  
  // optional .AvatarEndMessage avatarEndMessage = 11;
  inline bool has_avatarendmessage() const;
  inline void clear_avatarendmessage();
  static const int kAvatarEndMessageFieldNumber = 11;
  inline const ::AvatarEndMessage& avatarendmessage() const;
  inline ::AvatarEndMessage* mutable_avatarendmessage();
  inline ::AvatarEndMessage* release_avatarendmessage();
  
  // optional .UnknownAvatarMessage unknownAvatarMessage = 12;
  inline bool has_unknownavatarmessage() const;
  inline void clear_unknownavatarmessage();
  static const int kUnknownAvatarMessageFieldNumber = 12;
  inline const ::UnknownAvatarMessage& unknownavatarmessage() const;
  inline ::UnknownAvatarMessage* mutable_unknownavatarmessage();
  inline ::UnknownAvatarMessage* release_unknownavatarmessage();
  
  // optional .PlayerListMessage playerListMessage = 13;
  inline bool has_playerlistmessage() const;
  inline void clear_playerlistmessage();
  static const int kPlayerListMessageFieldNumber = 13;
  inline const ::PlayerListMessage& playerlistmessage() const;
  inline ::PlayerListMessage* mutable_playerlistmessage();
  inline ::PlayerListMessage* release_playerlistmessage();
  
  // optional .GameListNewMessage gameListNewMessage = 14;
  inline bool has_gamelistnewmessage() const;
  inline void clear_gamelistnewmessage();
  static const int kGameListNewMessageFieldNumber = 14;
  inline const ::GameListNewMessage& gamelistnewmessage() const;
  inline ::GameListNewMessage* mutable_gamelistnewmessage();
  inline ::GameListNewMessage* release_gamelistnewmessage();
  
  // optional .GameListUpdateMessage gameListUpdateMessage = 15;
  inline bool has_gamelistupdatemessage() const;
  inline void clear_gamelistupdatemessage();
  static const int kGameListUpdateMessageFieldNumber = 15;
  inline const ::GameListUpdateMessage& gamelistupdatemessage() const;
  inline ::GameListUpdateMessage* mutable_gamelistupdatemessage();
  inline ::GameListUpdateMessage* release_gamelistupdatemessage();
  
  // optional .GameListPlayerJoinedMessage gameListPlayerJoinedMessage = 16;
  inline bool has_gamelistplayerjoinedmessage() const;
  inline void clear_gamelistplayerjoinedmessage();
  static const int kGameListPlayerJoinedMessageFieldNumber = 16;
  inline const ::GameListPlayerJoinedMessage& gamelistplayerjoinedmessage() const;
  inline ::GameListPlayerJoinedMessage* mutable_gamelistplayerjoinedmessage();
  inline ::GameListPlayerJoinedMessage* release_gamelistplayerjoinedmessage();
  
  // optional .GameListPlayerLeftMessage gameListPlayerLeftMessage = 17;
  inline bool has_gamelistplayerleftmessage() const;
  inline void clear_gamelistplayerleftmessage();
  static const int kGameListPlayerLeftMessageFieldNumber = 17;
  inline const ::GameListPlayerLeftMessage& gamelistplayerleftmessage() const;
  inline ::GameListPlayerLeftMessage* mutable_gamelistplayerleftmessage();
  inline ::GameListPlayerLeftMessage* release_gamelistplayerleftmessage();
  
  // optional .GameListAdminChangedMessage gameListAdminChangedMessage = 18;
  inline bool has_gamelistadminchangedmessage() const;
  inline void clear_gamelistadminchangedmessage();
  static const int kGameListAdminChangedMessageFieldNumber = 18;
  inline const ::GameListAdminChangedMessage& gamelistadminchangedmessage() const;
  inline ::GameListAdminChangedMessage* mutable_gamelistadminchangedmessage();
  inline ::GameListAdminChangedMessage* release_gamelistadminchangedmessage();
  
  // optional .PlayerInfoRequestMessage playerInfoRequestMessage = 19;
  inline bool has_playerinforequestmessage() const;
  inline void clear_playerinforequestmessage();
  static const int kPlayerInfoRequestMessageFieldNumber = 19;
  inline const ::PlayerInfoRequestMessage& playerinforequestmessage() const;
  inline ::PlayerInfoRequestMessage* mutable_playerinforequestmessage();
  inline ::PlayerInfoRequestMessage* release_playerinforequestmessage();
  
  // optional .PlayerInfoReplyMessage playerInfoReplyMessage = 20;
  inline bool has_playerinforeplymessage() const;
  inline void clear_playerinforeplymessage();
  static const int kPlayerInfoReplyMessageFieldNumber = 20;
  inline const ::PlayerInfoReplyMessage& playerinforeplymessage() const;
  inline ::PlayerInfoReplyMessage* mutable_playerinforeplymessage();
  inline ::PlayerInfoReplyMessage* release_playerinforeplymessage();
  
  // optional .SubscriptionRequestMessage subscriptionRequestMessage = 21;
  inline bool has_subscriptionrequestmessage() const;
  inline void clear_subscriptionrequestmessage();
  static const int kSubscriptionRequestMessageFieldNumber = 21;
  inline const ::SubscriptionRequestMessage& subscriptionrequestmessage() const;
  inline ::SubscriptionRequestMessage* mutable_subscriptionrequestmessage();
  inline ::SubscriptionRequestMessage* release_subscriptionrequestmessage();
  
  // optional .JoinExistingGameMessage joinExistingGameMessage = 22;
  inline bool has_joinexistinggamemessage() const;
  inline void clear_joinexistinggamemessage();
  static const int kJoinExistingGameMessageFieldNumber = 22;
  inline const ::JoinExistingGameMessage& joinexistinggamemessage() const;
  inline ::JoinExistingGameMessage* mutable_joinexistinggamemessage();
  inline ::JoinExistingGameMessage* release_joinexistinggamemessage();
  
  // optional .JoinNewGameMessage joinNewGameMessage = 23;
  inline bool has_joinnewgamemessage() const;
  inline void clear_joinnewgamemessage();
  static const int kJoinNewGameMessageFieldNumber = 23;
  inline const ::JoinNewGameMessage& joinnewgamemessage() const;
  inline ::JoinNewGameMessage* mutable_joinnewgamemessage();
  inline ::JoinNewGameMessage* release_joinnewgamemessage();
  
  // optional .RejoinExistingGameMessage rejoinExistingGameMessage = 24;
  inline bool has_rejoinexistinggamemessage() const;
  inline void clear_rejoinexistinggamemessage();
  static const int kRejoinExistingGameMessageFieldNumber = 24;
  inline const ::RejoinExistingGameMessage& rejoinexistinggamemessage() const;
  inline ::RejoinExistingGameMessage* mutable_rejoinexistinggamemessage();
  inline ::RejoinExistingGameMessage* release_rejoinexistinggamemessage();
  
  // optional .JoinGameAckMessage joinGameAckMessage = 25;
  inline bool has_joingameackmessage() const;
  inline void clear_joingameackmessage();
  static const int kJoinGameAckMessageFieldNumber = 25;
  inline const ::JoinGameAckMessage& joingameackmessage() const;
  inline ::JoinGameAckMessage* mutable_joingameackmessage();
  inline ::JoinGameAckMessage* release_joingameackmessage();
  
  // optional .JoinGameFailedMessage joinGameFailedMessage = 26;
  inline bool has_joingamefailedmessage() const;
  inline void clear_joingamefailedmessage();
  static const int kJoinGameFailedMessageFieldNumber = 26;
  inline const ::JoinGameFailedMessage& joingamefailedmessage() const;
  inline ::JoinGameFailedMessage* mutable_joingamefailedmessage();
  inline ::JoinGameFailedMessage* release_joingamefailedmessage();
  
  // optional .GamePlayerJoinedMessage gamePlayerJoinedMessage = 27;
  inline bool has_gameplayerjoinedmessage() const;
  inline void clear_gameplayerjoinedmessage();
  static const int kGamePlayerJoinedMessageFieldNumber = 27;
  inline const ::GamePlayerJoinedMessage& gameplayerjoinedmessage() const;
  inline ::GamePlayerJoinedMessage* mutable_gameplayerjoinedmessage();
  inline ::GamePlayerJoinedMessage* release_gameplayerjoinedmessage();
  
  // optional .GamePlayerLeftMessage gamePlayerLeftMessage = 28;
  inline bool has_gameplayerleftmessage() const;
  inline void clear_gameplayerleftmessage();
  static const int kGamePlayerLeftMessageFieldNumber = 28;
  inline const ::GamePlayerLeftMessage& gameplayerleftmessage() const;
  inline ::GamePlayerLeftMessage* mutable_gameplayerleftmessage();
  inline ::GamePlayerLeftMessage* release_gameplayerleftmessage();
  
  // optional .GameAdminChangedMessage gameAdminChangedMessage = 29;
  inline bool has_gameadminchangedmessage() const;
  inline void clear_gameadminchangedmessage();
  static const int kGameAdminChangedMessageFieldNumber = 29;
  inline const ::GameAdminChangedMessage& gameadminchangedmessage() const;
  inline ::GameAdminChangedMessage* mutable_gameadminchangedmessage();
  inline ::GameAdminChangedMessage* release_gameadminchangedmessage();
  
  // optional .RemovedFromGameMessage removedFromGameMessage = 30;
  inline bool has_removedfromgamemessage() const;
  inline void clear_removedfromgamemessage();
  static const int kRemovedFromGameMessageFieldNumber = 30;
  inline const ::RemovedFromGameMessage& removedfromgamemessage() const;
  inline ::RemovedFromGameMessage* mutable_removedfromgamemessage();
  inline ::RemovedFromGameMessage* release_removedfromgamemessage();
  
  // optional .KickPlayerRequestMessage kickPlayerRequestMessage = 31;
  inline bool has_kickplayerrequestmessage() const;
  inline void clear_kickplayerrequestmessage();
  static const int kKickPlayerRequestMessageFieldNumber = 31;
  inline const ::KickPlayerRequestMessage& kickplayerrequestmessage() const;
  inline ::KickPlayerRequestMessage* mutable_kickplayerrequestmessage();
  inline ::KickPlayerRequestMessage* release_kickplayerrequestmessage();
  
  // optional .LeaveGameRequestMessage leaveGameRequestMessage = 32;
  inline bool has_leavegamerequestmessage() const;
  inline void clear_leavegamerequestmessage();
  static const int kLeaveGameRequestMessageFieldNumber = 32;
  inline const ::LeaveGameRequestMessage& leavegamerequestmessage() const;
  inline ::LeaveGameRequestMessage* mutable_leavegamerequestmessage();
  inline ::LeaveGameRequestMessage* release_leavegamerequestmessage();
  
  // optional .InvitePlayerToGameMessage invitePlayerToGameMessage = 33;
  inline bool has_inviteplayertogamemessage() const;
  inline void clear_inviteplayertogamemessage();
  static const int kInvitePlayerToGameMessageFieldNumber = 33;
  inline const ::InvitePlayerToGameMessage& inviteplayertogamemessage() const;
  inline ::InvitePlayerToGameMessage* mutable_inviteplayertogamemessage();
  inline ::InvitePlayerToGameMessage* release_inviteplayertogamemessage();
  
  // optional .InviteNotifyMessage inviteNotifyMessage = 34;
  inline bool has_invitenotifymessage() const;
  inline void clear_invitenotifymessage();
  static const int kInviteNotifyMessageFieldNumber = 34;
  inline const ::InviteNotifyMessage& invitenotifymessage() const;
  inline ::InviteNotifyMessage* mutable_invitenotifymessage();
  inline ::InviteNotifyMessage* release_invitenotifymessage();
  
  // optional .RejectGameInvitationMessage rejectGameInvitationMessage = 35;
  inline bool has_rejectgameinvitationmessage() const;
  inline void clear_rejectgameinvitationmessage();
  static const int kRejectGameInvitationMessageFieldNumber = 35;
  inline const ::RejectGameInvitationMessage& rejectgameinvitationmessage() const;
  inline ::RejectGameInvitationMessage* mutable_rejectgameinvitationmessage();
  inline ::RejectGameInvitationMessage* release_rejectgameinvitationmessage();
  
  // optional .RejectInvNotifyMessage rejectInvNotifyMessage = 36;
  inline bool has_rejectinvnotifymessage() const;
  inline void clear_rejectinvnotifymessage();
  static const int kRejectInvNotifyMessageFieldNumber = 36;
  inline const ::RejectInvNotifyMessage& rejectinvnotifymessage() const;
  inline ::RejectInvNotifyMessage* mutable_rejectinvnotifymessage();
  inline ::RejectInvNotifyMessage* release_rejectinvnotifymessage();
  
  // optional .StartEventMessage startEventMessage = 37;
  inline bool has_starteventmessage() const;
  inline void clear_starteventmessage();
  static const int kStartEventMessageFieldNumber = 37;
  inline const ::StartEventMessage& starteventmessage() const;
  inline ::StartEventMessage* mutable_starteventmessage();
  inline ::StartEventMessage* release_starteventmessage();
  
  // optional .StartEventAckMessage startEventAckMessage = 38;
  inline bool has_starteventackmessage() const;
  inline void clear_starteventackmessage();
  static const int kStartEventAckMessageFieldNumber = 38;
  inline const ::StartEventAckMessage& starteventackmessage() const;
  inline ::StartEventAckMessage* mutable_starteventackmessage();
  inline ::StartEventAckMessage* release_starteventackmessage();
  
  // optional .GameStartInitialMessage gameStartInitialMessage = 39;
  inline bool has_gamestartinitialmessage() const;
  inline void clear_gamestartinitialmessage();
  static const int kGameStartInitialMessageFieldNumber = 39;
  inline const ::GameStartInitialMessage& gamestartinitialmessage() const;
  inline ::GameStartInitialMessage* mutable_gamestartinitialmessage();
  inline ::GameStartInitialMessage* release_gamestartinitialmessage();
  
  // optional .GameStartRejoinMessage gameStartRejoinMessage = 40;
  inline bool has_gamestartrejoinmessage() const;
  inline void clear_gamestartrejoinmessage();
  static const int kGameStartRejoinMessageFieldNumber = 40;
  inline const ::GameStartRejoinMessage& gamestartrejoinmessage() const;
  inline ::GameStartRejoinMessage* mutable_gamestartrejoinmessage();
  inline ::GameStartRejoinMessage* release_gamestartrejoinmessage();
  
  // optional .HandStartMessage handStartMessage = 41;
  inline bool has_handstartmessage() const;
  inline void clear_handstartmessage();
  static const int kHandStartMessageFieldNumber = 41;
  inline const ::HandStartMessage& handstartmessage() const;
  inline ::HandStartMessage* mutable_handstartmessage();
  inline ::HandStartMessage* release_handstartmessage();
  
  // optional .PlayersTurnMessage playersTurnMessage = 42;
  inline bool has_playersturnmessage() const;
  inline void clear_playersturnmessage();
  static const int kPlayersTurnMessageFieldNumber = 42;
  inline const ::PlayersTurnMessage& playersturnmessage() const;
  inline ::PlayersTurnMessage* mutable_playersturnmessage();
  inline ::PlayersTurnMessage* release_playersturnmessage();
  
  // optional .MyActionRequestMessage myActionRequestMessage = 43;
  inline bool has_myactionrequestmessage() const;
  inline void clear_myactionrequestmessage();
  static const int kMyActionRequestMessageFieldNumber = 43;
  inline const ::MyActionRequestMessage& myactionrequestmessage() const;
  inline ::MyActionRequestMessage* mutable_myactionrequestmessage();
  inline ::MyActionRequestMessage* release_myactionrequestmessage();
  
  // optional .YourActionRejectedMessage yourActionRejectedMessage = 44;
  inline bool has_youractionrejectedmessage() const;
  inline void clear_youractionrejectedmessage();
  static const int kYourActionRejectedMessageFieldNumber = 44;
  inline const ::YourActionRejectedMessage& youractionrejectedmessage() const;
  inline ::YourActionRejectedMessage* mutable_youractionrejectedmessage();
  inline ::YourActionRejectedMessage* release_youractionrejectedmessage();
  
  // optional .PlayersActionDoneMessage playersActionDoneMessage = 45;
  inline bool has_playersactiondonemessage() const;
  inline void clear_playersactiondonemessage();
  static const int kPlayersActionDoneMessageFieldNumber = 45;
  inline const ::PlayersActionDoneMessage& playersactiondonemessage() const;
  inline ::PlayersActionDoneMessage* mutable_playersactiondonemessage();
  inline ::PlayersActionDoneMessage* release_playersactiondonemessage();
  
  // optional .DealFlopCardsMessage dealFlopCardsMessage = 46;
  inline bool has_dealflopcardsmessage() const;
  inline void clear_dealflopcardsmessage();
  static const int kDealFlopCardsMessageFieldNumber = 46;
  inline const ::DealFlopCardsMessage& dealflopcardsmessage() const;
  inline ::DealFlopCardsMessage* mutable_dealflopcardsmessage();
  inline ::DealFlopCardsMessage* release_dealflopcardsmessage();
  
  // optional .DealTurnCardMessage dealTurnCardMessage = 47;
  inline bool has_dealturncardmessage() const;
  inline void clear_dealturncardmessage();
  static const int kDealTurnCardMessageFieldNumber = 47;
  inline const ::DealTurnCardMessage& dealturncardmessage() const;
  inline ::DealTurnCardMessage* mutable_dealturncardmessage();
  inline ::DealTurnCardMessage* release_dealturncardmessage();
  
  // optional .DealRiverCardMessage dealRiverCardMessage = 48;
  inline bool has_dealrivercardmessage() const;
  inline void clear_dealrivercardmessage();
  static const int kDealRiverCardMessageFieldNumber = 48;
  inline const ::DealRiverCardMessage& dealrivercardmessage() const;
  inline ::DealRiverCardMessage* mutable_dealrivercardmessage();
  inline ::DealRiverCardMessage* release_dealrivercardmessage();
  
  // optional .AllInShowCardsMessage allInShowCardsMessage = 49;
  inline bool has_allinshowcardsmessage() const;
  inline void clear_allinshowcardsmessage();
  static const int kAllInShowCardsMessageFieldNumber = 49;
  inline const ::AllInShowCardsMessage& allinshowcardsmessage() const;
  inline ::AllInShowCardsMessage* mutable_allinshowcardsmessage();
  inline ::AllInShowCardsMessage* release_allinshowcardsmessage();
  
  // optional .EndOfHandShowCardsMessage endOfHandShowCardsMessage = 50;
  inline bool has_endofhandshowcardsmessage() const;
  inline void clear_endofhandshowcardsmessage();
  static const int kEndOfHandShowCardsMessageFieldNumber = 50;
  inline const ::EndOfHandShowCardsMessage& endofhandshowcardsmessage() const;
  inline ::EndOfHandShowCardsMessage* mutable_endofhandshowcardsmessage();
  inline ::EndOfHandShowCardsMessage* release_endofhandshowcardsmessage();
  
  // optional .EndOfHandHideCardsMessage endOfHandHideCardsMessage = 51;
  inline bool has_endofhandhidecardsmessage() const;
  inline void clear_endofhandhidecardsmessage();
  static const int kEndOfHandHideCardsMessageFieldNumber = 51;
  inline const ::EndOfHandHideCardsMessage& endofhandhidecardsmessage() const;
  inline ::EndOfHandHideCardsMessage* mutable_endofhandhidecardsmessage();
  inline ::EndOfHandHideCardsMessage* release_endofhandhidecardsmessage();
  
  // optional .ShowMyCardsRequestMessage showMyCardsRequestMessage = 52;
  inline bool has_showmycardsrequestmessage() const;
  inline void clear_showmycardsrequestmessage();
  static const int kShowMyCardsRequestMessageFieldNumber = 52;
  inline const ::ShowMyCardsRequestMessage& showmycardsrequestmessage() const;
  inline ::ShowMyCardsRequestMessage* mutable_showmycardsrequestmessage();
  inline ::ShowMyCardsRequestMessage* release_showmycardsrequestmessage();
  
  // optional .AfterHandShowCardsMessage afterHandShowCardsMessage = 53;
  inline bool has_afterhandshowcardsmessage() const;
  inline void clear_afterhandshowcardsmessage();
  static const int kAfterHandShowCardsMessageFieldNumber = 53;
  inline const ::AfterHandShowCardsMessage& afterhandshowcardsmessage() const;
  inline ::AfterHandShowCardsMessage* mutable_afterhandshowcardsmessage();
  inline ::AfterHandShowCardsMessage* release_afterhandshowcardsmessage();
  
  // optional .EndOfGameMessage endOfGameMessage = 54;
  inline bool has_endofgamemessage() const;
  inline void clear_endofgamemessage();
  static const int kEndOfGameMessageFieldNumber = 54;
  inline const ::EndOfGameMessage& endofgamemessage() const;
  inline ::EndOfGameMessage* mutable_endofgamemessage();
  inline ::EndOfGameMessage* release_endofgamemessage();
  
  // optional .PlayerIdChangedMessage playerIdChangedMessage = 55;
  inline bool has_playeridchangedmessage() const;
  inline void clear_playeridchangedmessage();
  static const int kPlayerIdChangedMessageFieldNumber = 55;
  inline const ::PlayerIdChangedMessage& playeridchangedmessage() const;
  inline ::PlayerIdChangedMessage* mutable_playeridchangedmessage();
  inline ::PlayerIdChangedMessage* release_playeridchangedmessage();
  
  // optional .AskKickPlayerMessage askKickPlayerMessage = 56;
  inline bool has_askkickplayermessage() const;
  inline void clear_askkickplayermessage();
  static const int kAskKickPlayerMessageFieldNumber = 56;
  inline const ::AskKickPlayerMessage& askkickplayermessage() const;
  inline ::AskKickPlayerMessage* mutable_askkickplayermessage();
  inline ::AskKickPlayerMessage* release_askkickplayermessage();
  
  // optional .AskKickDeniedMessage askKickDeniedMessage = 57;
  inline bool has_askkickdeniedmessage() const;
  inline void clear_askkickdeniedmessage();
  static const int kAskKickDeniedMessageFieldNumber = 57;
  inline const ::AskKickDeniedMessage& askkickdeniedmessage() const;
  inline ::AskKickDeniedMessage* mutable_askkickdeniedmessage();
  inline ::AskKickDeniedMessage* release_askkickdeniedmessage();
  
  // optional .StartKickPetitionMessage startKickPetitionMessage = 58;
  inline bool has_startkickpetitionmessage() const;
  inline void clear_startkickpetitionmessage();
  static const int kStartKickPetitionMessageFieldNumber = 58;
  inline const ::StartKickPetitionMessage& startkickpetitionmessage() const;
  inline ::StartKickPetitionMessage* mutable_startkickpetitionmessage();
  inline ::StartKickPetitionMessage* release_startkickpetitionmessage();
  
  // optional .VoteKickRequestMessage voteKickRequestMessage = 59;
  inline bool has_votekickrequestmessage() const;
  inline void clear_votekickrequestmessage();
  static const int kVoteKickRequestMessageFieldNumber = 59;
  inline const ::VoteKickRequestMessage& votekickrequestmessage() const;
  inline ::VoteKickRequestMessage* mutable_votekickrequestmessage();
  inline ::VoteKickRequestMessage* release_votekickrequestmessage();
  
  // optional .VoteKickReplyMessage voteKickReplyMessage = 60;
  inline bool has_votekickreplymessage() const;
  inline void clear_votekickreplymessage();
  static const int kVoteKickReplyMessageFieldNumber = 60;
  inline const ::VoteKickReplyMessage& votekickreplymessage() const;
  inline ::VoteKickReplyMessage* mutable_votekickreplymessage();
  inline ::VoteKickReplyMessage* release_votekickreplymessage();
  
  // optional .KickPetitionUpdateMessage kickPetitionUpdateMessage = 61;
  inline bool has_kickpetitionupdatemessage() const;
  inline void clear_kickpetitionupdatemessage();
  static const int kKickPetitionUpdateMessageFieldNumber = 61;
  inline const ::KickPetitionUpdateMessage& kickpetitionupdatemessage() const;
  inline ::KickPetitionUpdateMessage* mutable_kickpetitionupdatemessage();
  inline ::KickPetitionUpdateMessage* release_kickpetitionupdatemessage();
  
  // optional .EndKickPetitionMessage endKickPetitionMessage = 62;
  inline bool has_endkickpetitionmessage() const;
  inline void clear_endkickpetitionmessage();
  static const int kEndKickPetitionMessageFieldNumber = 62;
  inline const ::EndKickPetitionMessage& endkickpetitionmessage() const;
  inline ::EndKickPetitionMessage* mutable_endkickpetitionmessage();
  inline ::EndKickPetitionMessage* release_endkickpetitionmessage();
  
  // optional .StatisticsMessage statisticsMessage = 63;
  inline bool has_statisticsmessage() const;
  inline void clear_statisticsmessage();
  static const int kStatisticsMessageFieldNumber = 63;
  inline const ::StatisticsMessage& statisticsmessage() const;
  inline ::StatisticsMessage* mutable_statisticsmessage();
  inline ::StatisticsMessage* release_statisticsmessage();
  
  // optional .ChatRequestMessage chatRequestMessage = 64;
  inline bool has_chatrequestmessage() const;
  inline void clear_chatrequestmessage();
  static const int kChatRequestMessageFieldNumber = 64;
  inline const ::ChatRequestMessage& chatrequestmessage() const;
  inline ::ChatRequestMessage* mutable_chatrequestmessage();
  inline ::ChatRequestMessage* release_chatrequestmessage();
  
  // optional .ChatMessage chatMessage = 65;
  inline bool has_chatmessage() const;
  inline void clear_chatmessage();
  static const int kChatMessageFieldNumber = 65;
  inline const ::ChatMessage& chatmessage() const;
  inline ::ChatMessage* mutable_chatmessage();
  inline ::ChatMessage* release_chatmessage();
  
  // optional .ChatRejectMessage chatRejectMessage = 66;
  inline bool has_chatrejectmessage() const;
  inline void clear_chatrejectmessage();
  static const int kChatRejectMessageFieldNumber = 66;
  inline const ::ChatRejectMessage& chatrejectmessage() const;
  inline ::ChatRejectMessage* mutable_chatrejectmessage();
  inline ::ChatRejectMessage* release_chatrejectmessage();
  
  // optional .DialogMessage dialogMessage = 67;
  inline bool has_dialogmessage() const;
  inline void clear_dialogmessage();
  static const int kDialogMessageFieldNumber = 67;
  inline const ::DialogMessage& dialogmessage() const;
  inline ::DialogMessage* mutable_dialogmessage();
  inline ::DialogMessage* release_dialogmessage();
  
  // optional .TimeoutWarningMessage timeoutWarningMessage = 68;
  inline bool has_timeoutwarningmessage() const;
  inline void clear_timeoutwarningmessage();
  static const int kTimeoutWarningMessageFieldNumber = 68;
  inline const ::TimeoutWarningMessage& timeoutwarningmessage() const;
  inline ::TimeoutWarningMessage* mutable_timeoutwarningmessage();
  inline ::TimeoutWarningMessage* release_timeoutwarningmessage();
  
  // optional .ResetTimeoutMessage resetTimeoutMessage = 69;
  inline bool has_resettimeoutmessage() const;
  inline void clear_resettimeoutmessage();
  static const int kResetTimeoutMessageFieldNumber = 69;
  inline const ::ResetTimeoutMessage& resettimeoutmessage() const;
  inline ::ResetTimeoutMessage* mutable_resettimeoutmessage();
  inline ::ResetTimeoutMessage* release_resettimeoutmessage();
  
  // optional .ReportAvatarMessage reportAvatarMessage = 70;
  inline bool has_reportavatarmessage() const;
  inline void clear_reportavatarmessage();
  static const int kReportAvatarMessageFieldNumber = 70;
  inline const ::ReportAvatarMessage& reportavatarmessage() const;
  inline ::ReportAvatarMessage* mutable_reportavatarmessage();
  inline ::ReportAvatarMessage* release_reportavatarmessage();
  
  // optional .ReportAvatarAckMessage reportAvatarAckMessage = 71;
  inline bool has_reportavatarackmessage() const;
  inline void clear_reportavatarackmessage();
  static const int kReportAvatarAckMessageFieldNumber = 71;
  inline const ::ReportAvatarAckMessage& reportavatarackmessage() const;
  inline ::ReportAvatarAckMessage* mutable_reportavatarackmessage();
  inline ::ReportAvatarAckMessage* release_reportavatarackmessage();
  
  // optional .ReportGameMessage reportGameMessage = 72;
  inline bool has_reportgamemessage() const;
  inline void clear_reportgamemessage();
  static const int kReportGameMessageFieldNumber = 72;
  inline const ::ReportGameMessage& reportgamemessage() const;
  inline ::ReportGameMessage* mutable_reportgamemessage();
  inline ::ReportGameMessage* release_reportgamemessage();
  
  // optional .ReportGameAckMessage reportGameAckMessage = 73;
  inline bool has_reportgameackmessage() const;
  inline void clear_reportgameackmessage();
  static const int kReportGameAckMessageFieldNumber = 73;
  inline const ::ReportGameAckMessage& reportgameackmessage() const;
  inline ::ReportGameAckMessage* mutable_reportgameackmessage();
  inline ::ReportGameAckMessage* release_reportgameackmessage();
  
  // optional .ErrorMessage errorMessage = 74;
  inline bool has_errormessage() const;
  inline void clear_errormessage();
  static const int kErrorMessageFieldNumber = 74;
  inline const ::ErrorMessage& errormessage() const;
  inline ::ErrorMessage* mutable_errormessage();
  inline ::ErrorMessage* release_errormessage();
  
  // @@protoc_insertion_point(class_scope:PokerTHMessage)
 private:
  inline void set_has_messagetype();
  inline void clear_has_messagetype();
  inline void set_has_announcemessage();
  inline void clear_has_announcemessage();
  inline void set_has_initmessage();
  inline void clear_has_initmessage();
  inline void set_has_authserverchallengemessage();
  inline void clear_has_authserverchallengemessage();
  inline void set_has_authclientresponsemessage();
  inline void clear_has_authclientresponsemessage();
  inline void set_has_authserververificationmessage();
  inline void clear_has_authserververificationmessage();
  inline void set_has_initackmessage();
  inline void clear_has_initackmessage();
  inline void set_has_avatarrequestmessage();
  inline void clear_has_avatarrequestmessage();
  inline void set_has_avatarheadermessage();
  inline void clear_has_avatarheadermessage();
  inline void set_has_avatardatamessage();
  inline void clear_has_avatardatamessage();
  inline void set_has_avatarendmessage();
  inline void clear_has_avatarendmessage();
  inline void set_has_unknownavatarmessage();
  inline void clear_has_unknownavatarmessage();
  inline void set_has_playerlistmessage();
  inline void clear_has_playerlistmessage();
  inline void set_has_gamelistnewmessage();
  inline void clear_has_gamelistnewmessage();
  inline void set_has_gamelistupdatemessage();
  inline void clear_has_gamelistupdatemessage();
  inline void set_has_gamelistplayerjoinedmessage();
  inline void clear_has_gamelistplayerjoinedmessage();
  inline void set_has_gamelistplayerleftmessage();
  inline void clear_has_gamelistplayerleftmessage();
  inline void set_has_gamelistadminchangedmessage();
  inline void clear_has_gamelistadminchangedmessage();
  inline void set_has_playerinforequestmessage();
  inline void clear_has_playerinforequestmessage();
  inline void set_has_playerinforeplymessage();
  inline void clear_has_playerinforeplymessage();
  inline void set_has_subscriptionrequestmessage();
  inline void clear_has_subscriptionrequestmessage();
  inline void set_has_joinexistinggamemessage();
  inline void clear_has_joinexistinggamemessage();
  inline void set_has_joinnewgamemessage();
  inline void clear_has_joinnewgamemessage();
  inline void set_has_rejoinexistinggamemessage();
  inline void clear_has_rejoinexistinggamemessage();
  inline void set_has_joingameackmessage();
  inline void clear_has_joingameackmessage();
  inline void set_has_joingamefailedmessage();
  inline void clear_has_joingamefailedmessage();
  inline void set_has_gameplayerjoinedmessage();
  inline void clear_has_gameplayerjoinedmessage();
  inline void set_has_gameplayerleftmessage();
  inline void clear_has_gameplayerleftmessage();
  inline void set_has_gameadminchangedmessage();
  inline void clear_has_gameadminchangedmessage();
  inline void set_has_removedfromgamemessage();
  inline void clear_has_removedfromgamemessage();
  inline void set_has_kickplayerrequestmessage();
  inline void clear_has_kickplayerrequestmessage();
  inline void set_has_leavegamerequestmessage();
  inline void clear_has_leavegamerequestmessage();
  inline void set_has_inviteplayertogamemessage();
  inline void clear_has_inviteplayertogamemessage();
  inline void set_has_invitenotifymessage();
  inline void clear_has_invitenotifymessage();
  inline void set_has_rejectgameinvitationmessage();
  inline void clear_has_rejectgameinvitationmessage();
  inline void set_has_rejectinvnotifymessage();
  inline void clear_has_rejectinvnotifymessage();
  inline void set_has_starteventmessage();
  inline void clear_has_starteventmessage();
  inline void set_has_starteventackmessage();
  inline void clear_has_starteventackmessage();
  inline void set_has_gamestartinitialmessage();
  inline void clear_has_gamestartinitialmessage();
  inline void set_has_gamestartrejoinmessage();
  inline void clear_has_gamestartrejoinmessage();
  inline void set_has_handstartmessage();
  inline void clear_has_handstartmessage();
  inline void set_has_playersturnmessage();
  inline void clear_has_playersturnmessage();
  inline void set_has_myactionrequestmessage();
  inline void clear_has_myactionrequestmessage();
  inline void set_has_youractionrejectedmessage();
  inline void clear_has_youractionrejectedmessage();
  inline void set_has_playersactiondonemessage();
  inline void clear_has_playersactiondonemessage();
  inline void set_has_dealflopcardsmessage();
  inline void clear_has_dealflopcardsmessage();
  inline void set_has_dealturncardmessage();
  inline void clear_has_dealturncardmessage();
  inline void set_has_dealrivercardmessage();
  inline void clear_has_dealrivercardmessage();
  inline void set_has_allinshowcardsmessage();
  inline void clear_has_allinshowcardsmessage();
  inline void set_has_endofhandshowcardsmessage();
  inline void clear_has_endofhandshowcardsmessage();
  inline void set_has_endofhandhidecardsmessage();
  inline void clear_has_endofhandhidecardsmessage();
  inline void set_has_showmycardsrequestmessage();
  inline void clear_has_showmycardsrequestmessage();
  inline void set_has_afterhandshowcardsmessage();
  inline void clear_has_afterhandshowcardsmessage();
  inline void set_has_endofgamemessage();
  inline void clear_has_endofgamemessage();
  inline void set_has_playeridchangedmessage();
  inline void clear_has_playeridchangedmessage();
  inline void set_has_askkickplayermessage();
  inline void clear_has_askkickplayermessage();
  inline void set_has_askkickdeniedmessage();
  inline void clear_has_askkickdeniedmessage();
  inline void set_has_startkickpetitionmessage();
  inline void clear_has_startkickpetitionmessage();
  inline void set_has_votekickrequestmessage();
  inline void clear_has_votekickrequestmessage();
  inline void set_has_votekickreplymessage();
  inline void clear_has_votekickreplymessage();
  inline void set_has_kickpetitionupdatemessage();
  inline void clear_has_kickpetitionupdatemessage();
  inline void set_has_endkickpetitionmessage();
  inline void clear_has_endkickpetitionmessage();
  inline void set_has_statisticsmessage();
  inline void clear_has_statisticsmessage();
  inline void set_has_chatrequestmessage();
  inline void clear_has_chatrequestmessage();
  inline void set_has_chatmessage();
  inline void clear_has_chatmessage();
  inline void set_has_chatrejectmessage();
  inline void clear_has_chatrejectmessage();
  inline void set_has_dialogmessage();
  inline void clear_has_dialogmessage();
  inline void set_has_timeoutwarningmessage();
  inline void clear_has_timeoutwarningmessage();
  inline void set_has_resettimeoutmessage();
  inline void clear_has_resettimeoutmessage();
  inline void set_has_reportavatarmessage();
  inline void clear_has_reportavatarmessage();
  inline void set_has_reportavatarackmessage();
  inline void clear_has_reportavatarackmessage();
  inline void set_has_reportgamemessage();
  inline void clear_has_reportgamemessage();
  inline void set_has_reportgameackmessage();
  inline void clear_has_reportgameackmessage();
  inline void set_has_errormessage();
  inline void clear_has_errormessage();
  
  ::AnnounceMessage* announcemessage_;
  ::InitMessage* initmessage_;
  ::AuthServerChallengeMessage* authserverchallengemessage_;
  ::AuthClientResponseMessage* authclientresponsemessage_;
  ::AuthServerVerificationMessage* authserververificationmessage_;
  ::InitAckMessage* initackmessage_;
  ::AvatarRequestMessage* avatarrequestmessage_;
  ::AvatarHeaderMessage* avatarheadermessage_;
  ::AvatarDataMessage* avatardatamessage_;
  ::AvatarEndMessage* avatarendmessage_;
  ::UnknownAvatarMessage* unknownavatarmessage_;
  ::PlayerListMessage* playerlistmessage_;
  ::GameListNewMessage* gamelistnewmessage_;
  ::GameListUpdateMessage* gamelistupdatemessage_;
  ::GameListPlayerJoinedMessage* gamelistplayerjoinedmessage_;
  ::GameListPlayerLeftMessage* gamelistplayerleftmessage_;
  ::GameListAdminChangedMessage* gamelistadminchangedmessage_;
  ::PlayerInfoRequestMessage* playerinforequestmessage_;
  ::PlayerInfoReplyMessage* playerinforeplymessage_;
  ::SubscriptionRequestMessage* subscriptionrequestmessage_;
  ::JoinExistingGameMessage* joinexistinggamemessage_;
  ::JoinNewGameMessage* joinnewgamemessage_;
  ::RejoinExistingGameMessage* rejoinexistinggamemessage_;
  ::JoinGameAckMessage* joingameackmessage_;
  ::JoinGameFailedMessage* joingamefailedmessage_;
  ::GamePlayerJoinedMessage* gameplayerjoinedmessage_;
  ::GamePlayerLeftMessage* gameplayerleftmessage_;
  ::GameAdminChangedMessage* gameadminchangedmessage_;
  ::RemovedFromGameMessage* removedfromgamemessage_;
  ::KickPlayerRequestMessage* kickplayerrequestmessage_;
  ::LeaveGameRequestMessage* leavegamerequestmessage_;
  ::InvitePlayerToGameMessage* inviteplayertogamemessage_;
  ::InviteNotifyMessage* invitenotifymessage_;
  ::RejectGameInvitationMessage* rejectgameinvitationmessage_;
  ::RejectInvNotifyMessage* rejectinvnotifymessage_;
  ::StartEventMessage* starteventmessage_;
  ::StartEventAckMessage* starteventackmessage_;
  ::GameStartInitialMessage* gamestartinitialmessage_;
  ::GameStartRejoinMessage* gamestartrejoinmessage_;
  ::HandStartMessage* handstartmessage_;
  ::PlayersTurnMessage* playersturnmessage_;
  ::MyActionRequestMessage* myactionrequestmessage_;
  ::YourActionRejectedMessage* youractionrejectedmessage_;
  ::PlayersActionDoneMessage* playersactiondonemessage_;
  ::DealFlopCardsMessage* dealflopcardsmessage_;
  ::DealTurnCardMessage* dealturncardmessage_;
  ::DealRiverCardMessage* dealrivercardmessage_;
  ::AllInShowCardsMessage* allinshowcardsmessage_;
  ::EndOfHandShowCardsMessage* endofhandshowcardsmessage_;
  ::EndOfHandHideCardsMessage* endofhandhidecardsmessage_;
  ::ShowMyCardsRequestMessage* showmycardsrequestmessage_;
  ::AfterHandShowCardsMessage* afterhandshowcardsmessage_;
  ::EndOfGameMessage* endofgamemessage_;
  ::PlayerIdChangedMessage* playeridchangedmessage_;
  ::AskKickPlayerMessage* askkickplayermessage_;
  ::AskKickDeniedMessage* askkickdeniedmessage_;
  ::StartKickPetitionMessage* startkickpetitionmessage_;
  ::VoteKickRequestMessage* votekickrequestmessage_;
  ::VoteKickReplyMessage* votekickreplymessage_;
  ::KickPetitionUpdateMessage* kickpetitionupdatemessage_;
  ::EndKickPetitionMessage* endkickpetitionmessage_;
  ::StatisticsMessage* statisticsmessage_;
  ::ChatRequestMessage* chatrequestmessage_;
  ::ChatMessage* chatmessage_;
  ::ChatRejectMessage* chatrejectmessage_;
  ::DialogMessage* dialogmessage_;
  ::TimeoutWarningMessage* timeoutwarningmessage_;
  ::ResetTimeoutMessage* resettimeoutmessage_;
  ::ReportAvatarMessage* reportavatarmessage_;
  ::ReportAvatarAckMessage* reportavatarackmessage_;
  ::ReportGameMessage* reportgamemessage_;
  ::ReportGameAckMessage* reportgameackmessage_;
  ::ErrorMessage* errormessage_;
  int messagetype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(74 + 31) / 32];
  
  friend void  protobuf_AddDesc_pokerth_2eproto();
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();
  
  void InitAsDefaultInstance();
  static PokerTHMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// NetGameInfo

// required string gameName = 1;
inline bool NetGameInfo::has_gamename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetGameInfo::set_has_gamename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetGameInfo::clear_has_gamename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetGameInfo::clear_gamename() {
  if (gamename_ != &::google::protobuf::internal::kEmptyString) {
    gamename_->clear();
  }
  clear_has_gamename();
}
inline const ::std::string& NetGameInfo::gamename() const {
  return *gamename_;
}
inline void NetGameInfo::set_gamename(const ::std::string& value) {
  set_has_gamename();
  if (gamename_ == &::google::protobuf::internal::kEmptyString) {
    gamename_ = new ::std::string;
  }
  gamename_->assign(value);
}
inline void NetGameInfo::set_gamename(const char* value) {
  set_has_gamename();
  if (gamename_ == &::google::protobuf::internal::kEmptyString) {
    gamename_ = new ::std::string;
  }
  gamename_->assign(value);
}
inline void NetGameInfo::set_gamename(const char* value, size_t size) {
  set_has_gamename();
  if (gamename_ == &::google::protobuf::internal::kEmptyString) {
    gamename_ = new ::std::string;
  }
  gamename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetGameInfo::mutable_gamename() {
  set_has_gamename();
  if (gamename_ == &::google::protobuf::internal::kEmptyString) {
    gamename_ = new ::std::string;
  }
  return gamename_;
}
inline ::std::string* NetGameInfo::release_gamename() {
  clear_has_gamename();
  if (gamename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamename_;
    gamename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .NetGameInfo.NetGameType netGameType = 2;
inline bool NetGameInfo::has_netgametype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetGameInfo::set_has_netgametype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetGameInfo::clear_has_netgametype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetGameInfo::clear_netgametype() {
  netgametype_ = 1;
  clear_has_netgametype();
}
inline ::NetGameInfo_NetGameType NetGameInfo::netgametype() const {
  return static_cast< ::NetGameInfo_NetGameType >(netgametype_);
}
inline void NetGameInfo::set_netgametype(::NetGameInfo_NetGameType value) {
  GOOGLE_DCHECK(::NetGameInfo_NetGameType_IsValid(value));
  set_has_netgametype();
  netgametype_ = value;
}

// required uint32 maxNumPlayers = 3;
inline bool NetGameInfo::has_maxnumplayers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetGameInfo::set_has_maxnumplayers() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NetGameInfo::clear_has_maxnumplayers() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NetGameInfo::clear_maxnumplayers() {
  maxnumplayers_ = 0u;
  clear_has_maxnumplayers();
}
inline ::google::protobuf::uint32 NetGameInfo::maxnumplayers() const {
  return maxnumplayers_;
}
inline void NetGameInfo::set_maxnumplayers(::google::protobuf::uint32 value) {
  set_has_maxnumplayers();
  maxnumplayers_ = value;
}

// required .NetGameInfo.RaiseIntervalMode raiseIntervalMode = 4;
inline bool NetGameInfo::has_raiseintervalmode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NetGameInfo::set_has_raiseintervalmode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NetGameInfo::clear_has_raiseintervalmode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NetGameInfo::clear_raiseintervalmode() {
  raiseintervalmode_ = 1;
  clear_has_raiseintervalmode();
}
inline ::NetGameInfo_RaiseIntervalMode NetGameInfo::raiseintervalmode() const {
  return static_cast< ::NetGameInfo_RaiseIntervalMode >(raiseintervalmode_);
}
inline void NetGameInfo::set_raiseintervalmode(::NetGameInfo_RaiseIntervalMode value) {
  GOOGLE_DCHECK(::NetGameInfo_RaiseIntervalMode_IsValid(value));
  set_has_raiseintervalmode();
  raiseintervalmode_ = value;
}

// optional uint32 raiseEveryHands = 5;
inline bool NetGameInfo::has_raiseeveryhands() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NetGameInfo::set_has_raiseeveryhands() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NetGameInfo::clear_has_raiseeveryhands() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NetGameInfo::clear_raiseeveryhands() {
  raiseeveryhands_ = 0u;
  clear_has_raiseeveryhands();
}
inline ::google::protobuf::uint32 NetGameInfo::raiseeveryhands() const {
  return raiseeveryhands_;
}
inline void NetGameInfo::set_raiseeveryhands(::google::protobuf::uint32 value) {
  set_has_raiseeveryhands();
  raiseeveryhands_ = value;
}

// optional uint32 raiseEveryMinutes = 6;
inline bool NetGameInfo::has_raiseeveryminutes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NetGameInfo::set_has_raiseeveryminutes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NetGameInfo::clear_has_raiseeveryminutes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NetGameInfo::clear_raiseeveryminutes() {
  raiseeveryminutes_ = 0u;
  clear_has_raiseeveryminutes();
}
inline ::google::protobuf::uint32 NetGameInfo::raiseeveryminutes() const {
  return raiseeveryminutes_;
}
inline void NetGameInfo::set_raiseeveryminutes(::google::protobuf::uint32 value) {
  set_has_raiseeveryminutes();
  raiseeveryminutes_ = value;
}

// required .NetGameInfo.EndRaiseMode endRaiseMode = 7;
inline bool NetGameInfo::has_endraisemode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NetGameInfo::set_has_endraisemode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NetGameInfo::clear_has_endraisemode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NetGameInfo::clear_endraisemode() {
  endraisemode_ = 1;
  clear_has_endraisemode();
}
inline ::NetGameInfo_EndRaiseMode NetGameInfo::endraisemode() const {
  return static_cast< ::NetGameInfo_EndRaiseMode >(endraisemode_);
}
inline void NetGameInfo::set_endraisemode(::NetGameInfo_EndRaiseMode value) {
  GOOGLE_DCHECK(::NetGameInfo_EndRaiseMode_IsValid(value));
  set_has_endraisemode();
  endraisemode_ = value;
}

// optional uint32 endRaiseSmallBlindValue = 8;
inline bool NetGameInfo::has_endraisesmallblindvalue() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NetGameInfo::set_has_endraisesmallblindvalue() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NetGameInfo::clear_has_endraisesmallblindvalue() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NetGameInfo::clear_endraisesmallblindvalue() {
  endraisesmallblindvalue_ = 0u;
  clear_has_endraisesmallblindvalue();
}
inline ::google::protobuf::uint32 NetGameInfo::endraisesmallblindvalue() const {
  return endraisesmallblindvalue_;
}
inline void NetGameInfo::set_endraisesmallblindvalue(::google::protobuf::uint32 value) {
  set_has_endraisesmallblindvalue();
  endraisesmallblindvalue_ = value;
}

// required uint32 proposedGuiSpeed = 9;
inline bool NetGameInfo::has_proposedguispeed() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NetGameInfo::set_has_proposedguispeed() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NetGameInfo::clear_has_proposedguispeed() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NetGameInfo::clear_proposedguispeed() {
  proposedguispeed_ = 0u;
  clear_has_proposedguispeed();
}
inline ::google::protobuf::uint32 NetGameInfo::proposedguispeed() const {
  return proposedguispeed_;
}
inline void NetGameInfo::set_proposedguispeed(::google::protobuf::uint32 value) {
  set_has_proposedguispeed();
  proposedguispeed_ = value;
}

// required uint32 delayBetweenHands = 10;
inline bool NetGameInfo::has_delaybetweenhands() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NetGameInfo::set_has_delaybetweenhands() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NetGameInfo::clear_has_delaybetweenhands() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NetGameInfo::clear_delaybetweenhands() {
  delaybetweenhands_ = 0u;
  clear_has_delaybetweenhands();
}
inline ::google::protobuf::uint32 NetGameInfo::delaybetweenhands() const {
  return delaybetweenhands_;
}
inline void NetGameInfo::set_delaybetweenhands(::google::protobuf::uint32 value) {
  set_has_delaybetweenhands();
  delaybetweenhands_ = value;
}

// required uint32 playerActionTimeout = 11;
inline bool NetGameInfo::has_playeractiontimeout() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NetGameInfo::set_has_playeractiontimeout() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NetGameInfo::clear_has_playeractiontimeout() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NetGameInfo::clear_playeractiontimeout() {
  playeractiontimeout_ = 0u;
  clear_has_playeractiontimeout();
}
inline ::google::protobuf::uint32 NetGameInfo::playeractiontimeout() const {
  return playeractiontimeout_;
}
inline void NetGameInfo::set_playeractiontimeout(::google::protobuf::uint32 value) {
  set_has_playeractiontimeout();
  playeractiontimeout_ = value;
}

// required uint32 firstSmallBlind = 12;
inline bool NetGameInfo::has_firstsmallblind() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NetGameInfo::set_has_firstsmallblind() {
  _has_bits_[0] |= 0x00000800u;
}
inline void NetGameInfo::clear_has_firstsmallblind() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void NetGameInfo::clear_firstsmallblind() {
  firstsmallblind_ = 0u;
  clear_has_firstsmallblind();
}
inline ::google::protobuf::uint32 NetGameInfo::firstsmallblind() const {
  return firstsmallblind_;
}
inline void NetGameInfo::set_firstsmallblind(::google::protobuf::uint32 value) {
  set_has_firstsmallblind();
  firstsmallblind_ = value;
}

// required uint32 startMoney = 13;
inline bool NetGameInfo::has_startmoney() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void NetGameInfo::set_has_startmoney() {
  _has_bits_[0] |= 0x00001000u;
}
inline void NetGameInfo::clear_has_startmoney() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void NetGameInfo::clear_startmoney() {
  startmoney_ = 0u;
  clear_has_startmoney();
}
inline ::google::protobuf::uint32 NetGameInfo::startmoney() const {
  return startmoney_;
}
inline void NetGameInfo::set_startmoney(::google::protobuf::uint32 value) {
  set_has_startmoney();
  startmoney_ = value;
}

// repeated uint32 manualBlinds = 14 [packed = true];
inline int NetGameInfo::manualblinds_size() const {
  return manualblinds_.size();
}
inline void NetGameInfo::clear_manualblinds() {
  manualblinds_.Clear();
}
inline ::google::protobuf::uint32 NetGameInfo::manualblinds(int index) const {
  return manualblinds_.Get(index);
}
inline void NetGameInfo::set_manualblinds(int index, ::google::protobuf::uint32 value) {
  manualblinds_.Set(index, value);
}
inline void NetGameInfo::add_manualblinds(::google::protobuf::uint32 value) {
  manualblinds_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
NetGameInfo::manualblinds() const {
  return manualblinds_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
NetGameInfo::mutable_manualblinds() {
  return &manualblinds_;
}

// -------------------------------------------------------------------

// PlayerResult

// required uint32 playerId = 1;
inline bool PlayerResult::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerResult::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerResult::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerResult::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 PlayerResult::playerid() const {
  return playerid_;
}
inline void PlayerResult::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
}

// required uint32 resultCard1 = 2;
inline bool PlayerResult::has_resultcard1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerResult::set_has_resultcard1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerResult::clear_has_resultcard1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerResult::clear_resultcard1() {
  resultcard1_ = 0u;
  clear_has_resultcard1();
}
inline ::google::protobuf::uint32 PlayerResult::resultcard1() const {
  return resultcard1_;
}
inline void PlayerResult::set_resultcard1(::google::protobuf::uint32 value) {
  set_has_resultcard1();
  resultcard1_ = value;
}

// required uint32 resultCard2 = 3;
inline bool PlayerResult::has_resultcard2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerResult::set_has_resultcard2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerResult::clear_has_resultcard2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerResult::clear_resultcard2() {
  resultcard2_ = 0u;
  clear_has_resultcard2();
}
inline ::google::protobuf::uint32 PlayerResult::resultcard2() const {
  return resultcard2_;
}
inline void PlayerResult::set_resultcard2(::google::protobuf::uint32 value) {
  set_has_resultcard2();
  resultcard2_ = value;
}

// repeated uint32 bestHandPosition = 4 [packed = true];
inline int PlayerResult::besthandposition_size() const {
  return besthandposition_.size();
}
inline void PlayerResult::clear_besthandposition() {
  besthandposition_.Clear();
}
inline ::google::protobuf::uint32 PlayerResult::besthandposition(int index) const {
  return besthandposition_.Get(index);
}
inline void PlayerResult::set_besthandposition(int index, ::google::protobuf::uint32 value) {
  besthandposition_.Set(index, value);
}
inline void PlayerResult::add_besthandposition(::google::protobuf::uint32 value) {
  besthandposition_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
PlayerResult::besthandposition() const {
  return besthandposition_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
PlayerResult::mutable_besthandposition() {
  return &besthandposition_;
}

// required uint32 moneyWon = 5;
inline bool PlayerResult::has_moneywon() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerResult::set_has_moneywon() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerResult::clear_has_moneywon() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerResult::clear_moneywon() {
  moneywon_ = 0u;
  clear_has_moneywon();
}
inline ::google::protobuf::uint32 PlayerResult::moneywon() const {
  return moneywon_;
}
inline void PlayerResult::set_moneywon(::google::protobuf::uint32 value) {
  set_has_moneywon();
  moneywon_ = value;
}

// required uint32 playerMoney = 6;
inline bool PlayerResult::has_playermoney() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerResult::set_has_playermoney() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerResult::clear_has_playermoney() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerResult::clear_playermoney() {
  playermoney_ = 0u;
  clear_has_playermoney();
}
inline ::google::protobuf::uint32 PlayerResult::playermoney() const {
  return playermoney_;
}
inline void PlayerResult::set_playermoney(::google::protobuf::uint32 value) {
  set_has_playermoney();
  playermoney_ = value;
}

// optional uint32 cardsValue = 7;
inline bool PlayerResult::has_cardsvalue() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlayerResult::set_has_cardsvalue() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlayerResult::clear_has_cardsvalue() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlayerResult::clear_cardsvalue() {
  cardsvalue_ = 0u;
  clear_has_cardsvalue();
}
inline ::google::protobuf::uint32 PlayerResult::cardsvalue() const {
  return cardsvalue_;
}
inline void PlayerResult::set_cardsvalue(::google::protobuf::uint32 value) {
  set_has_cardsvalue();
  cardsvalue_ = value;
}

// -------------------------------------------------------------------

// AnnounceMessage_Version

// required uint32 majorVersion = 1;
inline bool AnnounceMessage_Version::has_majorversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnnounceMessage_Version::set_has_majorversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnnounceMessage_Version::clear_has_majorversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnnounceMessage_Version::clear_majorversion() {
  majorversion_ = 0u;
  clear_has_majorversion();
}
inline ::google::protobuf::uint32 AnnounceMessage_Version::majorversion() const {
  return majorversion_;
}
inline void AnnounceMessage_Version::set_majorversion(::google::protobuf::uint32 value) {
  set_has_majorversion();
  majorversion_ = value;
}

// required uint32 minorVersion = 2;
inline bool AnnounceMessage_Version::has_minorversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnnounceMessage_Version::set_has_minorversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnnounceMessage_Version::clear_has_minorversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnnounceMessage_Version::clear_minorversion() {
  minorversion_ = 0u;
  clear_has_minorversion();
}
inline ::google::protobuf::uint32 AnnounceMessage_Version::minorversion() const {
  return minorversion_;
}
inline void AnnounceMessage_Version::set_minorversion(::google::protobuf::uint32 value) {
  set_has_minorversion();
  minorversion_ = value;
}

// -------------------------------------------------------------------

// AnnounceMessage

// required .AnnounceMessage.Version protocolVersion = 1;
inline bool AnnounceMessage::has_protocolversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnnounceMessage::set_has_protocolversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnnounceMessage::clear_has_protocolversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnnounceMessage::clear_protocolversion() {
  if (protocolversion_ != NULL) protocolversion_->::AnnounceMessage_Version::Clear();
  clear_has_protocolversion();
}
inline const ::AnnounceMessage_Version& AnnounceMessage::protocolversion() const {
  return protocolversion_ != NULL ? *protocolversion_ : *default_instance_->protocolversion_;
}
inline ::AnnounceMessage_Version* AnnounceMessage::mutable_protocolversion() {
  set_has_protocolversion();
  if (protocolversion_ == NULL) protocolversion_ = new ::AnnounceMessage_Version;
  return protocolversion_;
}
inline ::AnnounceMessage_Version* AnnounceMessage::release_protocolversion() {
  clear_has_protocolversion();
  ::AnnounceMessage_Version* temp = protocolversion_;
  protocolversion_ = NULL;
  return temp;
}

// required .AnnounceMessage.Version latestGameVersion = 2;
inline bool AnnounceMessage::has_latestgameversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnnounceMessage::set_has_latestgameversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnnounceMessage::clear_has_latestgameversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnnounceMessage::clear_latestgameversion() {
  if (latestgameversion_ != NULL) latestgameversion_->::AnnounceMessage_Version::Clear();
  clear_has_latestgameversion();
}
inline const ::AnnounceMessage_Version& AnnounceMessage::latestgameversion() const {
  return latestgameversion_ != NULL ? *latestgameversion_ : *default_instance_->latestgameversion_;
}
inline ::AnnounceMessage_Version* AnnounceMessage::mutable_latestgameversion() {
  set_has_latestgameversion();
  if (latestgameversion_ == NULL) latestgameversion_ = new ::AnnounceMessage_Version;
  return latestgameversion_;
}
inline ::AnnounceMessage_Version* AnnounceMessage::release_latestgameversion() {
  clear_has_latestgameversion();
  ::AnnounceMessage_Version* temp = latestgameversion_;
  latestgameversion_ = NULL;
  return temp;
}

// required uint32 latestBetaRevision = 3;
inline bool AnnounceMessage::has_latestbetarevision() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnnounceMessage::set_has_latestbetarevision() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnnounceMessage::clear_has_latestbetarevision() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnnounceMessage::clear_latestbetarevision() {
  latestbetarevision_ = 0u;
  clear_has_latestbetarevision();
}
inline ::google::protobuf::uint32 AnnounceMessage::latestbetarevision() const {
  return latestbetarevision_;
}
inline void AnnounceMessage::set_latestbetarevision(::google::protobuf::uint32 value) {
  set_has_latestbetarevision();
  latestbetarevision_ = value;
}

// required .AnnounceMessage.ServerType serverType = 4;
inline bool AnnounceMessage::has_servertype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnnounceMessage::set_has_servertype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnnounceMessage::clear_has_servertype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnnounceMessage::clear_servertype() {
  servertype_ = 0;
  clear_has_servertype();
}
inline ::AnnounceMessage_ServerType AnnounceMessage::servertype() const {
  return static_cast< ::AnnounceMessage_ServerType >(servertype_);
}
inline void AnnounceMessage::set_servertype(::AnnounceMessage_ServerType value) {
  GOOGLE_DCHECK(::AnnounceMessage_ServerType_IsValid(value));
  set_has_servertype();
  servertype_ = value;
}

// required uint32 numPlayersOnServer = 5;
inline bool AnnounceMessage::has_numplayersonserver() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AnnounceMessage::set_has_numplayersonserver() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AnnounceMessage::clear_has_numplayersonserver() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AnnounceMessage::clear_numplayersonserver() {
  numplayersonserver_ = 0u;
  clear_has_numplayersonserver();
}
inline ::google::protobuf::uint32 AnnounceMessage::numplayersonserver() const {
  return numplayersonserver_;
}
inline void AnnounceMessage::set_numplayersonserver(::google::protobuf::uint32 value) {
  set_has_numplayersonserver();
  numplayersonserver_ = value;
}

// -------------------------------------------------------------------

// InitMessage

// required .AnnounceMessage.Version requestedVersion = 1;
inline bool InitMessage::has_requestedversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitMessage::set_has_requestedversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitMessage::clear_has_requestedversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitMessage::clear_requestedversion() {
  if (requestedversion_ != NULL) requestedversion_->::AnnounceMessage_Version::Clear();
  clear_has_requestedversion();
}
inline const ::AnnounceMessage_Version& InitMessage::requestedversion() const {
  return requestedversion_ != NULL ? *requestedversion_ : *default_instance_->requestedversion_;
}
inline ::AnnounceMessage_Version* InitMessage::mutable_requestedversion() {
  set_has_requestedversion();
  if (requestedversion_ == NULL) requestedversion_ = new ::AnnounceMessage_Version;
  return requestedversion_;
}
inline ::AnnounceMessage_Version* InitMessage::release_requestedversion() {
  clear_has_requestedversion();
  ::AnnounceMessage_Version* temp = requestedversion_;
  requestedversion_ = NULL;
  return temp;
}

// required uint32 buildId = 2;
inline bool InitMessage::has_buildid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitMessage::set_has_buildid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitMessage::clear_has_buildid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitMessage::clear_buildid() {
  buildid_ = 0u;
  clear_has_buildid();
}
inline ::google::protobuf::uint32 InitMessage::buildid() const {
  return buildid_;
}
inline void InitMessage::set_buildid(::google::protobuf::uint32 value) {
  set_has_buildid();
  buildid_ = value;
}

// optional bytes myLastSessionId = 3;
inline bool InitMessage::has_mylastsessionid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InitMessage::set_has_mylastsessionid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InitMessage::clear_has_mylastsessionid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InitMessage::clear_mylastsessionid() {
  if (mylastsessionid_ != &::google::protobuf::internal::kEmptyString) {
    mylastsessionid_->clear();
  }
  clear_has_mylastsessionid();
}
inline const ::std::string& InitMessage::mylastsessionid() const {
  return *mylastsessionid_;
}
inline void InitMessage::set_mylastsessionid(const ::std::string& value) {
  set_has_mylastsessionid();
  if (mylastsessionid_ == &::google::protobuf::internal::kEmptyString) {
    mylastsessionid_ = new ::std::string;
  }
  mylastsessionid_->assign(value);
}
inline void InitMessage::set_mylastsessionid(const char* value) {
  set_has_mylastsessionid();
  if (mylastsessionid_ == &::google::protobuf::internal::kEmptyString) {
    mylastsessionid_ = new ::std::string;
  }
  mylastsessionid_->assign(value);
}
inline void InitMessage::set_mylastsessionid(const void* value, size_t size) {
  set_has_mylastsessionid();
  if (mylastsessionid_ == &::google::protobuf::internal::kEmptyString) {
    mylastsessionid_ = new ::std::string;
  }
  mylastsessionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InitMessage::mutable_mylastsessionid() {
  set_has_mylastsessionid();
  if (mylastsessionid_ == &::google::protobuf::internal::kEmptyString) {
    mylastsessionid_ = new ::std::string;
  }
  return mylastsessionid_;
}
inline ::std::string* InitMessage::release_mylastsessionid() {
  clear_has_mylastsessionid();
  if (mylastsessionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mylastsessionid_;
    mylastsessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string authServerPassword = 4;
inline bool InitMessage::has_authserverpassword() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InitMessage::set_has_authserverpassword() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InitMessage::clear_has_authserverpassword() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InitMessage::clear_authserverpassword() {
  if (authserverpassword_ != &::google::protobuf::internal::kEmptyString) {
    authserverpassword_->clear();
  }
  clear_has_authserverpassword();
}
inline const ::std::string& InitMessage::authserverpassword() const {
  return *authserverpassword_;
}
inline void InitMessage::set_authserverpassword(const ::std::string& value) {
  set_has_authserverpassword();
  if (authserverpassword_ == &::google::protobuf::internal::kEmptyString) {
    authserverpassword_ = new ::std::string;
  }
  authserverpassword_->assign(value);
}
inline void InitMessage::set_authserverpassword(const char* value) {
  set_has_authserverpassword();
  if (authserverpassword_ == &::google::protobuf::internal::kEmptyString) {
    authserverpassword_ = new ::std::string;
  }
  authserverpassword_->assign(value);
}
inline void InitMessage::set_authserverpassword(const char* value, size_t size) {
  set_has_authserverpassword();
  if (authserverpassword_ == &::google::protobuf::internal::kEmptyString) {
    authserverpassword_ = new ::std::string;
  }
  authserverpassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InitMessage::mutable_authserverpassword() {
  set_has_authserverpassword();
  if (authserverpassword_ == &::google::protobuf::internal::kEmptyString) {
    authserverpassword_ = new ::std::string;
  }
  return authserverpassword_;
}
inline ::std::string* InitMessage::release_authserverpassword() {
  clear_has_authserverpassword();
  if (authserverpassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = authserverpassword_;
    authserverpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .InitMessage.LoginType login = 5;
inline bool InitMessage::has_login() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InitMessage::set_has_login() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InitMessage::clear_has_login() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InitMessage::clear_login() {
  login_ = 0;
  clear_has_login();
}
inline ::InitMessage_LoginType InitMessage::login() const {
  return static_cast< ::InitMessage_LoginType >(login_);
}
inline void InitMessage::set_login(::InitMessage_LoginType value) {
  GOOGLE_DCHECK(::InitMessage_LoginType_IsValid(value));
  set_has_login();
  login_ = value;
}

// optional string nickName = 6;
inline bool InitMessage::has_nickname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InitMessage::set_has_nickname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InitMessage::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InitMessage::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& InitMessage::nickname() const {
  return *nickname_;
}
inline void InitMessage::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void InitMessage::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void InitMessage::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InitMessage::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* InitMessage::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes clientUserData = 7;
inline bool InitMessage::has_clientuserdata() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InitMessage::set_has_clientuserdata() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InitMessage::clear_has_clientuserdata() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InitMessage::clear_clientuserdata() {
  if (clientuserdata_ != &::google::protobuf::internal::kEmptyString) {
    clientuserdata_->clear();
  }
  clear_has_clientuserdata();
}
inline const ::std::string& InitMessage::clientuserdata() const {
  return *clientuserdata_;
}
inline void InitMessage::set_clientuserdata(const ::std::string& value) {
  set_has_clientuserdata();
  if (clientuserdata_ == &::google::protobuf::internal::kEmptyString) {
    clientuserdata_ = new ::std::string;
  }
  clientuserdata_->assign(value);
}
inline void InitMessage::set_clientuserdata(const char* value) {
  set_has_clientuserdata();
  if (clientuserdata_ == &::google::protobuf::internal::kEmptyString) {
    clientuserdata_ = new ::std::string;
  }
  clientuserdata_->assign(value);
}
inline void InitMessage::set_clientuserdata(const void* value, size_t size) {
  set_has_clientuserdata();
  if (clientuserdata_ == &::google::protobuf::internal::kEmptyString) {
    clientuserdata_ = new ::std::string;
  }
  clientuserdata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InitMessage::mutable_clientuserdata() {
  set_has_clientuserdata();
  if (clientuserdata_ == &::google::protobuf::internal::kEmptyString) {
    clientuserdata_ = new ::std::string;
  }
  return clientuserdata_;
}
inline ::std::string* InitMessage::release_clientuserdata() {
  clear_has_clientuserdata();
  if (clientuserdata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clientuserdata_;
    clientuserdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes avatarHash = 8;
inline bool InitMessage::has_avatarhash() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InitMessage::set_has_avatarhash() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InitMessage::clear_has_avatarhash() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InitMessage::clear_avatarhash() {
  if (avatarhash_ != &::google::protobuf::internal::kEmptyString) {
    avatarhash_->clear();
  }
  clear_has_avatarhash();
}
inline const ::std::string& InitMessage::avatarhash() const {
  return *avatarhash_;
}
inline void InitMessage::set_avatarhash(const ::std::string& value) {
  set_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::kEmptyString) {
    avatarhash_ = new ::std::string;
  }
  avatarhash_->assign(value);
}
inline void InitMessage::set_avatarhash(const char* value) {
  set_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::kEmptyString) {
    avatarhash_ = new ::std::string;
  }
  avatarhash_->assign(value);
}
inline void InitMessage::set_avatarhash(const void* value, size_t size) {
  set_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::kEmptyString) {
    avatarhash_ = new ::std::string;
  }
  avatarhash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InitMessage::mutable_avatarhash() {
  set_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::kEmptyString) {
    avatarhash_ = new ::std::string;
  }
  return avatarhash_;
}
inline ::std::string* InitMessage::release_avatarhash() {
  clear_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatarhash_;
    avatarhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AuthServerChallengeMessage

// required bytes serverChallenge = 1;
inline bool AuthServerChallengeMessage::has_serverchallenge() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthServerChallengeMessage::set_has_serverchallenge() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthServerChallengeMessage::clear_has_serverchallenge() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthServerChallengeMessage::clear_serverchallenge() {
  if (serverchallenge_ != &::google::protobuf::internal::kEmptyString) {
    serverchallenge_->clear();
  }
  clear_has_serverchallenge();
}
inline const ::std::string& AuthServerChallengeMessage::serverchallenge() const {
  return *serverchallenge_;
}
inline void AuthServerChallengeMessage::set_serverchallenge(const ::std::string& value) {
  set_has_serverchallenge();
  if (serverchallenge_ == &::google::protobuf::internal::kEmptyString) {
    serverchallenge_ = new ::std::string;
  }
  serverchallenge_->assign(value);
}
inline void AuthServerChallengeMessage::set_serverchallenge(const char* value) {
  set_has_serverchallenge();
  if (serverchallenge_ == &::google::protobuf::internal::kEmptyString) {
    serverchallenge_ = new ::std::string;
  }
  serverchallenge_->assign(value);
}
inline void AuthServerChallengeMessage::set_serverchallenge(const void* value, size_t size) {
  set_has_serverchallenge();
  if (serverchallenge_ == &::google::protobuf::internal::kEmptyString) {
    serverchallenge_ = new ::std::string;
  }
  serverchallenge_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthServerChallengeMessage::mutable_serverchallenge() {
  set_has_serverchallenge();
  if (serverchallenge_ == &::google::protobuf::internal::kEmptyString) {
    serverchallenge_ = new ::std::string;
  }
  return serverchallenge_;
}
inline ::std::string* AuthServerChallengeMessage::release_serverchallenge() {
  clear_has_serverchallenge();
  if (serverchallenge_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serverchallenge_;
    serverchallenge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AuthClientResponseMessage

// required bytes clientResponse = 1;
inline bool AuthClientResponseMessage::has_clientresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthClientResponseMessage::set_has_clientresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthClientResponseMessage::clear_has_clientresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthClientResponseMessage::clear_clientresponse() {
  if (clientresponse_ != &::google::protobuf::internal::kEmptyString) {
    clientresponse_->clear();
  }
  clear_has_clientresponse();
}
inline const ::std::string& AuthClientResponseMessage::clientresponse() const {
  return *clientresponse_;
}
inline void AuthClientResponseMessage::set_clientresponse(const ::std::string& value) {
  set_has_clientresponse();
  if (clientresponse_ == &::google::protobuf::internal::kEmptyString) {
    clientresponse_ = new ::std::string;
  }
  clientresponse_->assign(value);
}
inline void AuthClientResponseMessage::set_clientresponse(const char* value) {
  set_has_clientresponse();
  if (clientresponse_ == &::google::protobuf::internal::kEmptyString) {
    clientresponse_ = new ::std::string;
  }
  clientresponse_->assign(value);
}
inline void AuthClientResponseMessage::set_clientresponse(const void* value, size_t size) {
  set_has_clientresponse();
  if (clientresponse_ == &::google::protobuf::internal::kEmptyString) {
    clientresponse_ = new ::std::string;
  }
  clientresponse_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthClientResponseMessage::mutable_clientresponse() {
  set_has_clientresponse();
  if (clientresponse_ == &::google::protobuf::internal::kEmptyString) {
    clientresponse_ = new ::std::string;
  }
  return clientresponse_;
}
inline ::std::string* AuthClientResponseMessage::release_clientresponse() {
  clear_has_clientresponse();
  if (clientresponse_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clientresponse_;
    clientresponse_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AuthServerVerificationMessage

// required bytes serverVerification = 1;
inline bool AuthServerVerificationMessage::has_serververification() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthServerVerificationMessage::set_has_serververification() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthServerVerificationMessage::clear_has_serververification() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthServerVerificationMessage::clear_serververification() {
  if (serververification_ != &::google::protobuf::internal::kEmptyString) {
    serververification_->clear();
  }
  clear_has_serververification();
}
inline const ::std::string& AuthServerVerificationMessage::serververification() const {
  return *serververification_;
}
inline void AuthServerVerificationMessage::set_serververification(const ::std::string& value) {
  set_has_serververification();
  if (serververification_ == &::google::protobuf::internal::kEmptyString) {
    serververification_ = new ::std::string;
  }
  serververification_->assign(value);
}
inline void AuthServerVerificationMessage::set_serververification(const char* value) {
  set_has_serververification();
  if (serververification_ == &::google::protobuf::internal::kEmptyString) {
    serververification_ = new ::std::string;
  }
  serververification_->assign(value);
}
inline void AuthServerVerificationMessage::set_serververification(const void* value, size_t size) {
  set_has_serververification();
  if (serververification_ == &::google::protobuf::internal::kEmptyString) {
    serververification_ = new ::std::string;
  }
  serververification_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthServerVerificationMessage::mutable_serververification() {
  set_has_serververification();
  if (serververification_ == &::google::protobuf::internal::kEmptyString) {
    serververification_ = new ::std::string;
  }
  return serververification_;
}
inline ::std::string* AuthServerVerificationMessage::release_serververification() {
  clear_has_serververification();
  if (serververification_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serververification_;
    serververification_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// InitAckMessage

// required bytes yourSessionId = 1;
inline bool InitAckMessage::has_yoursessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitAckMessage::set_has_yoursessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitAckMessage::clear_has_yoursessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitAckMessage::clear_yoursessionid() {
  if (yoursessionid_ != &::google::protobuf::internal::kEmptyString) {
    yoursessionid_->clear();
  }
  clear_has_yoursessionid();
}
inline const ::std::string& InitAckMessage::yoursessionid() const {
  return *yoursessionid_;
}
inline void InitAckMessage::set_yoursessionid(const ::std::string& value) {
  set_has_yoursessionid();
  if (yoursessionid_ == &::google::protobuf::internal::kEmptyString) {
    yoursessionid_ = new ::std::string;
  }
  yoursessionid_->assign(value);
}
inline void InitAckMessage::set_yoursessionid(const char* value) {
  set_has_yoursessionid();
  if (yoursessionid_ == &::google::protobuf::internal::kEmptyString) {
    yoursessionid_ = new ::std::string;
  }
  yoursessionid_->assign(value);
}
inline void InitAckMessage::set_yoursessionid(const void* value, size_t size) {
  set_has_yoursessionid();
  if (yoursessionid_ == &::google::protobuf::internal::kEmptyString) {
    yoursessionid_ = new ::std::string;
  }
  yoursessionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InitAckMessage::mutable_yoursessionid() {
  set_has_yoursessionid();
  if (yoursessionid_ == &::google::protobuf::internal::kEmptyString) {
    yoursessionid_ = new ::std::string;
  }
  return yoursessionid_;
}
inline ::std::string* InitAckMessage::release_yoursessionid() {
  clear_has_yoursessionid();
  if (yoursessionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = yoursessionid_;
    yoursessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 yourPlayerId = 2;
inline bool InitAckMessage::has_yourplayerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitAckMessage::set_has_yourplayerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitAckMessage::clear_has_yourplayerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitAckMessage::clear_yourplayerid() {
  yourplayerid_ = 0u;
  clear_has_yourplayerid();
}
inline ::google::protobuf::uint32 InitAckMessage::yourplayerid() const {
  return yourplayerid_;
}
inline void InitAckMessage::set_yourplayerid(::google::protobuf::uint32 value) {
  set_has_yourplayerid();
  yourplayerid_ = value;
}

// optional bytes yourAvatarHash = 3;
inline bool InitAckMessage::has_youravatarhash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InitAckMessage::set_has_youravatarhash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InitAckMessage::clear_has_youravatarhash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InitAckMessage::clear_youravatarhash() {
  if (youravatarhash_ != &::google::protobuf::internal::kEmptyString) {
    youravatarhash_->clear();
  }
  clear_has_youravatarhash();
}
inline const ::std::string& InitAckMessage::youravatarhash() const {
  return *youravatarhash_;
}
inline void InitAckMessage::set_youravatarhash(const ::std::string& value) {
  set_has_youravatarhash();
  if (youravatarhash_ == &::google::protobuf::internal::kEmptyString) {
    youravatarhash_ = new ::std::string;
  }
  youravatarhash_->assign(value);
}
inline void InitAckMessage::set_youravatarhash(const char* value) {
  set_has_youravatarhash();
  if (youravatarhash_ == &::google::protobuf::internal::kEmptyString) {
    youravatarhash_ = new ::std::string;
  }
  youravatarhash_->assign(value);
}
inline void InitAckMessage::set_youravatarhash(const void* value, size_t size) {
  set_has_youravatarhash();
  if (youravatarhash_ == &::google::protobuf::internal::kEmptyString) {
    youravatarhash_ = new ::std::string;
  }
  youravatarhash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InitAckMessage::mutable_youravatarhash() {
  set_has_youravatarhash();
  if (youravatarhash_ == &::google::protobuf::internal::kEmptyString) {
    youravatarhash_ = new ::std::string;
  }
  return youravatarhash_;
}
inline ::std::string* InitAckMessage::release_youravatarhash() {
  clear_has_youravatarhash();
  if (youravatarhash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = youravatarhash_;
    youravatarhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 rejoinGameId = 4;
inline bool InitAckMessage::has_rejoingameid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InitAckMessage::set_has_rejoingameid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InitAckMessage::clear_has_rejoingameid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InitAckMessage::clear_rejoingameid() {
  rejoingameid_ = 0u;
  clear_has_rejoingameid();
}
inline ::google::protobuf::uint32 InitAckMessage::rejoingameid() const {
  return rejoingameid_;
}
inline void InitAckMessage::set_rejoingameid(::google::protobuf::uint32 value) {
  set_has_rejoingameid();
  rejoingameid_ = value;
}

// -------------------------------------------------------------------

// AvatarRequestMessage

// required uint32 requestId = 1;
inline bool AvatarRequestMessage::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AvatarRequestMessage::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AvatarRequestMessage::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AvatarRequestMessage::clear_requestid() {
  requestid_ = 0u;
  clear_has_requestid();
}
inline ::google::protobuf::uint32 AvatarRequestMessage::requestid() const {
  return requestid_;
}
inline void AvatarRequestMessage::set_requestid(::google::protobuf::uint32 value) {
  set_has_requestid();
  requestid_ = value;
}

// required bytes avatarHash = 2;
inline bool AvatarRequestMessage::has_avatarhash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AvatarRequestMessage::set_has_avatarhash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AvatarRequestMessage::clear_has_avatarhash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AvatarRequestMessage::clear_avatarhash() {
  if (avatarhash_ != &::google::protobuf::internal::kEmptyString) {
    avatarhash_->clear();
  }
  clear_has_avatarhash();
}
inline const ::std::string& AvatarRequestMessage::avatarhash() const {
  return *avatarhash_;
}
inline void AvatarRequestMessage::set_avatarhash(const ::std::string& value) {
  set_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::kEmptyString) {
    avatarhash_ = new ::std::string;
  }
  avatarhash_->assign(value);
}
inline void AvatarRequestMessage::set_avatarhash(const char* value) {
  set_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::kEmptyString) {
    avatarhash_ = new ::std::string;
  }
  avatarhash_->assign(value);
}
inline void AvatarRequestMessage::set_avatarhash(const void* value, size_t size) {
  set_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::kEmptyString) {
    avatarhash_ = new ::std::string;
  }
  avatarhash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AvatarRequestMessage::mutable_avatarhash() {
  set_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::kEmptyString) {
    avatarhash_ = new ::std::string;
  }
  return avatarhash_;
}
inline ::std::string* AvatarRequestMessage::release_avatarhash() {
  clear_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatarhash_;
    avatarhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AvatarHeaderMessage

// required uint32 requestId = 1;
inline bool AvatarHeaderMessage::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AvatarHeaderMessage::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AvatarHeaderMessage::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AvatarHeaderMessage::clear_requestid() {
  requestid_ = 0u;
  clear_has_requestid();
}
inline ::google::protobuf::uint32 AvatarHeaderMessage::requestid() const {
  return requestid_;
}
inline void AvatarHeaderMessage::set_requestid(::google::protobuf::uint32 value) {
  set_has_requestid();
  requestid_ = value;
}

// required .NetAvatarType avatarType = 2;
inline bool AvatarHeaderMessage::has_avatartype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AvatarHeaderMessage::set_has_avatartype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AvatarHeaderMessage::clear_has_avatartype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AvatarHeaderMessage::clear_avatartype() {
  avatartype_ = 1;
  clear_has_avatartype();
}
inline NetAvatarType AvatarHeaderMessage::avatartype() const {
  return static_cast< NetAvatarType >(avatartype_);
}
inline void AvatarHeaderMessage::set_avatartype(NetAvatarType value) {
  GOOGLE_DCHECK(NetAvatarType_IsValid(value));
  set_has_avatartype();
  avatartype_ = value;
}

// required uint32 avatarSize = 3;
inline bool AvatarHeaderMessage::has_avatarsize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AvatarHeaderMessage::set_has_avatarsize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AvatarHeaderMessage::clear_has_avatarsize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AvatarHeaderMessage::clear_avatarsize() {
  avatarsize_ = 0u;
  clear_has_avatarsize();
}
inline ::google::protobuf::uint32 AvatarHeaderMessage::avatarsize() const {
  return avatarsize_;
}
inline void AvatarHeaderMessage::set_avatarsize(::google::protobuf::uint32 value) {
  set_has_avatarsize();
  avatarsize_ = value;
}

// -------------------------------------------------------------------

// AvatarDataMessage

// required uint32 requestId = 1;
inline bool AvatarDataMessage::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AvatarDataMessage::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AvatarDataMessage::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AvatarDataMessage::clear_requestid() {
  requestid_ = 0u;
  clear_has_requestid();
}
inline ::google::protobuf::uint32 AvatarDataMessage::requestid() const {
  return requestid_;
}
inline void AvatarDataMessage::set_requestid(::google::protobuf::uint32 value) {
  set_has_requestid();
  requestid_ = value;
}

// required bytes avatarBlock = 2;
inline bool AvatarDataMessage::has_avatarblock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AvatarDataMessage::set_has_avatarblock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AvatarDataMessage::clear_has_avatarblock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AvatarDataMessage::clear_avatarblock() {
  if (avatarblock_ != &::google::protobuf::internal::kEmptyString) {
    avatarblock_->clear();
  }
  clear_has_avatarblock();
}
inline const ::std::string& AvatarDataMessage::avatarblock() const {
  return *avatarblock_;
}
inline void AvatarDataMessage::set_avatarblock(const ::std::string& value) {
  set_has_avatarblock();
  if (avatarblock_ == &::google::protobuf::internal::kEmptyString) {
    avatarblock_ = new ::std::string;
  }
  avatarblock_->assign(value);
}
inline void AvatarDataMessage::set_avatarblock(const char* value) {
  set_has_avatarblock();
  if (avatarblock_ == &::google::protobuf::internal::kEmptyString) {
    avatarblock_ = new ::std::string;
  }
  avatarblock_->assign(value);
}
inline void AvatarDataMessage::set_avatarblock(const void* value, size_t size) {
  set_has_avatarblock();
  if (avatarblock_ == &::google::protobuf::internal::kEmptyString) {
    avatarblock_ = new ::std::string;
  }
  avatarblock_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AvatarDataMessage::mutable_avatarblock() {
  set_has_avatarblock();
  if (avatarblock_ == &::google::protobuf::internal::kEmptyString) {
    avatarblock_ = new ::std::string;
  }
  return avatarblock_;
}
inline ::std::string* AvatarDataMessage::release_avatarblock() {
  clear_has_avatarblock();
  if (avatarblock_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatarblock_;
    avatarblock_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AvatarEndMessage

// required uint32 requestId = 1;
inline bool AvatarEndMessage::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AvatarEndMessage::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AvatarEndMessage::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AvatarEndMessage::clear_requestid() {
  requestid_ = 0u;
  clear_has_requestid();
}
inline ::google::protobuf::uint32 AvatarEndMessage::requestid() const {
  return requestid_;
}
inline void AvatarEndMessage::set_requestid(::google::protobuf::uint32 value) {
  set_has_requestid();
  requestid_ = value;
}

// -------------------------------------------------------------------

// UnknownAvatarMessage

// required uint32 requestId = 1;
inline bool UnknownAvatarMessage::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnknownAvatarMessage::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnknownAvatarMessage::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnknownAvatarMessage::clear_requestid() {
  requestid_ = 0u;
  clear_has_requestid();
}
inline ::google::protobuf::uint32 UnknownAvatarMessage::requestid() const {
  return requestid_;
}
inline void UnknownAvatarMessage::set_requestid(::google::protobuf::uint32 value) {
  set_has_requestid();
  requestid_ = value;
}

// -------------------------------------------------------------------

// PlayerListMessage

// required uint32 playerId = 1;
inline bool PlayerListMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerListMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerListMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerListMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 PlayerListMessage::playerid() const {
  return playerid_;
}
inline void PlayerListMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
}

// required .PlayerListMessage.PlayerListNotification playerListNotification = 2;
inline bool PlayerListMessage::has_playerlistnotification() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerListMessage::set_has_playerlistnotification() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerListMessage::clear_has_playerlistnotification() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerListMessage::clear_playerlistnotification() {
  playerlistnotification_ = 0;
  clear_has_playerlistnotification();
}
inline ::PlayerListMessage_PlayerListNotification PlayerListMessage::playerlistnotification() const {
  return static_cast< ::PlayerListMessage_PlayerListNotification >(playerlistnotification_);
}
inline void PlayerListMessage::set_playerlistnotification(::PlayerListMessage_PlayerListNotification value) {
  GOOGLE_DCHECK(::PlayerListMessage_PlayerListNotification_IsValid(value));
  set_has_playerlistnotification();
  playerlistnotification_ = value;
}

// -------------------------------------------------------------------

// GameListNewMessage

// required uint32 gameId = 1;
inline bool GameListNewMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameListNewMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameListNewMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameListNewMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameListNewMessage::gameid() const {
  return gameid_;
}
inline void GameListNewMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required .NetGameMode gameMode = 2;
inline bool GameListNewMessage::has_gamemode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameListNewMessage::set_has_gamemode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameListNewMessage::clear_has_gamemode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameListNewMessage::clear_gamemode() {
  gamemode_ = 1;
  clear_has_gamemode();
}
inline NetGameMode GameListNewMessage::gamemode() const {
  return static_cast< NetGameMode >(gamemode_);
}
inline void GameListNewMessage::set_gamemode(NetGameMode value) {
  GOOGLE_DCHECK(NetGameMode_IsValid(value));
  set_has_gamemode();
  gamemode_ = value;
}

// required bool isPrivate = 3;
inline bool GameListNewMessage::has_isprivate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameListNewMessage::set_has_isprivate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameListNewMessage::clear_has_isprivate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameListNewMessage::clear_isprivate() {
  isprivate_ = false;
  clear_has_isprivate();
}
inline bool GameListNewMessage::isprivate() const {
  return isprivate_;
}
inline void GameListNewMessage::set_isprivate(bool value) {
  set_has_isprivate();
  isprivate_ = value;
}

// repeated uint32 playerIds = 4 [packed = true];
inline int GameListNewMessage::playerids_size() const {
  return playerids_.size();
}
inline void GameListNewMessage::clear_playerids() {
  playerids_.Clear();
}
inline ::google::protobuf::uint32 GameListNewMessage::playerids(int index) const {
  return playerids_.Get(index);
}
inline void GameListNewMessage::set_playerids(int index, ::google::protobuf::uint32 value) {
  playerids_.Set(index, value);
}
inline void GameListNewMessage::add_playerids(::google::protobuf::uint32 value) {
  playerids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GameListNewMessage::playerids() const {
  return playerids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GameListNewMessage::mutable_playerids() {
  return &playerids_;
}

// required uint32 adminPlayerId = 5;
inline bool GameListNewMessage::has_adminplayerid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameListNewMessage::set_has_adminplayerid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameListNewMessage::clear_has_adminplayerid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameListNewMessage::clear_adminplayerid() {
  adminplayerid_ = 0u;
  clear_has_adminplayerid();
}
inline ::google::protobuf::uint32 GameListNewMessage::adminplayerid() const {
  return adminplayerid_;
}
inline void GameListNewMessage::set_adminplayerid(::google::protobuf::uint32 value) {
  set_has_adminplayerid();
  adminplayerid_ = value;
}

// required .NetGameInfo gameInfo = 6;
inline bool GameListNewMessage::has_gameinfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameListNewMessage::set_has_gameinfo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameListNewMessage::clear_has_gameinfo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameListNewMessage::clear_gameinfo() {
  if (gameinfo_ != NULL) gameinfo_->::NetGameInfo::Clear();
  clear_has_gameinfo();
}
inline const ::NetGameInfo& GameListNewMessage::gameinfo() const {
  return gameinfo_ != NULL ? *gameinfo_ : *default_instance_->gameinfo_;
}
inline ::NetGameInfo* GameListNewMessage::mutable_gameinfo() {
  set_has_gameinfo();
  if (gameinfo_ == NULL) gameinfo_ = new ::NetGameInfo;
  return gameinfo_;
}
inline ::NetGameInfo* GameListNewMessage::release_gameinfo() {
  clear_has_gameinfo();
  ::NetGameInfo* temp = gameinfo_;
  gameinfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GameListUpdateMessage

// required uint32 gameId = 1;
inline bool GameListUpdateMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameListUpdateMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameListUpdateMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameListUpdateMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameListUpdateMessage::gameid() const {
  return gameid_;
}
inline void GameListUpdateMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required .NetGameMode gameMode = 2;
inline bool GameListUpdateMessage::has_gamemode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameListUpdateMessage::set_has_gamemode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameListUpdateMessage::clear_has_gamemode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameListUpdateMessage::clear_gamemode() {
  gamemode_ = 1;
  clear_has_gamemode();
}
inline NetGameMode GameListUpdateMessage::gamemode() const {
  return static_cast< NetGameMode >(gamemode_);
}
inline void GameListUpdateMessage::set_gamemode(NetGameMode value) {
  GOOGLE_DCHECK(NetGameMode_IsValid(value));
  set_has_gamemode();
  gamemode_ = value;
}

// -------------------------------------------------------------------

// GameListPlayerJoinedMessage

// required uint32 gameId = 1;
inline bool GameListPlayerJoinedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameListPlayerJoinedMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameListPlayerJoinedMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameListPlayerJoinedMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameListPlayerJoinedMessage::gameid() const {
  return gameid_;
}
inline void GameListPlayerJoinedMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 playerId = 2;
inline bool GameListPlayerJoinedMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameListPlayerJoinedMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameListPlayerJoinedMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameListPlayerJoinedMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 GameListPlayerJoinedMessage::playerid() const {
  return playerid_;
}
inline void GameListPlayerJoinedMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
}

// -------------------------------------------------------------------

// GameListPlayerLeftMessage

// required uint32 gameId = 1;
inline bool GameListPlayerLeftMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameListPlayerLeftMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameListPlayerLeftMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameListPlayerLeftMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameListPlayerLeftMessage::gameid() const {
  return gameid_;
}
inline void GameListPlayerLeftMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 playerId = 2;
inline bool GameListPlayerLeftMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameListPlayerLeftMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameListPlayerLeftMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameListPlayerLeftMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 GameListPlayerLeftMessage::playerid() const {
  return playerid_;
}
inline void GameListPlayerLeftMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
}

// -------------------------------------------------------------------

// GameListAdminChangedMessage

// required uint32 gameId = 1;
inline bool GameListAdminChangedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameListAdminChangedMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameListAdminChangedMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameListAdminChangedMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameListAdminChangedMessage::gameid() const {
  return gameid_;
}
inline void GameListAdminChangedMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 newAdminPlayerId = 2;
inline bool GameListAdminChangedMessage::has_newadminplayerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameListAdminChangedMessage::set_has_newadminplayerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameListAdminChangedMessage::clear_has_newadminplayerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameListAdminChangedMessage::clear_newadminplayerid() {
  newadminplayerid_ = 0u;
  clear_has_newadminplayerid();
}
inline ::google::protobuf::uint32 GameListAdminChangedMessage::newadminplayerid() const {
  return newadminplayerid_;
}
inline void GameListAdminChangedMessage::set_newadminplayerid(::google::protobuf::uint32 value) {
  set_has_newadminplayerid();
  newadminplayerid_ = value;
}

// -------------------------------------------------------------------

// PlayerInfoRequestMessage

// repeated uint32 playerId = 1 [packed = true];
inline int PlayerInfoRequestMessage::playerid_size() const {
  return playerid_.size();
}
inline void PlayerInfoRequestMessage::clear_playerid() {
  playerid_.Clear();
}
inline ::google::protobuf::uint32 PlayerInfoRequestMessage::playerid(int index) const {
  return playerid_.Get(index);
}
inline void PlayerInfoRequestMessage::set_playerid(int index, ::google::protobuf::uint32 value) {
  playerid_.Set(index, value);
}
inline void PlayerInfoRequestMessage::add_playerid(::google::protobuf::uint32 value) {
  playerid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
PlayerInfoRequestMessage::playerid() const {
  return playerid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
PlayerInfoRequestMessage::mutable_playerid() {
  return &playerid_;
}

// -------------------------------------------------------------------

// PlayerInfoReplyMessage_PlayerInfoData_AvatarData

// required .NetAvatarType avatarType = 1;
inline bool PlayerInfoReplyMessage_PlayerInfoData_AvatarData::has_avatartype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::set_has_avatartype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::clear_has_avatartype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::clear_avatartype() {
  avatartype_ = 1;
  clear_has_avatartype();
}
inline NetAvatarType PlayerInfoReplyMessage_PlayerInfoData_AvatarData::avatartype() const {
  return static_cast< NetAvatarType >(avatartype_);
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::set_avatartype(NetAvatarType value) {
  GOOGLE_DCHECK(NetAvatarType_IsValid(value));
  set_has_avatartype();
  avatartype_ = value;
}

// required bytes avatarHash = 2;
inline bool PlayerInfoReplyMessage_PlayerInfoData_AvatarData::has_avatarhash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::set_has_avatarhash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::clear_has_avatarhash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::clear_avatarhash() {
  if (avatarhash_ != &::google::protobuf::internal::kEmptyString) {
    avatarhash_->clear();
  }
  clear_has_avatarhash();
}
inline const ::std::string& PlayerInfoReplyMessage_PlayerInfoData_AvatarData::avatarhash() const {
  return *avatarhash_;
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::set_avatarhash(const ::std::string& value) {
  set_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::kEmptyString) {
    avatarhash_ = new ::std::string;
  }
  avatarhash_->assign(value);
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::set_avatarhash(const char* value) {
  set_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::kEmptyString) {
    avatarhash_ = new ::std::string;
  }
  avatarhash_->assign(value);
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::set_avatarhash(const void* value, size_t size) {
  set_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::kEmptyString) {
    avatarhash_ = new ::std::string;
  }
  avatarhash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerInfoReplyMessage_PlayerInfoData_AvatarData::mutable_avatarhash() {
  set_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::kEmptyString) {
    avatarhash_ = new ::std::string;
  }
  return avatarhash_;
}
inline ::std::string* PlayerInfoReplyMessage_PlayerInfoData_AvatarData::release_avatarhash() {
  clear_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatarhash_;
    avatarhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PlayerInfoReplyMessage_PlayerInfoData

// required string playerName = 1;
inline bool PlayerInfoReplyMessage_PlayerInfoData::has_playername() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_has_playername() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_has_playername() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_playername() {
  if (playername_ != &::google::protobuf::internal::kEmptyString) {
    playername_->clear();
  }
  clear_has_playername();
}
inline const ::std::string& PlayerInfoReplyMessage_PlayerInfoData::playername() const {
  return *playername_;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_playername(const ::std::string& value) {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  playername_->assign(value);
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_playername(const char* value) {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  playername_->assign(value);
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_playername(const char* value, size_t size) {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  playername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerInfoReplyMessage_PlayerInfoData::mutable_playername() {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  return playername_;
}
inline ::std::string* PlayerInfoReplyMessage_PlayerInfoData::release_playername() {
  clear_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playername_;
    playername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool isHuman = 2;
inline bool PlayerInfoReplyMessage_PlayerInfoData::has_ishuman() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_has_ishuman() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_has_ishuman() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_ishuman() {
  ishuman_ = false;
  clear_has_ishuman();
}
inline bool PlayerInfoReplyMessage_PlayerInfoData::ishuman() const {
  return ishuman_;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_ishuman(bool value) {
  set_has_ishuman();
  ishuman_ = value;
}

// required .NetPlayerInfoRights playerRights = 3;
inline bool PlayerInfoReplyMessage_PlayerInfoData::has_playerrights() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_has_playerrights() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_has_playerrights() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_playerrights() {
  playerrights_ = 1;
  clear_has_playerrights();
}
inline NetPlayerInfoRights PlayerInfoReplyMessage_PlayerInfoData::playerrights() const {
  return static_cast< NetPlayerInfoRights >(playerrights_);
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_playerrights(NetPlayerInfoRights value) {
  GOOGLE_DCHECK(NetPlayerInfoRights_IsValid(value));
  set_has_playerrights();
  playerrights_ = value;
}

// optional string countryCode = 4;
inline bool PlayerInfoReplyMessage_PlayerInfoData::has_countrycode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_has_countrycode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_has_countrycode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_countrycode() {
  if (countrycode_ != &::google::protobuf::internal::kEmptyString) {
    countrycode_->clear();
  }
  clear_has_countrycode();
}
inline const ::std::string& PlayerInfoReplyMessage_PlayerInfoData::countrycode() const {
  return *countrycode_;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_countrycode(const ::std::string& value) {
  set_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::kEmptyString) {
    countrycode_ = new ::std::string;
  }
  countrycode_->assign(value);
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_countrycode(const char* value) {
  set_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::kEmptyString) {
    countrycode_ = new ::std::string;
  }
  countrycode_->assign(value);
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_countrycode(const char* value, size_t size) {
  set_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::kEmptyString) {
    countrycode_ = new ::std::string;
  }
  countrycode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerInfoReplyMessage_PlayerInfoData::mutable_countrycode() {
  set_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::kEmptyString) {
    countrycode_ = new ::std::string;
  }
  return countrycode_;
}
inline ::std::string* PlayerInfoReplyMessage_PlayerInfoData::release_countrycode() {
  clear_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = countrycode_;
    countrycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .PlayerInfoReplyMessage.PlayerInfoData.AvatarData avatarData = 5;
inline bool PlayerInfoReplyMessage_PlayerInfoData::has_avatardata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_has_avatardata() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_has_avatardata() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_avatardata() {
  if (avatardata_ != NULL) avatardata_->::PlayerInfoReplyMessage_PlayerInfoData_AvatarData::Clear();
  clear_has_avatardata();
}
inline const ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData& PlayerInfoReplyMessage_PlayerInfoData::avatardata() const {
  return avatardata_ != NULL ? *avatardata_ : *default_instance_->avatardata_;
}
inline ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* PlayerInfoReplyMessage_PlayerInfoData::mutable_avatardata() {
  set_has_avatardata();
  if (avatardata_ == NULL) avatardata_ = new ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData;
  return avatardata_;
}
inline ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* PlayerInfoReplyMessage_PlayerInfoData::release_avatardata() {
  clear_has_avatardata();
  ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* temp = avatardata_;
  avatardata_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PlayerInfoReplyMessage

// required uint32 playerId = 1;
inline bool PlayerInfoReplyMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInfoReplyMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerInfoReplyMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerInfoReplyMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 PlayerInfoReplyMessage::playerid() const {
  return playerid_;
}
inline void PlayerInfoReplyMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional .PlayerInfoReplyMessage.PlayerInfoData playerInfoData = 2;
inline bool PlayerInfoReplyMessage::has_playerinfodata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInfoReplyMessage::set_has_playerinfodata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerInfoReplyMessage::clear_has_playerinfodata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerInfoReplyMessage::clear_playerinfodata() {
  if (playerinfodata_ != NULL) playerinfodata_->::PlayerInfoReplyMessage_PlayerInfoData::Clear();
  clear_has_playerinfodata();
}
inline const ::PlayerInfoReplyMessage_PlayerInfoData& PlayerInfoReplyMessage::playerinfodata() const {
  return playerinfodata_ != NULL ? *playerinfodata_ : *default_instance_->playerinfodata_;
}
inline ::PlayerInfoReplyMessage_PlayerInfoData* PlayerInfoReplyMessage::mutable_playerinfodata() {
  set_has_playerinfodata();
  if (playerinfodata_ == NULL) playerinfodata_ = new ::PlayerInfoReplyMessage_PlayerInfoData;
  return playerinfodata_;
}
inline ::PlayerInfoReplyMessage_PlayerInfoData* PlayerInfoReplyMessage::release_playerinfodata() {
  clear_has_playerinfodata();
  ::PlayerInfoReplyMessage_PlayerInfoData* temp = playerinfodata_;
  playerinfodata_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// SubscriptionRequestMessage

// required .SubscriptionRequestMessage.SubscriptionAction subscriptionAction = 1;
inline bool SubscriptionRequestMessage::has_subscriptionaction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscriptionRequestMessage::set_has_subscriptionaction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubscriptionRequestMessage::clear_has_subscriptionaction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubscriptionRequestMessage::clear_subscriptionaction() {
  subscriptionaction_ = 1;
  clear_has_subscriptionaction();
}
inline ::SubscriptionRequestMessage_SubscriptionAction SubscriptionRequestMessage::subscriptionaction() const {
  return static_cast< ::SubscriptionRequestMessage_SubscriptionAction >(subscriptionaction_);
}
inline void SubscriptionRequestMessage::set_subscriptionaction(::SubscriptionRequestMessage_SubscriptionAction value) {
  GOOGLE_DCHECK(::SubscriptionRequestMessage_SubscriptionAction_IsValid(value));
  set_has_subscriptionaction();
  subscriptionaction_ = value;
}

// -------------------------------------------------------------------

// JoinExistingGameMessage

// required uint32 gameId = 1;
inline bool JoinExistingGameMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinExistingGameMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinExistingGameMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinExistingGameMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 JoinExistingGameMessage::gameid() const {
  return gameid_;
}
inline void JoinExistingGameMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional string password = 2;
inline bool JoinExistingGameMessage::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinExistingGameMessage::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinExistingGameMessage::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinExistingGameMessage::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& JoinExistingGameMessage::password() const {
  return *password_;
}
inline void JoinExistingGameMessage::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void JoinExistingGameMessage::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void JoinExistingGameMessage::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JoinExistingGameMessage::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* JoinExistingGameMessage::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool autoLeave = 3;
inline bool JoinExistingGameMessage::has_autoleave() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JoinExistingGameMessage::set_has_autoleave() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JoinExistingGameMessage::clear_has_autoleave() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JoinExistingGameMessage::clear_autoleave() {
  autoleave_ = false;
  clear_has_autoleave();
}
inline bool JoinExistingGameMessage::autoleave() const {
  return autoleave_;
}
inline void JoinExistingGameMessage::set_autoleave(bool value) {
  set_has_autoleave();
  autoleave_ = value;
}

// -------------------------------------------------------------------

// JoinNewGameMessage

// required .NetGameInfo gameInfo = 1;
inline bool JoinNewGameMessage::has_gameinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinNewGameMessage::set_has_gameinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinNewGameMessage::clear_has_gameinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinNewGameMessage::clear_gameinfo() {
  if (gameinfo_ != NULL) gameinfo_->::NetGameInfo::Clear();
  clear_has_gameinfo();
}
inline const ::NetGameInfo& JoinNewGameMessage::gameinfo() const {
  return gameinfo_ != NULL ? *gameinfo_ : *default_instance_->gameinfo_;
}
inline ::NetGameInfo* JoinNewGameMessage::mutable_gameinfo() {
  set_has_gameinfo();
  if (gameinfo_ == NULL) gameinfo_ = new ::NetGameInfo;
  return gameinfo_;
}
inline ::NetGameInfo* JoinNewGameMessage::release_gameinfo() {
  clear_has_gameinfo();
  ::NetGameInfo* temp = gameinfo_;
  gameinfo_ = NULL;
  return temp;
}

// optional string password = 2;
inline bool JoinNewGameMessage::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinNewGameMessage::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinNewGameMessage::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinNewGameMessage::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& JoinNewGameMessage::password() const {
  return *password_;
}
inline void JoinNewGameMessage::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void JoinNewGameMessage::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void JoinNewGameMessage::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JoinNewGameMessage::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* JoinNewGameMessage::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool autoLeave = 3;
inline bool JoinNewGameMessage::has_autoleave() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JoinNewGameMessage::set_has_autoleave() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JoinNewGameMessage::clear_has_autoleave() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JoinNewGameMessage::clear_autoleave() {
  autoleave_ = false;
  clear_has_autoleave();
}
inline bool JoinNewGameMessage::autoleave() const {
  return autoleave_;
}
inline void JoinNewGameMessage::set_autoleave(bool value) {
  set_has_autoleave();
  autoleave_ = value;
}

// -------------------------------------------------------------------

// RejoinExistingGameMessage

// required uint32 gameId = 1;
inline bool RejoinExistingGameMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RejoinExistingGameMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RejoinExistingGameMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RejoinExistingGameMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 RejoinExistingGameMessage::gameid() const {
  return gameid_;
}
inline void RejoinExistingGameMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional bool autoLeave = 2;
inline bool RejoinExistingGameMessage::has_autoleave() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RejoinExistingGameMessage::set_has_autoleave() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RejoinExistingGameMessage::clear_has_autoleave() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RejoinExistingGameMessage::clear_autoleave() {
  autoleave_ = false;
  clear_has_autoleave();
}
inline bool RejoinExistingGameMessage::autoleave() const {
  return autoleave_;
}
inline void RejoinExistingGameMessage::set_autoleave(bool value) {
  set_has_autoleave();
  autoleave_ = value;
}

// -------------------------------------------------------------------

// JoinGameAckMessage

// required uint32 gameId = 1;
inline bool JoinGameAckMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinGameAckMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinGameAckMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinGameAckMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 JoinGameAckMessage::gameid() const {
  return gameid_;
}
inline void JoinGameAckMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required bool areYouGameAdmin = 2;
inline bool JoinGameAckMessage::has_areyougameadmin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinGameAckMessage::set_has_areyougameadmin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinGameAckMessage::clear_has_areyougameadmin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinGameAckMessage::clear_areyougameadmin() {
  areyougameadmin_ = false;
  clear_has_areyougameadmin();
}
inline bool JoinGameAckMessage::areyougameadmin() const {
  return areyougameadmin_;
}
inline void JoinGameAckMessage::set_areyougameadmin(bool value) {
  set_has_areyougameadmin();
  areyougameadmin_ = value;
}

// required .NetGameInfo gameInfo = 3;
inline bool JoinGameAckMessage::has_gameinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JoinGameAckMessage::set_has_gameinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JoinGameAckMessage::clear_has_gameinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JoinGameAckMessage::clear_gameinfo() {
  if (gameinfo_ != NULL) gameinfo_->::NetGameInfo::Clear();
  clear_has_gameinfo();
}
inline const ::NetGameInfo& JoinGameAckMessage::gameinfo() const {
  return gameinfo_ != NULL ? *gameinfo_ : *default_instance_->gameinfo_;
}
inline ::NetGameInfo* JoinGameAckMessage::mutable_gameinfo() {
  set_has_gameinfo();
  if (gameinfo_ == NULL) gameinfo_ = new ::NetGameInfo;
  return gameinfo_;
}
inline ::NetGameInfo* JoinGameAckMessage::release_gameinfo() {
  clear_has_gameinfo();
  ::NetGameInfo* temp = gameinfo_;
  gameinfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// JoinGameFailedMessage

// required uint32 gameId = 1;
inline bool JoinGameFailedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinGameFailedMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinGameFailedMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinGameFailedMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 JoinGameFailedMessage::gameid() const {
  return gameid_;
}
inline void JoinGameFailedMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required .JoinGameFailedMessage.JoinGameFailureReason joinGameFailureReason = 2;
inline bool JoinGameFailedMessage::has_joingamefailurereason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinGameFailedMessage::set_has_joingamefailurereason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinGameFailedMessage::clear_has_joingamefailurereason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinGameFailedMessage::clear_joingamefailurereason() {
  joingamefailurereason_ = 1;
  clear_has_joingamefailurereason();
}
inline ::JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage::joingamefailurereason() const {
  return static_cast< ::JoinGameFailedMessage_JoinGameFailureReason >(joingamefailurereason_);
}
inline void JoinGameFailedMessage::set_joingamefailurereason(::JoinGameFailedMessage_JoinGameFailureReason value) {
  GOOGLE_DCHECK(::JoinGameFailedMessage_JoinGameFailureReason_IsValid(value));
  set_has_joingamefailurereason();
  joingamefailurereason_ = value;
}

// -------------------------------------------------------------------

// GamePlayerJoinedMessage

// required uint32 gameId = 1;
inline bool GamePlayerJoinedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GamePlayerJoinedMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GamePlayerJoinedMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GamePlayerJoinedMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GamePlayerJoinedMessage::gameid() const {
  return gameid_;
}
inline void GamePlayerJoinedMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 playerId = 2;
inline bool GamePlayerJoinedMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GamePlayerJoinedMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GamePlayerJoinedMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GamePlayerJoinedMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 GamePlayerJoinedMessage::playerid() const {
  return playerid_;
}
inline void GamePlayerJoinedMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
}

// required bool isGameAdmin = 3;
inline bool GamePlayerJoinedMessage::has_isgameadmin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GamePlayerJoinedMessage::set_has_isgameadmin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GamePlayerJoinedMessage::clear_has_isgameadmin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GamePlayerJoinedMessage::clear_isgameadmin() {
  isgameadmin_ = false;
  clear_has_isgameadmin();
}
inline bool GamePlayerJoinedMessage::isgameadmin() const {
  return isgameadmin_;
}
inline void GamePlayerJoinedMessage::set_isgameadmin(bool value) {
  set_has_isgameadmin();
  isgameadmin_ = value;
}

// -------------------------------------------------------------------

// GamePlayerLeftMessage

// required uint32 gameId = 1;
inline bool GamePlayerLeftMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GamePlayerLeftMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GamePlayerLeftMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GamePlayerLeftMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GamePlayerLeftMessage::gameid() const {
  return gameid_;
}
inline void GamePlayerLeftMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 playerId = 2;
inline bool GamePlayerLeftMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GamePlayerLeftMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GamePlayerLeftMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GamePlayerLeftMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 GamePlayerLeftMessage::playerid() const {
  return playerid_;
}
inline void GamePlayerLeftMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
}

// required .GamePlayerLeftMessage.GamePlayerLeftReason gamePlayerLeftReason = 3;
inline bool GamePlayerLeftMessage::has_gameplayerleftreason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GamePlayerLeftMessage::set_has_gameplayerleftreason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GamePlayerLeftMessage::clear_has_gameplayerleftreason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GamePlayerLeftMessage::clear_gameplayerleftreason() {
  gameplayerleftreason_ = 0;
  clear_has_gameplayerleftreason();
}
inline ::GamePlayerLeftMessage_GamePlayerLeftReason GamePlayerLeftMessage::gameplayerleftreason() const {
  return static_cast< ::GamePlayerLeftMessage_GamePlayerLeftReason >(gameplayerleftreason_);
}
inline void GamePlayerLeftMessage::set_gameplayerleftreason(::GamePlayerLeftMessage_GamePlayerLeftReason value) {
  GOOGLE_DCHECK(::GamePlayerLeftMessage_GamePlayerLeftReason_IsValid(value));
  set_has_gameplayerleftreason();
  gameplayerleftreason_ = value;
}

// -------------------------------------------------------------------

// GameAdminChangedMessage

// required uint32 gameId = 1;
inline bool GameAdminChangedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameAdminChangedMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameAdminChangedMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameAdminChangedMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameAdminChangedMessage::gameid() const {
  return gameid_;
}
inline void GameAdminChangedMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 newAdminPlayerId = 2;
inline bool GameAdminChangedMessage::has_newadminplayerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameAdminChangedMessage::set_has_newadminplayerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameAdminChangedMessage::clear_has_newadminplayerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameAdminChangedMessage::clear_newadminplayerid() {
  newadminplayerid_ = 0u;
  clear_has_newadminplayerid();
}
inline ::google::protobuf::uint32 GameAdminChangedMessage::newadminplayerid() const {
  return newadminplayerid_;
}
inline void GameAdminChangedMessage::set_newadminplayerid(::google::protobuf::uint32 value) {
  set_has_newadminplayerid();
  newadminplayerid_ = value;
}

// -------------------------------------------------------------------

// RemovedFromGameMessage

// required uint32 gameId = 1;
inline bool RemovedFromGameMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemovedFromGameMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemovedFromGameMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemovedFromGameMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 RemovedFromGameMessage::gameid() const {
  return gameid_;
}
inline void RemovedFromGameMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required .RemovedFromGameMessage.RemovedFromGameReason removedFromGameReason = 2;
inline bool RemovedFromGameMessage::has_removedfromgamereason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemovedFromGameMessage::set_has_removedfromgamereason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemovedFromGameMessage::clear_has_removedfromgamereason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemovedFromGameMessage::clear_removedfromgamereason() {
  removedfromgamereason_ = 0;
  clear_has_removedfromgamereason();
}
inline ::RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameMessage::removedfromgamereason() const {
  return static_cast< ::RemovedFromGameMessage_RemovedFromGameReason >(removedfromgamereason_);
}
inline void RemovedFromGameMessage::set_removedfromgamereason(::RemovedFromGameMessage_RemovedFromGameReason value) {
  GOOGLE_DCHECK(::RemovedFromGameMessage_RemovedFromGameReason_IsValid(value));
  set_has_removedfromgamereason();
  removedfromgamereason_ = value;
}

// -------------------------------------------------------------------

// KickPlayerRequestMessage

// required uint32 gameId = 1;
inline bool KickPlayerRequestMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KickPlayerRequestMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KickPlayerRequestMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KickPlayerRequestMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 KickPlayerRequestMessage::gameid() const {
  return gameid_;
}
inline void KickPlayerRequestMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 playerId = 2;
inline bool KickPlayerRequestMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KickPlayerRequestMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KickPlayerRequestMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KickPlayerRequestMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 KickPlayerRequestMessage::playerid() const {
  return playerid_;
}
inline void KickPlayerRequestMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
}

// -------------------------------------------------------------------

// LeaveGameRequestMessage

// required uint32 gameId = 1;
inline bool LeaveGameRequestMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveGameRequestMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaveGameRequestMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaveGameRequestMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 LeaveGameRequestMessage::gameid() const {
  return gameid_;
}
inline void LeaveGameRequestMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// -------------------------------------------------------------------

// InvitePlayerToGameMessage

// required uint32 gameId = 1;
inline bool InvitePlayerToGameMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvitePlayerToGameMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvitePlayerToGameMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvitePlayerToGameMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 InvitePlayerToGameMessage::gameid() const {
  return gameid_;
}
inline void InvitePlayerToGameMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 playerId = 2;
inline bool InvitePlayerToGameMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvitePlayerToGameMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvitePlayerToGameMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvitePlayerToGameMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 InvitePlayerToGameMessage::playerid() const {
  return playerid_;
}
inline void InvitePlayerToGameMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
}

// -------------------------------------------------------------------

// InviteNotifyMessage

// required uint32 gameId = 1;
inline bool InviteNotifyMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InviteNotifyMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InviteNotifyMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InviteNotifyMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 InviteNotifyMessage::gameid() const {
  return gameid_;
}
inline void InviteNotifyMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 playerIdWho = 2;
inline bool InviteNotifyMessage::has_playeridwho() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InviteNotifyMessage::set_has_playeridwho() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InviteNotifyMessage::clear_has_playeridwho() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InviteNotifyMessage::clear_playeridwho() {
  playeridwho_ = 0u;
  clear_has_playeridwho();
}
inline ::google::protobuf::uint32 InviteNotifyMessage::playeridwho() const {
  return playeridwho_;
}
inline void InviteNotifyMessage::set_playeridwho(::google::protobuf::uint32 value) {
  set_has_playeridwho();
  playeridwho_ = value;
}

// required uint32 playerIdByWhom = 3;
inline bool InviteNotifyMessage::has_playeridbywhom() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InviteNotifyMessage::set_has_playeridbywhom() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InviteNotifyMessage::clear_has_playeridbywhom() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InviteNotifyMessage::clear_playeridbywhom() {
  playeridbywhom_ = 0u;
  clear_has_playeridbywhom();
}
inline ::google::protobuf::uint32 InviteNotifyMessage::playeridbywhom() const {
  return playeridbywhom_;
}
inline void InviteNotifyMessage::set_playeridbywhom(::google::protobuf::uint32 value) {
  set_has_playeridbywhom();
  playeridbywhom_ = value;
}

// -------------------------------------------------------------------

// RejectGameInvitationMessage

// required uint32 gameId = 1;
inline bool RejectGameInvitationMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RejectGameInvitationMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RejectGameInvitationMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RejectGameInvitationMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 RejectGameInvitationMessage::gameid() const {
  return gameid_;
}
inline void RejectGameInvitationMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required .RejectGameInvitationMessage.RejectGameInvReason myRejectReason = 2;
inline bool RejectGameInvitationMessage::has_myrejectreason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RejectGameInvitationMessage::set_has_myrejectreason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RejectGameInvitationMessage::clear_has_myrejectreason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RejectGameInvitationMessage::clear_myrejectreason() {
  myrejectreason_ = 0;
  clear_has_myrejectreason();
}
inline ::RejectGameInvitationMessage_RejectGameInvReason RejectGameInvitationMessage::myrejectreason() const {
  return static_cast< ::RejectGameInvitationMessage_RejectGameInvReason >(myrejectreason_);
}
inline void RejectGameInvitationMessage::set_myrejectreason(::RejectGameInvitationMessage_RejectGameInvReason value) {
  GOOGLE_DCHECK(::RejectGameInvitationMessage_RejectGameInvReason_IsValid(value));
  set_has_myrejectreason();
  myrejectreason_ = value;
}

// -------------------------------------------------------------------

// RejectInvNotifyMessage

// required uint32 gameId = 1;
inline bool RejectInvNotifyMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RejectInvNotifyMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RejectInvNotifyMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RejectInvNotifyMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 RejectInvNotifyMessage::gameid() const {
  return gameid_;
}
inline void RejectInvNotifyMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 playerId = 2;
inline bool RejectInvNotifyMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RejectInvNotifyMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RejectInvNotifyMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RejectInvNotifyMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 RejectInvNotifyMessage::playerid() const {
  return playerid_;
}
inline void RejectInvNotifyMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
}

// required .RejectGameInvitationMessage.RejectGameInvReason playerRejectReason = 3;
inline bool RejectInvNotifyMessage::has_playerrejectreason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RejectInvNotifyMessage::set_has_playerrejectreason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RejectInvNotifyMessage::clear_has_playerrejectreason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RejectInvNotifyMessage::clear_playerrejectreason() {
  playerrejectreason_ = 0;
  clear_has_playerrejectreason();
}
inline ::RejectGameInvitationMessage_RejectGameInvReason RejectInvNotifyMessage::playerrejectreason() const {
  return static_cast< ::RejectGameInvitationMessage_RejectGameInvReason >(playerrejectreason_);
}
inline void RejectInvNotifyMessage::set_playerrejectreason(::RejectGameInvitationMessage_RejectGameInvReason value) {
  GOOGLE_DCHECK(::RejectGameInvitationMessage_RejectGameInvReason_IsValid(value));
  set_has_playerrejectreason();
  playerrejectreason_ = value;
}

// -------------------------------------------------------------------

// StartEventMessage

// required uint32 gameId = 1;
inline bool StartEventMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartEventMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartEventMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartEventMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 StartEventMessage::gameid() const {
  return gameid_;
}
inline void StartEventMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required .StartEventMessage.StartEventType startEventType = 2;
inline bool StartEventMessage::has_starteventtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartEventMessage::set_has_starteventtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartEventMessage::clear_has_starteventtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartEventMessage::clear_starteventtype() {
  starteventtype_ = 0;
  clear_has_starteventtype();
}
inline ::StartEventMessage_StartEventType StartEventMessage::starteventtype() const {
  return static_cast< ::StartEventMessage_StartEventType >(starteventtype_);
}
inline void StartEventMessage::set_starteventtype(::StartEventMessage_StartEventType value) {
  GOOGLE_DCHECK(::StartEventMessage_StartEventType_IsValid(value));
  set_has_starteventtype();
  starteventtype_ = value;
}

// optional bool fillWithComputerPlayers = 3;
inline bool StartEventMessage::has_fillwithcomputerplayers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartEventMessage::set_has_fillwithcomputerplayers() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StartEventMessage::clear_has_fillwithcomputerplayers() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StartEventMessage::clear_fillwithcomputerplayers() {
  fillwithcomputerplayers_ = false;
  clear_has_fillwithcomputerplayers();
}
inline bool StartEventMessage::fillwithcomputerplayers() const {
  return fillwithcomputerplayers_;
}
inline void StartEventMessage::set_fillwithcomputerplayers(bool value) {
  set_has_fillwithcomputerplayers();
  fillwithcomputerplayers_ = value;
}

// -------------------------------------------------------------------

// StartEventAckMessage

// required uint32 gameId = 1;
inline bool StartEventAckMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartEventAckMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartEventAckMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartEventAckMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 StartEventAckMessage::gameid() const {
  return gameid_;
}
inline void StartEventAckMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// -------------------------------------------------------------------

// GameStartInitialMessage

// required uint32 gameId = 1;
inline bool GameStartInitialMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameStartInitialMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameStartInitialMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameStartInitialMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameStartInitialMessage::gameid() const {
  return gameid_;
}
inline void GameStartInitialMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 startDealerPlayerId = 2;
inline bool GameStartInitialMessage::has_startdealerplayerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameStartInitialMessage::set_has_startdealerplayerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameStartInitialMessage::clear_has_startdealerplayerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameStartInitialMessage::clear_startdealerplayerid() {
  startdealerplayerid_ = 0u;
  clear_has_startdealerplayerid();
}
inline ::google::protobuf::uint32 GameStartInitialMessage::startdealerplayerid() const {
  return startdealerplayerid_;
}
inline void GameStartInitialMessage::set_startdealerplayerid(::google::protobuf::uint32 value) {
  set_has_startdealerplayerid();
  startdealerplayerid_ = value;
}

// repeated uint32 playerSeats = 3 [packed = true];
inline int GameStartInitialMessage::playerseats_size() const {
  return playerseats_.size();
}
inline void GameStartInitialMessage::clear_playerseats() {
  playerseats_.Clear();
}
inline ::google::protobuf::uint32 GameStartInitialMessage::playerseats(int index) const {
  return playerseats_.Get(index);
}
inline void GameStartInitialMessage::set_playerseats(int index, ::google::protobuf::uint32 value) {
  playerseats_.Set(index, value);
}
inline void GameStartInitialMessage::add_playerseats(::google::protobuf::uint32 value) {
  playerseats_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GameStartInitialMessage::playerseats() const {
  return playerseats_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GameStartInitialMessage::mutable_playerseats() {
  return &playerseats_;
}

// -------------------------------------------------------------------

// GameStartRejoinMessage_RejoinPlayerData

// required uint32 playerId = 1;
inline bool GameStartRejoinMessage_RejoinPlayerData::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameStartRejoinMessage_RejoinPlayerData::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameStartRejoinMessage_RejoinPlayerData::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameStartRejoinMessage_RejoinPlayerData::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 GameStartRejoinMessage_RejoinPlayerData::playerid() const {
  return playerid_;
}
inline void GameStartRejoinMessage_RejoinPlayerData::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
}

// required uint32 playerMoney = 2;
inline bool GameStartRejoinMessage_RejoinPlayerData::has_playermoney() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameStartRejoinMessage_RejoinPlayerData::set_has_playermoney() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameStartRejoinMessage_RejoinPlayerData::clear_has_playermoney() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameStartRejoinMessage_RejoinPlayerData::clear_playermoney() {
  playermoney_ = 0u;
  clear_has_playermoney();
}
inline ::google::protobuf::uint32 GameStartRejoinMessage_RejoinPlayerData::playermoney() const {
  return playermoney_;
}
inline void GameStartRejoinMessage_RejoinPlayerData::set_playermoney(::google::protobuf::uint32 value) {
  set_has_playermoney();
  playermoney_ = value;
}

// -------------------------------------------------------------------

// GameStartRejoinMessage

// required uint32 gameId = 1;
inline bool GameStartRejoinMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameStartRejoinMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameStartRejoinMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameStartRejoinMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameStartRejoinMessage::gameid() const {
  return gameid_;
}
inline void GameStartRejoinMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 startDealerPlayerId = 2;
inline bool GameStartRejoinMessage::has_startdealerplayerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameStartRejoinMessage::set_has_startdealerplayerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameStartRejoinMessage::clear_has_startdealerplayerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameStartRejoinMessage::clear_startdealerplayerid() {
  startdealerplayerid_ = 0u;
  clear_has_startdealerplayerid();
}
inline ::google::protobuf::uint32 GameStartRejoinMessage::startdealerplayerid() const {
  return startdealerplayerid_;
}
inline void GameStartRejoinMessage::set_startdealerplayerid(::google::protobuf::uint32 value) {
  set_has_startdealerplayerid();
  startdealerplayerid_ = value;
}

// required uint32 handNum = 3;
inline bool GameStartRejoinMessage::has_handnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameStartRejoinMessage::set_has_handnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameStartRejoinMessage::clear_has_handnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameStartRejoinMessage::clear_handnum() {
  handnum_ = 0u;
  clear_has_handnum();
}
inline ::google::protobuf::uint32 GameStartRejoinMessage::handnum() const {
  return handnum_;
}
inline void GameStartRejoinMessage::set_handnum(::google::protobuf::uint32 value) {
  set_has_handnum();
  handnum_ = value;
}

// repeated .GameStartRejoinMessage.RejoinPlayerData rejoinPlayerData = 4;
inline int GameStartRejoinMessage::rejoinplayerdata_size() const {
  return rejoinplayerdata_.size();
}
inline void GameStartRejoinMessage::clear_rejoinplayerdata() {
  rejoinplayerdata_.Clear();
}
inline const ::GameStartRejoinMessage_RejoinPlayerData& GameStartRejoinMessage::rejoinplayerdata(int index) const {
  return rejoinplayerdata_.Get(index);
}
inline ::GameStartRejoinMessage_RejoinPlayerData* GameStartRejoinMessage::mutable_rejoinplayerdata(int index) {
  return rejoinplayerdata_.Mutable(index);
}
inline ::GameStartRejoinMessage_RejoinPlayerData* GameStartRejoinMessage::add_rejoinplayerdata() {
  return rejoinplayerdata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GameStartRejoinMessage_RejoinPlayerData >&
GameStartRejoinMessage::rejoinplayerdata() const {
  return rejoinplayerdata_;
}
inline ::google::protobuf::RepeatedPtrField< ::GameStartRejoinMessage_RejoinPlayerData >*
GameStartRejoinMessage::mutable_rejoinplayerdata() {
  return &rejoinplayerdata_;
}

// -------------------------------------------------------------------

// HandStartMessage_PlainCards

// required uint32 plainCard1 = 1;
inline bool HandStartMessage_PlainCards::has_plaincard1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HandStartMessage_PlainCards::set_has_plaincard1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HandStartMessage_PlainCards::clear_has_plaincard1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HandStartMessage_PlainCards::clear_plaincard1() {
  plaincard1_ = 0u;
  clear_has_plaincard1();
}
inline ::google::protobuf::uint32 HandStartMessage_PlainCards::plaincard1() const {
  return plaincard1_;
}
inline void HandStartMessage_PlainCards::set_plaincard1(::google::protobuf::uint32 value) {
  set_has_plaincard1();
  plaincard1_ = value;
}

// required uint32 plainCard2 = 2;
inline bool HandStartMessage_PlainCards::has_plaincard2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HandStartMessage_PlainCards::set_has_plaincard2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HandStartMessage_PlainCards::clear_has_plaincard2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HandStartMessage_PlainCards::clear_plaincard2() {
  plaincard2_ = 0u;
  clear_has_plaincard2();
}
inline ::google::protobuf::uint32 HandStartMessage_PlainCards::plaincard2() const {
  return plaincard2_;
}
inline void HandStartMessage_PlainCards::set_plaincard2(::google::protobuf::uint32 value) {
  set_has_plaincard2();
  plaincard2_ = value;
}

// -------------------------------------------------------------------

// HandStartMessage

// required uint32 gameId = 1;
inline bool HandStartMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HandStartMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HandStartMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HandStartMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 HandStartMessage::gameid() const {
  return gameid_;
}
inline void HandStartMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional .HandStartMessage.PlainCards plainCards = 2;
inline bool HandStartMessage::has_plaincards() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HandStartMessage::set_has_plaincards() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HandStartMessage::clear_has_plaincards() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HandStartMessage::clear_plaincards() {
  if (plaincards_ != NULL) plaincards_->::HandStartMessage_PlainCards::Clear();
  clear_has_plaincards();
}
inline const ::HandStartMessage_PlainCards& HandStartMessage::plaincards() const {
  return plaincards_ != NULL ? *plaincards_ : *default_instance_->plaincards_;
}
inline ::HandStartMessage_PlainCards* HandStartMessage::mutable_plaincards() {
  set_has_plaincards();
  if (plaincards_ == NULL) plaincards_ = new ::HandStartMessage_PlainCards;
  return plaincards_;
}
inline ::HandStartMessage_PlainCards* HandStartMessage::release_plaincards() {
  clear_has_plaincards();
  ::HandStartMessage_PlainCards* temp = plaincards_;
  plaincards_ = NULL;
  return temp;
}

// optional bytes encryptedCards = 3;
inline bool HandStartMessage::has_encryptedcards() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HandStartMessage::set_has_encryptedcards() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HandStartMessage::clear_has_encryptedcards() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HandStartMessage::clear_encryptedcards() {
  if (encryptedcards_ != &::google::protobuf::internal::kEmptyString) {
    encryptedcards_->clear();
  }
  clear_has_encryptedcards();
}
inline const ::std::string& HandStartMessage::encryptedcards() const {
  return *encryptedcards_;
}
inline void HandStartMessage::set_encryptedcards(const ::std::string& value) {
  set_has_encryptedcards();
  if (encryptedcards_ == &::google::protobuf::internal::kEmptyString) {
    encryptedcards_ = new ::std::string;
  }
  encryptedcards_->assign(value);
}
inline void HandStartMessage::set_encryptedcards(const char* value) {
  set_has_encryptedcards();
  if (encryptedcards_ == &::google::protobuf::internal::kEmptyString) {
    encryptedcards_ = new ::std::string;
  }
  encryptedcards_->assign(value);
}
inline void HandStartMessage::set_encryptedcards(const void* value, size_t size) {
  set_has_encryptedcards();
  if (encryptedcards_ == &::google::protobuf::internal::kEmptyString) {
    encryptedcards_ = new ::std::string;
  }
  encryptedcards_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HandStartMessage::mutable_encryptedcards() {
  set_has_encryptedcards();
  if (encryptedcards_ == &::google::protobuf::internal::kEmptyString) {
    encryptedcards_ = new ::std::string;
  }
  return encryptedcards_;
}
inline ::std::string* HandStartMessage::release_encryptedcards() {
  clear_has_encryptedcards();
  if (encryptedcards_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptedcards_;
    encryptedcards_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 smallBlind = 4;
inline bool HandStartMessage::has_smallblind() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HandStartMessage::set_has_smallblind() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HandStartMessage::clear_has_smallblind() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HandStartMessage::clear_smallblind() {
  smallblind_ = 0u;
  clear_has_smallblind();
}
inline ::google::protobuf::uint32 HandStartMessage::smallblind() const {
  return smallblind_;
}
inline void HandStartMessage::set_smallblind(::google::protobuf::uint32 value) {
  set_has_smallblind();
  smallblind_ = value;
}

// repeated .NetPlayerState seatStates = 5;
inline int HandStartMessage::seatstates_size() const {
  return seatstates_.size();
}
inline void HandStartMessage::clear_seatstates() {
  seatstates_.Clear();
}
inline NetPlayerState HandStartMessage::seatstates(int index) const {
  return static_cast< NetPlayerState >(seatstates_.Get(index));
}
inline void HandStartMessage::set_seatstates(int index, NetPlayerState value) {
  GOOGLE_DCHECK(NetPlayerState_IsValid(value));
  seatstates_.Set(index, value);
}
inline void HandStartMessage::add_seatstates(NetPlayerState value) {
  GOOGLE_DCHECK(NetPlayerState_IsValid(value));
  seatstates_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
HandStartMessage::seatstates() const {
  return seatstates_;
}
inline ::google::protobuf::RepeatedField<int>*
HandStartMessage::mutable_seatstates() {
  return &seatstates_;
}

// -------------------------------------------------------------------

// PlayersTurnMessage

// required uint32 gameId = 1;
inline bool PlayersTurnMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayersTurnMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayersTurnMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayersTurnMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 PlayersTurnMessage::gameid() const {
  return gameid_;
}
inline void PlayersTurnMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 playerId = 2;
inline bool PlayersTurnMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayersTurnMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayersTurnMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayersTurnMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 PlayersTurnMessage::playerid() const {
  return playerid_;
}
inline void PlayersTurnMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
}

// required .NetGameState gameState = 3;
inline bool PlayersTurnMessage::has_gamestate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayersTurnMessage::set_has_gamestate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayersTurnMessage::clear_has_gamestate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayersTurnMessage::clear_gamestate() {
  gamestate_ = 0;
  clear_has_gamestate();
}
inline NetGameState PlayersTurnMessage::gamestate() const {
  return static_cast< NetGameState >(gamestate_);
}
inline void PlayersTurnMessage::set_gamestate(NetGameState value) {
  GOOGLE_DCHECK(NetGameState_IsValid(value));
  set_has_gamestate();
  gamestate_ = value;
}

// -------------------------------------------------------------------

// MyActionRequestMessage

// required uint32 gameId = 1;
inline bool MyActionRequestMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MyActionRequestMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MyActionRequestMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MyActionRequestMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 MyActionRequestMessage::gameid() const {
  return gameid_;
}
inline void MyActionRequestMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 handNum = 2;
inline bool MyActionRequestMessage::has_handnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MyActionRequestMessage::set_has_handnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MyActionRequestMessage::clear_has_handnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MyActionRequestMessage::clear_handnum() {
  handnum_ = 0u;
  clear_has_handnum();
}
inline ::google::protobuf::uint32 MyActionRequestMessage::handnum() const {
  return handnum_;
}
inline void MyActionRequestMessage::set_handnum(::google::protobuf::uint32 value) {
  set_has_handnum();
  handnum_ = value;
}

// required .NetGameState gameState = 3;
inline bool MyActionRequestMessage::has_gamestate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MyActionRequestMessage::set_has_gamestate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MyActionRequestMessage::clear_has_gamestate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MyActionRequestMessage::clear_gamestate() {
  gamestate_ = 0;
  clear_has_gamestate();
}
inline NetGameState MyActionRequestMessage::gamestate() const {
  return static_cast< NetGameState >(gamestate_);
}
inline void MyActionRequestMessage::set_gamestate(NetGameState value) {
  GOOGLE_DCHECK(NetGameState_IsValid(value));
  set_has_gamestate();
  gamestate_ = value;
}

// required .NetPlayerAction myAction = 4;
inline bool MyActionRequestMessage::has_myaction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MyActionRequestMessage::set_has_myaction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MyActionRequestMessage::clear_has_myaction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MyActionRequestMessage::clear_myaction() {
  myaction_ = 0;
  clear_has_myaction();
}
inline NetPlayerAction MyActionRequestMessage::myaction() const {
  return static_cast< NetPlayerAction >(myaction_);
}
inline void MyActionRequestMessage::set_myaction(NetPlayerAction value) {
  GOOGLE_DCHECK(NetPlayerAction_IsValid(value));
  set_has_myaction();
  myaction_ = value;
}

// required uint32 myRelativeBet = 5;
inline bool MyActionRequestMessage::has_myrelativebet() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MyActionRequestMessage::set_has_myrelativebet() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MyActionRequestMessage::clear_has_myrelativebet() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MyActionRequestMessage::clear_myrelativebet() {
  myrelativebet_ = 0u;
  clear_has_myrelativebet();
}
inline ::google::protobuf::uint32 MyActionRequestMessage::myrelativebet() const {
  return myrelativebet_;
}
inline void MyActionRequestMessage::set_myrelativebet(::google::protobuf::uint32 value) {
  set_has_myrelativebet();
  myrelativebet_ = value;
}

// -------------------------------------------------------------------

// YourActionRejectedMessage

// required uint32 gameId = 1;
inline bool YourActionRejectedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void YourActionRejectedMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void YourActionRejectedMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void YourActionRejectedMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 YourActionRejectedMessage::gameid() const {
  return gameid_;
}
inline void YourActionRejectedMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required .NetGameState gameState = 2;
inline bool YourActionRejectedMessage::has_gamestate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void YourActionRejectedMessage::set_has_gamestate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void YourActionRejectedMessage::clear_has_gamestate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void YourActionRejectedMessage::clear_gamestate() {
  gamestate_ = 0;
  clear_has_gamestate();
}
inline NetGameState YourActionRejectedMessage::gamestate() const {
  return static_cast< NetGameState >(gamestate_);
}
inline void YourActionRejectedMessage::set_gamestate(NetGameState value) {
  GOOGLE_DCHECK(NetGameState_IsValid(value));
  set_has_gamestate();
  gamestate_ = value;
}

// required .NetPlayerAction yourAction = 3;
inline bool YourActionRejectedMessage::has_youraction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void YourActionRejectedMessage::set_has_youraction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void YourActionRejectedMessage::clear_has_youraction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void YourActionRejectedMessage::clear_youraction() {
  youraction_ = 0;
  clear_has_youraction();
}
inline NetPlayerAction YourActionRejectedMessage::youraction() const {
  return static_cast< NetPlayerAction >(youraction_);
}
inline void YourActionRejectedMessage::set_youraction(NetPlayerAction value) {
  GOOGLE_DCHECK(NetPlayerAction_IsValid(value));
  set_has_youraction();
  youraction_ = value;
}

// required uint32 yourRelativeBet = 4;
inline bool YourActionRejectedMessage::has_yourrelativebet() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void YourActionRejectedMessage::set_has_yourrelativebet() {
  _has_bits_[0] |= 0x00000008u;
}
inline void YourActionRejectedMessage::clear_has_yourrelativebet() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void YourActionRejectedMessage::clear_yourrelativebet() {
  yourrelativebet_ = 0u;
  clear_has_yourrelativebet();
}
inline ::google::protobuf::uint32 YourActionRejectedMessage::yourrelativebet() const {
  return yourrelativebet_;
}
inline void YourActionRejectedMessage::set_yourrelativebet(::google::protobuf::uint32 value) {
  set_has_yourrelativebet();
  yourrelativebet_ = value;
}

// required .YourActionRejectedMessage.RejectionReason rejectionReason = 5;
inline bool YourActionRejectedMessage::has_rejectionreason() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void YourActionRejectedMessage::set_has_rejectionreason() {
  _has_bits_[0] |= 0x00000010u;
}
inline void YourActionRejectedMessage::clear_has_rejectionreason() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void YourActionRejectedMessage::clear_rejectionreason() {
  rejectionreason_ = 1;
  clear_has_rejectionreason();
}
inline ::YourActionRejectedMessage_RejectionReason YourActionRejectedMessage::rejectionreason() const {
  return static_cast< ::YourActionRejectedMessage_RejectionReason >(rejectionreason_);
}
inline void YourActionRejectedMessage::set_rejectionreason(::YourActionRejectedMessage_RejectionReason value) {
  GOOGLE_DCHECK(::YourActionRejectedMessage_RejectionReason_IsValid(value));
  set_has_rejectionreason();
  rejectionreason_ = value;
}

// -------------------------------------------------------------------

// PlayersActionDoneMessage

// required uint32 gameId = 1;
inline bool PlayersActionDoneMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayersActionDoneMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayersActionDoneMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayersActionDoneMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 PlayersActionDoneMessage::gameid() const {
  return gameid_;
}
inline void PlayersActionDoneMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 playerId = 2;
inline bool PlayersActionDoneMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayersActionDoneMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayersActionDoneMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayersActionDoneMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 PlayersActionDoneMessage::playerid() const {
  return playerid_;
}
inline void PlayersActionDoneMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
}

// required .NetGameState gameState = 3;
inline bool PlayersActionDoneMessage::has_gamestate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayersActionDoneMessage::set_has_gamestate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayersActionDoneMessage::clear_has_gamestate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayersActionDoneMessage::clear_gamestate() {
  gamestate_ = 0;
  clear_has_gamestate();
}
inline NetGameState PlayersActionDoneMessage::gamestate() const {
  return static_cast< NetGameState >(gamestate_);
}
inline void PlayersActionDoneMessage::set_gamestate(NetGameState value) {
  GOOGLE_DCHECK(NetGameState_IsValid(value));
  set_has_gamestate();
  gamestate_ = value;
}

// required .NetPlayerAction playerAction = 4;
inline bool PlayersActionDoneMessage::has_playeraction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayersActionDoneMessage::set_has_playeraction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayersActionDoneMessage::clear_has_playeraction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayersActionDoneMessage::clear_playeraction() {
  playeraction_ = 0;
  clear_has_playeraction();
}
inline NetPlayerAction PlayersActionDoneMessage::playeraction() const {
  return static_cast< NetPlayerAction >(playeraction_);
}
inline void PlayersActionDoneMessage::set_playeraction(NetPlayerAction value) {
  GOOGLE_DCHECK(NetPlayerAction_IsValid(value));
  set_has_playeraction();
  playeraction_ = value;
}

// required uint32 totalPlayerBet = 5;
inline bool PlayersActionDoneMessage::has_totalplayerbet() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayersActionDoneMessage::set_has_totalplayerbet() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayersActionDoneMessage::clear_has_totalplayerbet() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayersActionDoneMessage::clear_totalplayerbet() {
  totalplayerbet_ = 0u;
  clear_has_totalplayerbet();
}
inline ::google::protobuf::uint32 PlayersActionDoneMessage::totalplayerbet() const {
  return totalplayerbet_;
}
inline void PlayersActionDoneMessage::set_totalplayerbet(::google::protobuf::uint32 value) {
  set_has_totalplayerbet();
  totalplayerbet_ = value;
}

// required uint32 playerMoney = 6;
inline bool PlayersActionDoneMessage::has_playermoney() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayersActionDoneMessage::set_has_playermoney() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayersActionDoneMessage::clear_has_playermoney() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayersActionDoneMessage::clear_playermoney() {
  playermoney_ = 0u;
  clear_has_playermoney();
}
inline ::google::protobuf::uint32 PlayersActionDoneMessage::playermoney() const {
  return playermoney_;
}
inline void PlayersActionDoneMessage::set_playermoney(::google::protobuf::uint32 value) {
  set_has_playermoney();
  playermoney_ = value;
}

// required uint32 highestSet = 7;
inline bool PlayersActionDoneMessage::has_highestset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlayersActionDoneMessage::set_has_highestset() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlayersActionDoneMessage::clear_has_highestset() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlayersActionDoneMessage::clear_highestset() {
  highestset_ = 0u;
  clear_has_highestset();
}
inline ::google::protobuf::uint32 PlayersActionDoneMessage::highestset() const {
  return highestset_;
}
inline void PlayersActionDoneMessage::set_highestset(::google::protobuf::uint32 value) {
  set_has_highestset();
  highestset_ = value;
}

// required uint32 minimumRaise = 8;
inline bool PlayersActionDoneMessage::has_minimumraise() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlayersActionDoneMessage::set_has_minimumraise() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlayersActionDoneMessage::clear_has_minimumraise() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlayersActionDoneMessage::clear_minimumraise() {
  minimumraise_ = 0u;
  clear_has_minimumraise();
}
inline ::google::protobuf::uint32 PlayersActionDoneMessage::minimumraise() const {
  return minimumraise_;
}
inline void PlayersActionDoneMessage::set_minimumraise(::google::protobuf::uint32 value) {
  set_has_minimumraise();
  minimumraise_ = value;
}

// -------------------------------------------------------------------

// DealFlopCardsMessage

// required uint32 gameId = 1;
inline bool DealFlopCardsMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DealFlopCardsMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DealFlopCardsMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DealFlopCardsMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 DealFlopCardsMessage::gameid() const {
  return gameid_;
}
inline void DealFlopCardsMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 flopCard1 = 2;
inline bool DealFlopCardsMessage::has_flopcard1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DealFlopCardsMessage::set_has_flopcard1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DealFlopCardsMessage::clear_has_flopcard1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DealFlopCardsMessage::clear_flopcard1() {
  flopcard1_ = 0u;
  clear_has_flopcard1();
}
inline ::google::protobuf::uint32 DealFlopCardsMessage::flopcard1() const {
  return flopcard1_;
}
inline void DealFlopCardsMessage::set_flopcard1(::google::protobuf::uint32 value) {
  set_has_flopcard1();
  flopcard1_ = value;
}

// required uint32 flopCard2 = 3;
inline bool DealFlopCardsMessage::has_flopcard2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DealFlopCardsMessage::set_has_flopcard2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DealFlopCardsMessage::clear_has_flopcard2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DealFlopCardsMessage::clear_flopcard2() {
  flopcard2_ = 0u;
  clear_has_flopcard2();
}
inline ::google::protobuf::uint32 DealFlopCardsMessage::flopcard2() const {
  return flopcard2_;
}
inline void DealFlopCardsMessage::set_flopcard2(::google::protobuf::uint32 value) {
  set_has_flopcard2();
  flopcard2_ = value;
}

// required uint32 flopCard3 = 4;
inline bool DealFlopCardsMessage::has_flopcard3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DealFlopCardsMessage::set_has_flopcard3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DealFlopCardsMessage::clear_has_flopcard3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DealFlopCardsMessage::clear_flopcard3() {
  flopcard3_ = 0u;
  clear_has_flopcard3();
}
inline ::google::protobuf::uint32 DealFlopCardsMessage::flopcard3() const {
  return flopcard3_;
}
inline void DealFlopCardsMessage::set_flopcard3(::google::protobuf::uint32 value) {
  set_has_flopcard3();
  flopcard3_ = value;
}

// -------------------------------------------------------------------

// DealTurnCardMessage

// required uint32 gameId = 1;
inline bool DealTurnCardMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DealTurnCardMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DealTurnCardMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DealTurnCardMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 DealTurnCardMessage::gameid() const {
  return gameid_;
}
inline void DealTurnCardMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 turnCard = 2;
inline bool DealTurnCardMessage::has_turncard() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DealTurnCardMessage::set_has_turncard() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DealTurnCardMessage::clear_has_turncard() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DealTurnCardMessage::clear_turncard() {
  turncard_ = 0u;
  clear_has_turncard();
}
inline ::google::protobuf::uint32 DealTurnCardMessage::turncard() const {
  return turncard_;
}
inline void DealTurnCardMessage::set_turncard(::google::protobuf::uint32 value) {
  set_has_turncard();
  turncard_ = value;
}

// -------------------------------------------------------------------

// DealRiverCardMessage

// required uint32 gameId = 1;
inline bool DealRiverCardMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DealRiverCardMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DealRiverCardMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DealRiverCardMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 DealRiverCardMessage::gameid() const {
  return gameid_;
}
inline void DealRiverCardMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 riverCard = 2;
inline bool DealRiverCardMessage::has_rivercard() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DealRiverCardMessage::set_has_rivercard() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DealRiverCardMessage::clear_has_rivercard() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DealRiverCardMessage::clear_rivercard() {
  rivercard_ = 0u;
  clear_has_rivercard();
}
inline ::google::protobuf::uint32 DealRiverCardMessage::rivercard() const {
  return rivercard_;
}
inline void DealRiverCardMessage::set_rivercard(::google::protobuf::uint32 value) {
  set_has_rivercard();
  rivercard_ = value;
}

// -------------------------------------------------------------------

// AllInShowCardsMessage_PlayerAllIn

// required uint32 playerId = 1;
inline bool AllInShowCardsMessage_PlayerAllIn::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllInShowCardsMessage_PlayerAllIn::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AllInShowCardsMessage_PlayerAllIn::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AllInShowCardsMessage_PlayerAllIn::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 AllInShowCardsMessage_PlayerAllIn::playerid() const {
  return playerid_;
}
inline void AllInShowCardsMessage_PlayerAllIn::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
}

// required uint32 allInCard1 = 2;
inline bool AllInShowCardsMessage_PlayerAllIn::has_allincard1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AllInShowCardsMessage_PlayerAllIn::set_has_allincard1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AllInShowCardsMessage_PlayerAllIn::clear_has_allincard1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AllInShowCardsMessage_PlayerAllIn::clear_allincard1() {
  allincard1_ = 0u;
  clear_has_allincard1();
}
inline ::google::protobuf::uint32 AllInShowCardsMessage_PlayerAllIn::allincard1() const {
  return allincard1_;
}
inline void AllInShowCardsMessage_PlayerAllIn::set_allincard1(::google::protobuf::uint32 value) {
  set_has_allincard1();
  allincard1_ = value;
}

// required uint32 allInCard2 = 3;
inline bool AllInShowCardsMessage_PlayerAllIn::has_allincard2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AllInShowCardsMessage_PlayerAllIn::set_has_allincard2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AllInShowCardsMessage_PlayerAllIn::clear_has_allincard2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AllInShowCardsMessage_PlayerAllIn::clear_allincard2() {
  allincard2_ = 0u;
  clear_has_allincard2();
}
inline ::google::protobuf::uint32 AllInShowCardsMessage_PlayerAllIn::allincard2() const {
  return allincard2_;
}
inline void AllInShowCardsMessage_PlayerAllIn::set_allincard2(::google::protobuf::uint32 value) {
  set_has_allincard2();
  allincard2_ = value;
}

// -------------------------------------------------------------------

// AllInShowCardsMessage

// required uint32 gameId = 1;
inline bool AllInShowCardsMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllInShowCardsMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AllInShowCardsMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AllInShowCardsMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 AllInShowCardsMessage::gameid() const {
  return gameid_;
}
inline void AllInShowCardsMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// repeated .AllInShowCardsMessage.PlayerAllIn playersAllIn = 2;
inline int AllInShowCardsMessage::playersallin_size() const {
  return playersallin_.size();
}
inline void AllInShowCardsMessage::clear_playersallin() {
  playersallin_.Clear();
}
inline const ::AllInShowCardsMessage_PlayerAllIn& AllInShowCardsMessage::playersallin(int index) const {
  return playersallin_.Get(index);
}
inline ::AllInShowCardsMessage_PlayerAllIn* AllInShowCardsMessage::mutable_playersallin(int index) {
  return playersallin_.Mutable(index);
}
inline ::AllInShowCardsMessage_PlayerAllIn* AllInShowCardsMessage::add_playersallin() {
  return playersallin_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AllInShowCardsMessage_PlayerAllIn >&
AllInShowCardsMessage::playersallin() const {
  return playersallin_;
}
inline ::google::protobuf::RepeatedPtrField< ::AllInShowCardsMessage_PlayerAllIn >*
AllInShowCardsMessage::mutable_playersallin() {
  return &playersallin_;
}

// -------------------------------------------------------------------

// EndOfHandShowCardsMessage

// required uint32 gameId = 1;
inline bool EndOfHandShowCardsMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EndOfHandShowCardsMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EndOfHandShowCardsMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EndOfHandShowCardsMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 EndOfHandShowCardsMessage::gameid() const {
  return gameid_;
}
inline void EndOfHandShowCardsMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// repeated .PlayerResult playerResults = 2;
inline int EndOfHandShowCardsMessage::playerresults_size() const {
  return playerresults_.size();
}
inline void EndOfHandShowCardsMessage::clear_playerresults() {
  playerresults_.Clear();
}
inline const ::PlayerResult& EndOfHandShowCardsMessage::playerresults(int index) const {
  return playerresults_.Get(index);
}
inline ::PlayerResult* EndOfHandShowCardsMessage::mutable_playerresults(int index) {
  return playerresults_.Mutable(index);
}
inline ::PlayerResult* EndOfHandShowCardsMessage::add_playerresults() {
  return playerresults_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerResult >&
EndOfHandShowCardsMessage::playerresults() const {
  return playerresults_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerResult >*
EndOfHandShowCardsMessage::mutable_playerresults() {
  return &playerresults_;
}

// -------------------------------------------------------------------

// EndOfHandHideCardsMessage

// required uint32 gameId = 1;
inline bool EndOfHandHideCardsMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EndOfHandHideCardsMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EndOfHandHideCardsMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EndOfHandHideCardsMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 EndOfHandHideCardsMessage::gameid() const {
  return gameid_;
}
inline void EndOfHandHideCardsMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 playerId = 2;
inline bool EndOfHandHideCardsMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EndOfHandHideCardsMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EndOfHandHideCardsMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EndOfHandHideCardsMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 EndOfHandHideCardsMessage::playerid() const {
  return playerid_;
}
inline void EndOfHandHideCardsMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
}

// required uint32 moneyWon = 3;
inline bool EndOfHandHideCardsMessage::has_moneywon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EndOfHandHideCardsMessage::set_has_moneywon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EndOfHandHideCardsMessage::clear_has_moneywon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EndOfHandHideCardsMessage::clear_moneywon() {
  moneywon_ = 0u;
  clear_has_moneywon();
}
inline ::google::protobuf::uint32 EndOfHandHideCardsMessage::moneywon() const {
  return moneywon_;
}
inline void EndOfHandHideCardsMessage::set_moneywon(::google::protobuf::uint32 value) {
  set_has_moneywon();
  moneywon_ = value;
}

// required uint32 playerMoney = 4;
inline bool EndOfHandHideCardsMessage::has_playermoney() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EndOfHandHideCardsMessage::set_has_playermoney() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EndOfHandHideCardsMessage::clear_has_playermoney() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EndOfHandHideCardsMessage::clear_playermoney() {
  playermoney_ = 0u;
  clear_has_playermoney();
}
inline ::google::protobuf::uint32 EndOfHandHideCardsMessage::playermoney() const {
  return playermoney_;
}
inline void EndOfHandHideCardsMessage::set_playermoney(::google::protobuf::uint32 value) {
  set_has_playermoney();
  playermoney_ = value;
}

// -------------------------------------------------------------------

// ShowMyCardsRequestMessage

// -------------------------------------------------------------------

// AfterHandShowCardsMessage

// required .PlayerResult playerResult = 1;
inline bool AfterHandShowCardsMessage::has_playerresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AfterHandShowCardsMessage::set_has_playerresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AfterHandShowCardsMessage::clear_has_playerresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AfterHandShowCardsMessage::clear_playerresult() {
  if (playerresult_ != NULL) playerresult_->::PlayerResult::Clear();
  clear_has_playerresult();
}
inline const ::PlayerResult& AfterHandShowCardsMessage::playerresult() const {
  return playerresult_ != NULL ? *playerresult_ : *default_instance_->playerresult_;
}
inline ::PlayerResult* AfterHandShowCardsMessage::mutable_playerresult() {
  set_has_playerresult();
  if (playerresult_ == NULL) playerresult_ = new ::PlayerResult;
  return playerresult_;
}
inline ::PlayerResult* AfterHandShowCardsMessage::release_playerresult() {
  clear_has_playerresult();
  ::PlayerResult* temp = playerresult_;
  playerresult_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// EndOfGameMessage

// required uint32 gameId = 1;
inline bool EndOfGameMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EndOfGameMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EndOfGameMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EndOfGameMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 EndOfGameMessage::gameid() const {
  return gameid_;
}
inline void EndOfGameMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 winnerPlayerId = 2;
inline bool EndOfGameMessage::has_winnerplayerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EndOfGameMessage::set_has_winnerplayerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EndOfGameMessage::clear_has_winnerplayerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EndOfGameMessage::clear_winnerplayerid() {
  winnerplayerid_ = 0u;
  clear_has_winnerplayerid();
}
inline ::google::protobuf::uint32 EndOfGameMessage::winnerplayerid() const {
  return winnerplayerid_;
}
inline void EndOfGameMessage::set_winnerplayerid(::google::protobuf::uint32 value) {
  set_has_winnerplayerid();
  winnerplayerid_ = value;
}

// -------------------------------------------------------------------

// PlayerIdChangedMessage

// required uint32 oldPlayerId = 1;
inline bool PlayerIdChangedMessage::has_oldplayerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerIdChangedMessage::set_has_oldplayerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerIdChangedMessage::clear_has_oldplayerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerIdChangedMessage::clear_oldplayerid() {
  oldplayerid_ = 0u;
  clear_has_oldplayerid();
}
inline ::google::protobuf::uint32 PlayerIdChangedMessage::oldplayerid() const {
  return oldplayerid_;
}
inline void PlayerIdChangedMessage::set_oldplayerid(::google::protobuf::uint32 value) {
  set_has_oldplayerid();
  oldplayerid_ = value;
}

// required uint32 newPlayerId = 2;
inline bool PlayerIdChangedMessage::has_newplayerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerIdChangedMessage::set_has_newplayerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerIdChangedMessage::clear_has_newplayerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerIdChangedMessage::clear_newplayerid() {
  newplayerid_ = 0u;
  clear_has_newplayerid();
}
inline ::google::protobuf::uint32 PlayerIdChangedMessage::newplayerid() const {
  return newplayerid_;
}
inline void PlayerIdChangedMessage::set_newplayerid(::google::protobuf::uint32 value) {
  set_has_newplayerid();
  newplayerid_ = value;
}

// -------------------------------------------------------------------

// AskKickPlayerMessage

// required uint32 gameId = 1;
inline bool AskKickPlayerMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AskKickPlayerMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AskKickPlayerMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AskKickPlayerMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 AskKickPlayerMessage::gameid() const {
  return gameid_;
}
inline void AskKickPlayerMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 playerId = 2;
inline bool AskKickPlayerMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AskKickPlayerMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AskKickPlayerMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AskKickPlayerMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 AskKickPlayerMessage::playerid() const {
  return playerid_;
}
inline void AskKickPlayerMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
}

// -------------------------------------------------------------------

// AskKickDeniedMessage

// required uint32 gameId = 1;
inline bool AskKickDeniedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AskKickDeniedMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AskKickDeniedMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AskKickDeniedMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 AskKickDeniedMessage::gameid() const {
  return gameid_;
}
inline void AskKickDeniedMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 playerId = 2;
inline bool AskKickDeniedMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AskKickDeniedMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AskKickDeniedMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AskKickDeniedMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 AskKickDeniedMessage::playerid() const {
  return playerid_;
}
inline void AskKickDeniedMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
}

// required .AskKickDeniedMessage.KickDeniedReason kickDeniedReason = 3;
inline bool AskKickDeniedMessage::has_kickdeniedreason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AskKickDeniedMessage::set_has_kickdeniedreason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AskKickDeniedMessage::clear_has_kickdeniedreason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AskKickDeniedMessage::clear_kickdeniedreason() {
  kickdeniedreason_ = 0;
  clear_has_kickdeniedreason();
}
inline ::AskKickDeniedMessage_KickDeniedReason AskKickDeniedMessage::kickdeniedreason() const {
  return static_cast< ::AskKickDeniedMessage_KickDeniedReason >(kickdeniedreason_);
}
inline void AskKickDeniedMessage::set_kickdeniedreason(::AskKickDeniedMessage_KickDeniedReason value) {
  GOOGLE_DCHECK(::AskKickDeniedMessage_KickDeniedReason_IsValid(value));
  set_has_kickdeniedreason();
  kickdeniedreason_ = value;
}

// -------------------------------------------------------------------

// StartKickPetitionMessage

// required uint32 gameId = 1;
inline bool StartKickPetitionMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartKickPetitionMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartKickPetitionMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartKickPetitionMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 StartKickPetitionMessage::gameid() const {
  return gameid_;
}
inline void StartKickPetitionMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 petitionId = 2;
inline bool StartKickPetitionMessage::has_petitionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartKickPetitionMessage::set_has_petitionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartKickPetitionMessage::clear_has_petitionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartKickPetitionMessage::clear_petitionid() {
  petitionid_ = 0u;
  clear_has_petitionid();
}
inline ::google::protobuf::uint32 StartKickPetitionMessage::petitionid() const {
  return petitionid_;
}
inline void StartKickPetitionMessage::set_petitionid(::google::protobuf::uint32 value) {
  set_has_petitionid();
  petitionid_ = value;
}

// required uint32 proposingPlayerId = 3;
inline bool StartKickPetitionMessage::has_proposingplayerid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartKickPetitionMessage::set_has_proposingplayerid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StartKickPetitionMessage::clear_has_proposingplayerid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StartKickPetitionMessage::clear_proposingplayerid() {
  proposingplayerid_ = 0u;
  clear_has_proposingplayerid();
}
inline ::google::protobuf::uint32 StartKickPetitionMessage::proposingplayerid() const {
  return proposingplayerid_;
}
inline void StartKickPetitionMessage::set_proposingplayerid(::google::protobuf::uint32 value) {
  set_has_proposingplayerid();
  proposingplayerid_ = value;
}

// required uint32 kickPlayerId = 4;
inline bool StartKickPetitionMessage::has_kickplayerid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StartKickPetitionMessage::set_has_kickplayerid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StartKickPetitionMessage::clear_has_kickplayerid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StartKickPetitionMessage::clear_kickplayerid() {
  kickplayerid_ = 0u;
  clear_has_kickplayerid();
}
inline ::google::protobuf::uint32 StartKickPetitionMessage::kickplayerid() const {
  return kickplayerid_;
}
inline void StartKickPetitionMessage::set_kickplayerid(::google::protobuf::uint32 value) {
  set_has_kickplayerid();
  kickplayerid_ = value;
}

// required uint32 kickTimeoutSec = 5;
inline bool StartKickPetitionMessage::has_kicktimeoutsec() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StartKickPetitionMessage::set_has_kicktimeoutsec() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StartKickPetitionMessage::clear_has_kicktimeoutsec() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StartKickPetitionMessage::clear_kicktimeoutsec() {
  kicktimeoutsec_ = 0u;
  clear_has_kicktimeoutsec();
}
inline ::google::protobuf::uint32 StartKickPetitionMessage::kicktimeoutsec() const {
  return kicktimeoutsec_;
}
inline void StartKickPetitionMessage::set_kicktimeoutsec(::google::protobuf::uint32 value) {
  set_has_kicktimeoutsec();
  kicktimeoutsec_ = value;
}

// required uint32 numVotesNeededToKick = 6;
inline bool StartKickPetitionMessage::has_numvotesneededtokick() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StartKickPetitionMessage::set_has_numvotesneededtokick() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StartKickPetitionMessage::clear_has_numvotesneededtokick() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StartKickPetitionMessage::clear_numvotesneededtokick() {
  numvotesneededtokick_ = 0u;
  clear_has_numvotesneededtokick();
}
inline ::google::protobuf::uint32 StartKickPetitionMessage::numvotesneededtokick() const {
  return numvotesneededtokick_;
}
inline void StartKickPetitionMessage::set_numvotesneededtokick(::google::protobuf::uint32 value) {
  set_has_numvotesneededtokick();
  numvotesneededtokick_ = value;
}

// -------------------------------------------------------------------

// VoteKickRequestMessage

// required uint32 gameId = 1;
inline bool VoteKickRequestMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VoteKickRequestMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VoteKickRequestMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VoteKickRequestMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 VoteKickRequestMessage::gameid() const {
  return gameid_;
}
inline void VoteKickRequestMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 petitionId = 2;
inline bool VoteKickRequestMessage::has_petitionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VoteKickRequestMessage::set_has_petitionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VoteKickRequestMessage::clear_has_petitionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VoteKickRequestMessage::clear_petitionid() {
  petitionid_ = 0u;
  clear_has_petitionid();
}
inline ::google::protobuf::uint32 VoteKickRequestMessage::petitionid() const {
  return petitionid_;
}
inline void VoteKickRequestMessage::set_petitionid(::google::protobuf::uint32 value) {
  set_has_petitionid();
  petitionid_ = value;
}

// required bool voteKick = 3;
inline bool VoteKickRequestMessage::has_votekick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VoteKickRequestMessage::set_has_votekick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VoteKickRequestMessage::clear_has_votekick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VoteKickRequestMessage::clear_votekick() {
  votekick_ = false;
  clear_has_votekick();
}
inline bool VoteKickRequestMessage::votekick() const {
  return votekick_;
}
inline void VoteKickRequestMessage::set_votekick(bool value) {
  set_has_votekick();
  votekick_ = value;
}

// -------------------------------------------------------------------

// VoteKickReplyMessage

// required uint32 gameId = 1;
inline bool VoteKickReplyMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VoteKickReplyMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VoteKickReplyMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VoteKickReplyMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 VoteKickReplyMessage::gameid() const {
  return gameid_;
}
inline void VoteKickReplyMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 petitionId = 2;
inline bool VoteKickReplyMessage::has_petitionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VoteKickReplyMessage::set_has_petitionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VoteKickReplyMessage::clear_has_petitionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VoteKickReplyMessage::clear_petitionid() {
  petitionid_ = 0u;
  clear_has_petitionid();
}
inline ::google::protobuf::uint32 VoteKickReplyMessage::petitionid() const {
  return petitionid_;
}
inline void VoteKickReplyMessage::set_petitionid(::google::protobuf::uint32 value) {
  set_has_petitionid();
  petitionid_ = value;
}

// required .VoteKickReplyMessage.VoteKickReplyType voteKickReplyType = 3;
inline bool VoteKickReplyMessage::has_votekickreplytype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VoteKickReplyMessage::set_has_votekickreplytype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VoteKickReplyMessage::clear_has_votekickreplytype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VoteKickReplyMessage::clear_votekickreplytype() {
  votekickreplytype_ = 0;
  clear_has_votekickreplytype();
}
inline ::VoteKickReplyMessage_VoteKickReplyType VoteKickReplyMessage::votekickreplytype() const {
  return static_cast< ::VoteKickReplyMessage_VoteKickReplyType >(votekickreplytype_);
}
inline void VoteKickReplyMessage::set_votekickreplytype(::VoteKickReplyMessage_VoteKickReplyType value) {
  GOOGLE_DCHECK(::VoteKickReplyMessage_VoteKickReplyType_IsValid(value));
  set_has_votekickreplytype();
  votekickreplytype_ = value;
}

// -------------------------------------------------------------------

// KickPetitionUpdateMessage

// required uint32 gameId = 1;
inline bool KickPetitionUpdateMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KickPetitionUpdateMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KickPetitionUpdateMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KickPetitionUpdateMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 KickPetitionUpdateMessage::gameid() const {
  return gameid_;
}
inline void KickPetitionUpdateMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 petitionId = 2;
inline bool KickPetitionUpdateMessage::has_petitionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KickPetitionUpdateMessage::set_has_petitionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KickPetitionUpdateMessage::clear_has_petitionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KickPetitionUpdateMessage::clear_petitionid() {
  petitionid_ = 0u;
  clear_has_petitionid();
}
inline ::google::protobuf::uint32 KickPetitionUpdateMessage::petitionid() const {
  return petitionid_;
}
inline void KickPetitionUpdateMessage::set_petitionid(::google::protobuf::uint32 value) {
  set_has_petitionid();
  petitionid_ = value;
}

// required uint32 numVotesAgainstKicking = 3;
inline bool KickPetitionUpdateMessage::has_numvotesagainstkicking() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KickPetitionUpdateMessage::set_has_numvotesagainstkicking() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KickPetitionUpdateMessage::clear_has_numvotesagainstkicking() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KickPetitionUpdateMessage::clear_numvotesagainstkicking() {
  numvotesagainstkicking_ = 0u;
  clear_has_numvotesagainstkicking();
}
inline ::google::protobuf::uint32 KickPetitionUpdateMessage::numvotesagainstkicking() const {
  return numvotesagainstkicking_;
}
inline void KickPetitionUpdateMessage::set_numvotesagainstkicking(::google::protobuf::uint32 value) {
  set_has_numvotesagainstkicking();
  numvotesagainstkicking_ = value;
}

// required uint32 numVotesInFavourOfKicking = 4;
inline bool KickPetitionUpdateMessage::has_numvotesinfavourofkicking() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KickPetitionUpdateMessage::set_has_numvotesinfavourofkicking() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KickPetitionUpdateMessage::clear_has_numvotesinfavourofkicking() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KickPetitionUpdateMessage::clear_numvotesinfavourofkicking() {
  numvotesinfavourofkicking_ = 0u;
  clear_has_numvotesinfavourofkicking();
}
inline ::google::protobuf::uint32 KickPetitionUpdateMessage::numvotesinfavourofkicking() const {
  return numvotesinfavourofkicking_;
}
inline void KickPetitionUpdateMessage::set_numvotesinfavourofkicking(::google::protobuf::uint32 value) {
  set_has_numvotesinfavourofkicking();
  numvotesinfavourofkicking_ = value;
}

// required uint32 numVotesNeededToKick = 5;
inline bool KickPetitionUpdateMessage::has_numvotesneededtokick() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void KickPetitionUpdateMessage::set_has_numvotesneededtokick() {
  _has_bits_[0] |= 0x00000010u;
}
inline void KickPetitionUpdateMessage::clear_has_numvotesneededtokick() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void KickPetitionUpdateMessage::clear_numvotesneededtokick() {
  numvotesneededtokick_ = 0u;
  clear_has_numvotesneededtokick();
}
inline ::google::protobuf::uint32 KickPetitionUpdateMessage::numvotesneededtokick() const {
  return numvotesneededtokick_;
}
inline void KickPetitionUpdateMessage::set_numvotesneededtokick(::google::protobuf::uint32 value) {
  set_has_numvotesneededtokick();
  numvotesneededtokick_ = value;
}

// -------------------------------------------------------------------

// EndKickPetitionMessage

// required uint32 gameId = 1;
inline bool EndKickPetitionMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EndKickPetitionMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EndKickPetitionMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EndKickPetitionMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 EndKickPetitionMessage::gameid() const {
  return gameid_;
}
inline void EndKickPetitionMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required uint32 petitionId = 2;
inline bool EndKickPetitionMessage::has_petitionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EndKickPetitionMessage::set_has_petitionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EndKickPetitionMessage::clear_has_petitionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EndKickPetitionMessage::clear_petitionid() {
  petitionid_ = 0u;
  clear_has_petitionid();
}
inline ::google::protobuf::uint32 EndKickPetitionMessage::petitionid() const {
  return petitionid_;
}
inline void EndKickPetitionMessage::set_petitionid(::google::protobuf::uint32 value) {
  set_has_petitionid();
  petitionid_ = value;
}

// required uint32 numVotesAgainstKicking = 3;
inline bool EndKickPetitionMessage::has_numvotesagainstkicking() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EndKickPetitionMessage::set_has_numvotesagainstkicking() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EndKickPetitionMessage::clear_has_numvotesagainstkicking() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EndKickPetitionMessage::clear_numvotesagainstkicking() {
  numvotesagainstkicking_ = 0u;
  clear_has_numvotesagainstkicking();
}
inline ::google::protobuf::uint32 EndKickPetitionMessage::numvotesagainstkicking() const {
  return numvotesagainstkicking_;
}
inline void EndKickPetitionMessage::set_numvotesagainstkicking(::google::protobuf::uint32 value) {
  set_has_numvotesagainstkicking();
  numvotesagainstkicking_ = value;
}

// required uint32 numVotesInFavourOfKicking = 4;
inline bool EndKickPetitionMessage::has_numvotesinfavourofkicking() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EndKickPetitionMessage::set_has_numvotesinfavourofkicking() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EndKickPetitionMessage::clear_has_numvotesinfavourofkicking() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EndKickPetitionMessage::clear_numvotesinfavourofkicking() {
  numvotesinfavourofkicking_ = 0u;
  clear_has_numvotesinfavourofkicking();
}
inline ::google::protobuf::uint32 EndKickPetitionMessage::numvotesinfavourofkicking() const {
  return numvotesinfavourofkicking_;
}
inline void EndKickPetitionMessage::set_numvotesinfavourofkicking(::google::protobuf::uint32 value) {
  set_has_numvotesinfavourofkicking();
  numvotesinfavourofkicking_ = value;
}

// required uint32 resultPlayerKicked = 5;
inline bool EndKickPetitionMessage::has_resultplayerkicked() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EndKickPetitionMessage::set_has_resultplayerkicked() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EndKickPetitionMessage::clear_has_resultplayerkicked() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EndKickPetitionMessage::clear_resultplayerkicked() {
  resultplayerkicked_ = 0u;
  clear_has_resultplayerkicked();
}
inline ::google::protobuf::uint32 EndKickPetitionMessage::resultplayerkicked() const {
  return resultplayerkicked_;
}
inline void EndKickPetitionMessage::set_resultplayerkicked(::google::protobuf::uint32 value) {
  set_has_resultplayerkicked();
  resultplayerkicked_ = value;
}

// required .EndKickPetitionMessage.PetitionEndReason petitionEndReason = 6;
inline bool EndKickPetitionMessage::has_petitionendreason() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EndKickPetitionMessage::set_has_petitionendreason() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EndKickPetitionMessage::clear_has_petitionendreason() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EndKickPetitionMessage::clear_petitionendreason() {
  petitionendreason_ = 0;
  clear_has_petitionendreason();
}
inline ::EndKickPetitionMessage_PetitionEndReason EndKickPetitionMessage::petitionendreason() const {
  return static_cast< ::EndKickPetitionMessage_PetitionEndReason >(petitionendreason_);
}
inline void EndKickPetitionMessage::set_petitionendreason(::EndKickPetitionMessage_PetitionEndReason value) {
  GOOGLE_DCHECK(::EndKickPetitionMessage_PetitionEndReason_IsValid(value));
  set_has_petitionendreason();
  petitionendreason_ = value;
}

// -------------------------------------------------------------------

// StatisticsMessage_StatisticsData

// required .StatisticsMessage.StatisticsData.StatisticsType statisticsType = 1;
inline bool StatisticsMessage_StatisticsData::has_statisticstype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatisticsMessage_StatisticsData::set_has_statisticstype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatisticsMessage_StatisticsData::clear_has_statisticstype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatisticsMessage_StatisticsData::clear_statisticstype() {
  statisticstype_ = 1;
  clear_has_statisticstype();
}
inline ::StatisticsMessage_StatisticsData_StatisticsType StatisticsMessage_StatisticsData::statisticstype() const {
  return static_cast< ::StatisticsMessage_StatisticsData_StatisticsType >(statisticstype_);
}
inline void StatisticsMessage_StatisticsData::set_statisticstype(::StatisticsMessage_StatisticsData_StatisticsType value) {
  GOOGLE_DCHECK(::StatisticsMessage_StatisticsData_StatisticsType_IsValid(value));
  set_has_statisticstype();
  statisticstype_ = value;
}

// required uint32 statisticsValue = 2;
inline bool StatisticsMessage_StatisticsData::has_statisticsvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatisticsMessage_StatisticsData::set_has_statisticsvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StatisticsMessage_StatisticsData::clear_has_statisticsvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StatisticsMessage_StatisticsData::clear_statisticsvalue() {
  statisticsvalue_ = 0u;
  clear_has_statisticsvalue();
}
inline ::google::protobuf::uint32 StatisticsMessage_StatisticsData::statisticsvalue() const {
  return statisticsvalue_;
}
inline void StatisticsMessage_StatisticsData::set_statisticsvalue(::google::protobuf::uint32 value) {
  set_has_statisticsvalue();
  statisticsvalue_ = value;
}

// -------------------------------------------------------------------

// StatisticsMessage

// repeated .StatisticsMessage.StatisticsData statisticsData = 1;
inline int StatisticsMessage::statisticsdata_size() const {
  return statisticsdata_.size();
}
inline void StatisticsMessage::clear_statisticsdata() {
  statisticsdata_.Clear();
}
inline const ::StatisticsMessage_StatisticsData& StatisticsMessage::statisticsdata(int index) const {
  return statisticsdata_.Get(index);
}
inline ::StatisticsMessage_StatisticsData* StatisticsMessage::mutable_statisticsdata(int index) {
  return statisticsdata_.Mutable(index);
}
inline ::StatisticsMessage_StatisticsData* StatisticsMessage::add_statisticsdata() {
  return statisticsdata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::StatisticsMessage_StatisticsData >&
StatisticsMessage::statisticsdata() const {
  return statisticsdata_;
}
inline ::google::protobuf::RepeatedPtrField< ::StatisticsMessage_StatisticsData >*
StatisticsMessage::mutable_statisticsdata() {
  return &statisticsdata_;
}

// -------------------------------------------------------------------

// ChatRequestMessage

// optional uint32 targetGameId = 1;
inline bool ChatRequestMessage::has_targetgameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatRequestMessage::set_has_targetgameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatRequestMessage::clear_has_targetgameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatRequestMessage::clear_targetgameid() {
  targetgameid_ = 0u;
  clear_has_targetgameid();
}
inline ::google::protobuf::uint32 ChatRequestMessage::targetgameid() const {
  return targetgameid_;
}
inline void ChatRequestMessage::set_targetgameid(::google::protobuf::uint32 value) {
  set_has_targetgameid();
  targetgameid_ = value;
}

// optional uint32 targetPlayerId = 2;
inline bool ChatRequestMessage::has_targetplayerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatRequestMessage::set_has_targetplayerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatRequestMessage::clear_has_targetplayerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatRequestMessage::clear_targetplayerid() {
  targetplayerid_ = 0u;
  clear_has_targetplayerid();
}
inline ::google::protobuf::uint32 ChatRequestMessage::targetplayerid() const {
  return targetplayerid_;
}
inline void ChatRequestMessage::set_targetplayerid(::google::protobuf::uint32 value) {
  set_has_targetplayerid();
  targetplayerid_ = value;
}

// required string chatText = 3;
inline bool ChatRequestMessage::has_chattext() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatRequestMessage::set_has_chattext() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatRequestMessage::clear_has_chattext() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatRequestMessage::clear_chattext() {
  if (chattext_ != &::google::protobuf::internal::kEmptyString) {
    chattext_->clear();
  }
  clear_has_chattext();
}
inline const ::std::string& ChatRequestMessage::chattext() const {
  return *chattext_;
}
inline void ChatRequestMessage::set_chattext(const ::std::string& value) {
  set_has_chattext();
  if (chattext_ == &::google::protobuf::internal::kEmptyString) {
    chattext_ = new ::std::string;
  }
  chattext_->assign(value);
}
inline void ChatRequestMessage::set_chattext(const char* value) {
  set_has_chattext();
  if (chattext_ == &::google::protobuf::internal::kEmptyString) {
    chattext_ = new ::std::string;
  }
  chattext_->assign(value);
}
inline void ChatRequestMessage::set_chattext(const char* value, size_t size) {
  set_has_chattext();
  if (chattext_ == &::google::protobuf::internal::kEmptyString) {
    chattext_ = new ::std::string;
  }
  chattext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatRequestMessage::mutable_chattext() {
  set_has_chattext();
  if (chattext_ == &::google::protobuf::internal::kEmptyString) {
    chattext_ = new ::std::string;
  }
  return chattext_;
}
inline ::std::string* ChatRequestMessage::release_chattext() {
  clear_has_chattext();
  if (chattext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chattext_;
    chattext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ChatMessage

// optional uint32 gameId = 1;
inline bool ChatMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 ChatMessage::gameid() const {
  return gameid_;
}
inline void ChatMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional uint32 playerId = 2;
inline bool ChatMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 ChatMessage::playerid() const {
  return playerid_;
}
inline void ChatMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
}

// required .ChatMessage.ChatType chatType = 3;
inline bool ChatMessage::has_chattype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatMessage::set_has_chattype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatMessage::clear_has_chattype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatMessage::clear_chattype() {
  chattype_ = 0;
  clear_has_chattype();
}
inline ::ChatMessage_ChatType ChatMessage::chattype() const {
  return static_cast< ::ChatMessage_ChatType >(chattype_);
}
inline void ChatMessage::set_chattype(::ChatMessage_ChatType value) {
  GOOGLE_DCHECK(::ChatMessage_ChatType_IsValid(value));
  set_has_chattype();
  chattype_ = value;
}

// required string chatText = 4;
inline bool ChatMessage::has_chattext() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChatMessage::set_has_chattext() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChatMessage::clear_has_chattext() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChatMessage::clear_chattext() {
  if (chattext_ != &::google::protobuf::internal::kEmptyString) {
    chattext_->clear();
  }
  clear_has_chattext();
}
inline const ::std::string& ChatMessage::chattext() const {
  return *chattext_;
}
inline void ChatMessage::set_chattext(const ::std::string& value) {
  set_has_chattext();
  if (chattext_ == &::google::protobuf::internal::kEmptyString) {
    chattext_ = new ::std::string;
  }
  chattext_->assign(value);
}
inline void ChatMessage::set_chattext(const char* value) {
  set_has_chattext();
  if (chattext_ == &::google::protobuf::internal::kEmptyString) {
    chattext_ = new ::std::string;
  }
  chattext_->assign(value);
}
inline void ChatMessage::set_chattext(const char* value, size_t size) {
  set_has_chattext();
  if (chattext_ == &::google::protobuf::internal::kEmptyString) {
    chattext_ = new ::std::string;
  }
  chattext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatMessage::mutable_chattext() {
  set_has_chattext();
  if (chattext_ == &::google::protobuf::internal::kEmptyString) {
    chattext_ = new ::std::string;
  }
  return chattext_;
}
inline ::std::string* ChatMessage::release_chattext() {
  clear_has_chattext();
  if (chattext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chattext_;
    chattext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ChatRejectMessage

// required string chatText = 1;
inline bool ChatRejectMessage::has_chattext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatRejectMessage::set_has_chattext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatRejectMessage::clear_has_chattext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatRejectMessage::clear_chattext() {
  if (chattext_ != &::google::protobuf::internal::kEmptyString) {
    chattext_->clear();
  }
  clear_has_chattext();
}
inline const ::std::string& ChatRejectMessage::chattext() const {
  return *chattext_;
}
inline void ChatRejectMessage::set_chattext(const ::std::string& value) {
  set_has_chattext();
  if (chattext_ == &::google::protobuf::internal::kEmptyString) {
    chattext_ = new ::std::string;
  }
  chattext_->assign(value);
}
inline void ChatRejectMessage::set_chattext(const char* value) {
  set_has_chattext();
  if (chattext_ == &::google::protobuf::internal::kEmptyString) {
    chattext_ = new ::std::string;
  }
  chattext_->assign(value);
}
inline void ChatRejectMessage::set_chattext(const char* value, size_t size) {
  set_has_chattext();
  if (chattext_ == &::google::protobuf::internal::kEmptyString) {
    chattext_ = new ::std::string;
  }
  chattext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatRejectMessage::mutable_chattext() {
  set_has_chattext();
  if (chattext_ == &::google::protobuf::internal::kEmptyString) {
    chattext_ = new ::std::string;
  }
  return chattext_;
}
inline ::std::string* ChatRejectMessage::release_chattext() {
  clear_has_chattext();
  if (chattext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chattext_;
    chattext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// DialogMessage

// required string notificationText = 1;
inline bool DialogMessage::has_notificationtext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DialogMessage::set_has_notificationtext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DialogMessage::clear_has_notificationtext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DialogMessage::clear_notificationtext() {
  if (notificationtext_ != &::google::protobuf::internal::kEmptyString) {
    notificationtext_->clear();
  }
  clear_has_notificationtext();
}
inline const ::std::string& DialogMessage::notificationtext() const {
  return *notificationtext_;
}
inline void DialogMessage::set_notificationtext(const ::std::string& value) {
  set_has_notificationtext();
  if (notificationtext_ == &::google::protobuf::internal::kEmptyString) {
    notificationtext_ = new ::std::string;
  }
  notificationtext_->assign(value);
}
inline void DialogMessage::set_notificationtext(const char* value) {
  set_has_notificationtext();
  if (notificationtext_ == &::google::protobuf::internal::kEmptyString) {
    notificationtext_ = new ::std::string;
  }
  notificationtext_->assign(value);
}
inline void DialogMessage::set_notificationtext(const char* value, size_t size) {
  set_has_notificationtext();
  if (notificationtext_ == &::google::protobuf::internal::kEmptyString) {
    notificationtext_ = new ::std::string;
  }
  notificationtext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DialogMessage::mutable_notificationtext() {
  set_has_notificationtext();
  if (notificationtext_ == &::google::protobuf::internal::kEmptyString) {
    notificationtext_ = new ::std::string;
  }
  return notificationtext_;
}
inline ::std::string* DialogMessage::release_notificationtext() {
  clear_has_notificationtext();
  if (notificationtext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notificationtext_;
    notificationtext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// TimeoutWarningMessage

// required .TimeoutWarningMessage.TimeoutReason timeoutReason = 1;
inline bool TimeoutWarningMessage::has_timeoutreason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeoutWarningMessage::set_has_timeoutreason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeoutWarningMessage::clear_has_timeoutreason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeoutWarningMessage::clear_timeoutreason() {
  timeoutreason_ = 0;
  clear_has_timeoutreason();
}
inline ::TimeoutWarningMessage_TimeoutReason TimeoutWarningMessage::timeoutreason() const {
  return static_cast< ::TimeoutWarningMessage_TimeoutReason >(timeoutreason_);
}
inline void TimeoutWarningMessage::set_timeoutreason(::TimeoutWarningMessage_TimeoutReason value) {
  GOOGLE_DCHECK(::TimeoutWarningMessage_TimeoutReason_IsValid(value));
  set_has_timeoutreason();
  timeoutreason_ = value;
}

// required uint32 remainingSeconds = 2;
inline bool TimeoutWarningMessage::has_remainingseconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeoutWarningMessage::set_has_remainingseconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeoutWarningMessage::clear_has_remainingseconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeoutWarningMessage::clear_remainingseconds() {
  remainingseconds_ = 0u;
  clear_has_remainingseconds();
}
inline ::google::protobuf::uint32 TimeoutWarningMessage::remainingseconds() const {
  return remainingseconds_;
}
inline void TimeoutWarningMessage::set_remainingseconds(::google::protobuf::uint32 value) {
  set_has_remainingseconds();
  remainingseconds_ = value;
}

// -------------------------------------------------------------------

// ResetTimeoutMessage

// -------------------------------------------------------------------

// ReportAvatarMessage

// required uint32 reportedPlayerId = 1;
inline bool ReportAvatarMessage::has_reportedplayerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReportAvatarMessage::set_has_reportedplayerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReportAvatarMessage::clear_has_reportedplayerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReportAvatarMessage::clear_reportedplayerid() {
  reportedplayerid_ = 0u;
  clear_has_reportedplayerid();
}
inline ::google::protobuf::uint32 ReportAvatarMessage::reportedplayerid() const {
  return reportedplayerid_;
}
inline void ReportAvatarMessage::set_reportedplayerid(::google::protobuf::uint32 value) {
  set_has_reportedplayerid();
  reportedplayerid_ = value;
}

// required bytes reportedAvatarHash = 2;
inline bool ReportAvatarMessage::has_reportedavatarhash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReportAvatarMessage::set_has_reportedavatarhash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReportAvatarMessage::clear_has_reportedavatarhash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReportAvatarMessage::clear_reportedavatarhash() {
  if (reportedavatarhash_ != &::google::protobuf::internal::kEmptyString) {
    reportedavatarhash_->clear();
  }
  clear_has_reportedavatarhash();
}
inline const ::std::string& ReportAvatarMessage::reportedavatarhash() const {
  return *reportedavatarhash_;
}
inline void ReportAvatarMessage::set_reportedavatarhash(const ::std::string& value) {
  set_has_reportedavatarhash();
  if (reportedavatarhash_ == &::google::protobuf::internal::kEmptyString) {
    reportedavatarhash_ = new ::std::string;
  }
  reportedavatarhash_->assign(value);
}
inline void ReportAvatarMessage::set_reportedavatarhash(const char* value) {
  set_has_reportedavatarhash();
  if (reportedavatarhash_ == &::google::protobuf::internal::kEmptyString) {
    reportedavatarhash_ = new ::std::string;
  }
  reportedavatarhash_->assign(value);
}
inline void ReportAvatarMessage::set_reportedavatarhash(const void* value, size_t size) {
  set_has_reportedavatarhash();
  if (reportedavatarhash_ == &::google::protobuf::internal::kEmptyString) {
    reportedavatarhash_ = new ::std::string;
  }
  reportedavatarhash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReportAvatarMessage::mutable_reportedavatarhash() {
  set_has_reportedavatarhash();
  if (reportedavatarhash_ == &::google::protobuf::internal::kEmptyString) {
    reportedavatarhash_ = new ::std::string;
  }
  return reportedavatarhash_;
}
inline ::std::string* ReportAvatarMessage::release_reportedavatarhash() {
  clear_has_reportedavatarhash();
  if (reportedavatarhash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reportedavatarhash_;
    reportedavatarhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ReportAvatarAckMessage

// required uint32 reportedPlayerId = 1;
inline bool ReportAvatarAckMessage::has_reportedplayerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReportAvatarAckMessage::set_has_reportedplayerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReportAvatarAckMessage::clear_has_reportedplayerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReportAvatarAckMessage::clear_reportedplayerid() {
  reportedplayerid_ = 0u;
  clear_has_reportedplayerid();
}
inline ::google::protobuf::uint32 ReportAvatarAckMessage::reportedplayerid() const {
  return reportedplayerid_;
}
inline void ReportAvatarAckMessage::set_reportedplayerid(::google::protobuf::uint32 value) {
  set_has_reportedplayerid();
  reportedplayerid_ = value;
}

// required .ReportAvatarAckMessage.ReportAvatarResult reportAvatarResult = 2;
inline bool ReportAvatarAckMessage::has_reportavatarresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReportAvatarAckMessage::set_has_reportavatarresult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReportAvatarAckMessage::clear_has_reportavatarresult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReportAvatarAckMessage::clear_reportavatarresult() {
  reportavatarresult_ = 0;
  clear_has_reportavatarresult();
}
inline ::ReportAvatarAckMessage_ReportAvatarResult ReportAvatarAckMessage::reportavatarresult() const {
  return static_cast< ::ReportAvatarAckMessage_ReportAvatarResult >(reportavatarresult_);
}
inline void ReportAvatarAckMessage::set_reportavatarresult(::ReportAvatarAckMessage_ReportAvatarResult value) {
  GOOGLE_DCHECK(::ReportAvatarAckMessage_ReportAvatarResult_IsValid(value));
  set_has_reportavatarresult();
  reportavatarresult_ = value;
}

// -------------------------------------------------------------------

// ReportGameMessage

// required uint32 reportedGameId = 1;
inline bool ReportGameMessage::has_reportedgameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReportGameMessage::set_has_reportedgameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReportGameMessage::clear_has_reportedgameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReportGameMessage::clear_reportedgameid() {
  reportedgameid_ = 0u;
  clear_has_reportedgameid();
}
inline ::google::protobuf::uint32 ReportGameMessage::reportedgameid() const {
  return reportedgameid_;
}
inline void ReportGameMessage::set_reportedgameid(::google::protobuf::uint32 value) {
  set_has_reportedgameid();
  reportedgameid_ = value;
}

// -------------------------------------------------------------------

// ReportGameAckMessage

// required uint32 reportedGameId = 1;
inline bool ReportGameAckMessage::has_reportedgameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReportGameAckMessage::set_has_reportedgameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReportGameAckMessage::clear_has_reportedgameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReportGameAckMessage::clear_reportedgameid() {
  reportedgameid_ = 0u;
  clear_has_reportedgameid();
}
inline ::google::protobuf::uint32 ReportGameAckMessage::reportedgameid() const {
  return reportedgameid_;
}
inline void ReportGameAckMessage::set_reportedgameid(::google::protobuf::uint32 value) {
  set_has_reportedgameid();
  reportedgameid_ = value;
}

// required .ReportGameAckMessage.ReportGameResult reportGameResult = 2;
inline bool ReportGameAckMessage::has_reportgameresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReportGameAckMessage::set_has_reportgameresult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReportGameAckMessage::clear_has_reportgameresult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReportGameAckMessage::clear_reportgameresult() {
  reportgameresult_ = 0;
  clear_has_reportgameresult();
}
inline ::ReportGameAckMessage_ReportGameResult ReportGameAckMessage::reportgameresult() const {
  return static_cast< ::ReportGameAckMessage_ReportGameResult >(reportgameresult_);
}
inline void ReportGameAckMessage::set_reportgameresult(::ReportGameAckMessage_ReportGameResult value) {
  GOOGLE_DCHECK(::ReportGameAckMessage_ReportGameResult_IsValid(value));
  set_has_reportgameresult();
  reportgameresult_ = value;
}

// -------------------------------------------------------------------

// ErrorMessage

// required .ErrorMessage.ErrorReason errorReason = 1;
inline bool ErrorMessage::has_errorreason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ErrorMessage::set_has_errorreason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ErrorMessage::clear_has_errorreason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ErrorMessage::clear_errorreason() {
  errorreason_ = 0;
  clear_has_errorreason();
}
inline ::ErrorMessage_ErrorReason ErrorMessage::errorreason() const {
  return static_cast< ::ErrorMessage_ErrorReason >(errorreason_);
}
inline void ErrorMessage::set_errorreason(::ErrorMessage_ErrorReason value) {
  GOOGLE_DCHECK(::ErrorMessage_ErrorReason_IsValid(value));
  set_has_errorreason();
  errorreason_ = value;
}

// -------------------------------------------------------------------

// PokerTHMessage

// required .PokerTHMessage.PokerTHMessageType messageType = 1;
inline bool PokerTHMessage::has_messagetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PokerTHMessage::set_has_messagetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PokerTHMessage::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PokerTHMessage::clear_messagetype() {
  messagetype_ = 1;
  clear_has_messagetype();
}
inline ::PokerTHMessage_PokerTHMessageType PokerTHMessage::messagetype() const {
  return static_cast< ::PokerTHMessage_PokerTHMessageType >(messagetype_);
}
inline void PokerTHMessage::set_messagetype(::PokerTHMessage_PokerTHMessageType value) {
  GOOGLE_DCHECK(::PokerTHMessage_PokerTHMessageType_IsValid(value));
  set_has_messagetype();
  messagetype_ = value;
}

// optional .AnnounceMessage announceMessage = 2;
inline bool PokerTHMessage::has_announcemessage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PokerTHMessage::set_has_announcemessage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PokerTHMessage::clear_has_announcemessage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PokerTHMessage::clear_announcemessage() {
  if (announcemessage_ != NULL) announcemessage_->::AnnounceMessage::Clear();
  clear_has_announcemessage();
}
inline const ::AnnounceMessage& PokerTHMessage::announcemessage() const {
  return announcemessage_ != NULL ? *announcemessage_ : *default_instance_->announcemessage_;
}
inline ::AnnounceMessage* PokerTHMessage::mutable_announcemessage() {
  set_has_announcemessage();
  if (announcemessage_ == NULL) announcemessage_ = new ::AnnounceMessage;
  return announcemessage_;
}
inline ::AnnounceMessage* PokerTHMessage::release_announcemessage() {
  clear_has_announcemessage();
  ::AnnounceMessage* temp = announcemessage_;
  announcemessage_ = NULL;
  return temp;
}

// optional .InitMessage initMessage = 3;
inline bool PokerTHMessage::has_initmessage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PokerTHMessage::set_has_initmessage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PokerTHMessage::clear_has_initmessage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PokerTHMessage::clear_initmessage() {
  if (initmessage_ != NULL) initmessage_->::InitMessage::Clear();
  clear_has_initmessage();
}
inline const ::InitMessage& PokerTHMessage::initmessage() const {
  return initmessage_ != NULL ? *initmessage_ : *default_instance_->initmessage_;
}
inline ::InitMessage* PokerTHMessage::mutable_initmessage() {
  set_has_initmessage();
  if (initmessage_ == NULL) initmessage_ = new ::InitMessage;
  return initmessage_;
}
inline ::InitMessage* PokerTHMessage::release_initmessage() {
  clear_has_initmessage();
  ::InitMessage* temp = initmessage_;
  initmessage_ = NULL;
  return temp;
}

// optional .AuthServerChallengeMessage authServerChallengeMessage = 4;
inline bool PokerTHMessage::has_authserverchallengemessage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PokerTHMessage::set_has_authserverchallengemessage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PokerTHMessage::clear_has_authserverchallengemessage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PokerTHMessage::clear_authserverchallengemessage() {
  if (authserverchallengemessage_ != NULL) authserverchallengemessage_->::AuthServerChallengeMessage::Clear();
  clear_has_authserverchallengemessage();
}
inline const ::AuthServerChallengeMessage& PokerTHMessage::authserverchallengemessage() const {
  return authserverchallengemessage_ != NULL ? *authserverchallengemessage_ : *default_instance_->authserverchallengemessage_;
}
inline ::AuthServerChallengeMessage* PokerTHMessage::mutable_authserverchallengemessage() {
  set_has_authserverchallengemessage();
  if (authserverchallengemessage_ == NULL) authserverchallengemessage_ = new ::AuthServerChallengeMessage;
  return authserverchallengemessage_;
}
inline ::AuthServerChallengeMessage* PokerTHMessage::release_authserverchallengemessage() {
  clear_has_authserverchallengemessage();
  ::AuthServerChallengeMessage* temp = authserverchallengemessage_;
  authserverchallengemessage_ = NULL;
  return temp;
}

// optional .AuthClientResponseMessage authClientResponseMessage = 5;
inline bool PokerTHMessage::has_authclientresponsemessage() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PokerTHMessage::set_has_authclientresponsemessage() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PokerTHMessage::clear_has_authclientresponsemessage() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PokerTHMessage::clear_authclientresponsemessage() {
  if (authclientresponsemessage_ != NULL) authclientresponsemessage_->::AuthClientResponseMessage::Clear();
  clear_has_authclientresponsemessage();
}
inline const ::AuthClientResponseMessage& PokerTHMessage::authclientresponsemessage() const {
  return authclientresponsemessage_ != NULL ? *authclientresponsemessage_ : *default_instance_->authclientresponsemessage_;
}
inline ::AuthClientResponseMessage* PokerTHMessage::mutable_authclientresponsemessage() {
  set_has_authclientresponsemessage();
  if (authclientresponsemessage_ == NULL) authclientresponsemessage_ = new ::AuthClientResponseMessage;
  return authclientresponsemessage_;
}
inline ::AuthClientResponseMessage* PokerTHMessage::release_authclientresponsemessage() {
  clear_has_authclientresponsemessage();
  ::AuthClientResponseMessage* temp = authclientresponsemessage_;
  authclientresponsemessage_ = NULL;
  return temp;
}

// optional .AuthServerVerificationMessage authServerVerificationMessage = 6;
inline bool PokerTHMessage::has_authserververificationmessage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PokerTHMessage::set_has_authserververificationmessage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PokerTHMessage::clear_has_authserververificationmessage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PokerTHMessage::clear_authserververificationmessage() {
  if (authserververificationmessage_ != NULL) authserververificationmessage_->::AuthServerVerificationMessage::Clear();
  clear_has_authserververificationmessage();
}
inline const ::AuthServerVerificationMessage& PokerTHMessage::authserververificationmessage() const {
  return authserververificationmessage_ != NULL ? *authserververificationmessage_ : *default_instance_->authserververificationmessage_;
}
inline ::AuthServerVerificationMessage* PokerTHMessage::mutable_authserververificationmessage() {
  set_has_authserververificationmessage();
  if (authserververificationmessage_ == NULL) authserververificationmessage_ = new ::AuthServerVerificationMessage;
  return authserververificationmessage_;
}
inline ::AuthServerVerificationMessage* PokerTHMessage::release_authserververificationmessage() {
  clear_has_authserververificationmessage();
  ::AuthServerVerificationMessage* temp = authserververificationmessage_;
  authserververificationmessage_ = NULL;
  return temp;
}

// optional .InitAckMessage initAckMessage = 7;
inline bool PokerTHMessage::has_initackmessage() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PokerTHMessage::set_has_initackmessage() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PokerTHMessage::clear_has_initackmessage() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PokerTHMessage::clear_initackmessage() {
  if (initackmessage_ != NULL) initackmessage_->::InitAckMessage::Clear();
  clear_has_initackmessage();
}
inline const ::InitAckMessage& PokerTHMessage::initackmessage() const {
  return initackmessage_ != NULL ? *initackmessage_ : *default_instance_->initackmessage_;
}
inline ::InitAckMessage* PokerTHMessage::mutable_initackmessage() {
  set_has_initackmessage();
  if (initackmessage_ == NULL) initackmessage_ = new ::InitAckMessage;
  return initackmessage_;
}
inline ::InitAckMessage* PokerTHMessage::release_initackmessage() {
  clear_has_initackmessage();
  ::InitAckMessage* temp = initackmessage_;
  initackmessage_ = NULL;
  return temp;
}

// optional .AvatarRequestMessage avatarRequestMessage = 8;
inline bool PokerTHMessage::has_avatarrequestmessage() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PokerTHMessage::set_has_avatarrequestmessage() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PokerTHMessage::clear_has_avatarrequestmessage() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PokerTHMessage::clear_avatarrequestmessage() {
  if (avatarrequestmessage_ != NULL) avatarrequestmessage_->::AvatarRequestMessage::Clear();
  clear_has_avatarrequestmessage();
}
inline const ::AvatarRequestMessage& PokerTHMessage::avatarrequestmessage() const {
  return avatarrequestmessage_ != NULL ? *avatarrequestmessage_ : *default_instance_->avatarrequestmessage_;
}
inline ::AvatarRequestMessage* PokerTHMessage::mutable_avatarrequestmessage() {
  set_has_avatarrequestmessage();
  if (avatarrequestmessage_ == NULL) avatarrequestmessage_ = new ::AvatarRequestMessage;
  return avatarrequestmessage_;
}
inline ::AvatarRequestMessage* PokerTHMessage::release_avatarrequestmessage() {
  clear_has_avatarrequestmessage();
  ::AvatarRequestMessage* temp = avatarrequestmessage_;
  avatarrequestmessage_ = NULL;
  return temp;
}

// optional .AvatarHeaderMessage avatarHeaderMessage = 9;
inline bool PokerTHMessage::has_avatarheadermessage() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PokerTHMessage::set_has_avatarheadermessage() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PokerTHMessage::clear_has_avatarheadermessage() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PokerTHMessage::clear_avatarheadermessage() {
  if (avatarheadermessage_ != NULL) avatarheadermessage_->::AvatarHeaderMessage::Clear();
  clear_has_avatarheadermessage();
}
inline const ::AvatarHeaderMessage& PokerTHMessage::avatarheadermessage() const {
  return avatarheadermessage_ != NULL ? *avatarheadermessage_ : *default_instance_->avatarheadermessage_;
}
inline ::AvatarHeaderMessage* PokerTHMessage::mutable_avatarheadermessage() {
  set_has_avatarheadermessage();
  if (avatarheadermessage_ == NULL) avatarheadermessage_ = new ::AvatarHeaderMessage;
  return avatarheadermessage_;
}
inline ::AvatarHeaderMessage* PokerTHMessage::release_avatarheadermessage() {
  clear_has_avatarheadermessage();
  ::AvatarHeaderMessage* temp = avatarheadermessage_;
  avatarheadermessage_ = NULL;
  return temp;
}

// optional .AvatarDataMessage avatarDataMessage = 10;
inline bool PokerTHMessage::has_avatardatamessage() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PokerTHMessage::set_has_avatardatamessage() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PokerTHMessage::clear_has_avatardatamessage() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PokerTHMessage::clear_avatardatamessage() {
  if (avatardatamessage_ != NULL) avatardatamessage_->::AvatarDataMessage::Clear();
  clear_has_avatardatamessage();
}
inline const ::AvatarDataMessage& PokerTHMessage::avatardatamessage() const {
  return avatardatamessage_ != NULL ? *avatardatamessage_ : *default_instance_->avatardatamessage_;
}
inline ::AvatarDataMessage* PokerTHMessage::mutable_avatardatamessage() {
  set_has_avatardatamessage();
  if (avatardatamessage_ == NULL) avatardatamessage_ = new ::AvatarDataMessage;
  return avatardatamessage_;
}
inline ::AvatarDataMessage* PokerTHMessage::release_avatardatamessage() {
  clear_has_avatardatamessage();
  ::AvatarDataMessage* temp = avatardatamessage_;
  avatardatamessage_ = NULL;
  return temp;
}

// optional .AvatarEndMessage avatarEndMessage = 11;
inline bool PokerTHMessage::has_avatarendmessage() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PokerTHMessage::set_has_avatarendmessage() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PokerTHMessage::clear_has_avatarendmessage() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PokerTHMessage::clear_avatarendmessage() {
  if (avatarendmessage_ != NULL) avatarendmessage_->::AvatarEndMessage::Clear();
  clear_has_avatarendmessage();
}
inline const ::AvatarEndMessage& PokerTHMessage::avatarendmessage() const {
  return avatarendmessage_ != NULL ? *avatarendmessage_ : *default_instance_->avatarendmessage_;
}
inline ::AvatarEndMessage* PokerTHMessage::mutable_avatarendmessage() {
  set_has_avatarendmessage();
  if (avatarendmessage_ == NULL) avatarendmessage_ = new ::AvatarEndMessage;
  return avatarendmessage_;
}
inline ::AvatarEndMessage* PokerTHMessage::release_avatarendmessage() {
  clear_has_avatarendmessage();
  ::AvatarEndMessage* temp = avatarendmessage_;
  avatarendmessage_ = NULL;
  return temp;
}

// optional .UnknownAvatarMessage unknownAvatarMessage = 12;
inline bool PokerTHMessage::has_unknownavatarmessage() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PokerTHMessage::set_has_unknownavatarmessage() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PokerTHMessage::clear_has_unknownavatarmessage() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PokerTHMessage::clear_unknownavatarmessage() {
  if (unknownavatarmessage_ != NULL) unknownavatarmessage_->::UnknownAvatarMessage::Clear();
  clear_has_unknownavatarmessage();
}
inline const ::UnknownAvatarMessage& PokerTHMessage::unknownavatarmessage() const {
  return unknownavatarmessage_ != NULL ? *unknownavatarmessage_ : *default_instance_->unknownavatarmessage_;
}
inline ::UnknownAvatarMessage* PokerTHMessage::mutable_unknownavatarmessage() {
  set_has_unknownavatarmessage();
  if (unknownavatarmessage_ == NULL) unknownavatarmessage_ = new ::UnknownAvatarMessage;
  return unknownavatarmessage_;
}
inline ::UnknownAvatarMessage* PokerTHMessage::release_unknownavatarmessage() {
  clear_has_unknownavatarmessage();
  ::UnknownAvatarMessage* temp = unknownavatarmessage_;
  unknownavatarmessage_ = NULL;
  return temp;
}

// optional .PlayerListMessage playerListMessage = 13;
inline bool PokerTHMessage::has_playerlistmessage() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PokerTHMessage::set_has_playerlistmessage() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PokerTHMessage::clear_has_playerlistmessage() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PokerTHMessage::clear_playerlistmessage() {
  if (playerlistmessage_ != NULL) playerlistmessage_->::PlayerListMessage::Clear();
  clear_has_playerlistmessage();
}
inline const ::PlayerListMessage& PokerTHMessage::playerlistmessage() const {
  return playerlistmessage_ != NULL ? *playerlistmessage_ : *default_instance_->playerlistmessage_;
}
inline ::PlayerListMessage* PokerTHMessage::mutable_playerlistmessage() {
  set_has_playerlistmessage();
  if (playerlistmessage_ == NULL) playerlistmessage_ = new ::PlayerListMessage;
  return playerlistmessage_;
}
inline ::PlayerListMessage* PokerTHMessage::release_playerlistmessage() {
  clear_has_playerlistmessage();
  ::PlayerListMessage* temp = playerlistmessage_;
  playerlistmessage_ = NULL;
  return temp;
}

// optional .GameListNewMessage gameListNewMessage = 14;
inline bool PokerTHMessage::has_gamelistnewmessage() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PokerTHMessage::set_has_gamelistnewmessage() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PokerTHMessage::clear_has_gamelistnewmessage() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PokerTHMessage::clear_gamelistnewmessage() {
  if (gamelistnewmessage_ != NULL) gamelistnewmessage_->::GameListNewMessage::Clear();
  clear_has_gamelistnewmessage();
}
inline const ::GameListNewMessage& PokerTHMessage::gamelistnewmessage() const {
  return gamelistnewmessage_ != NULL ? *gamelistnewmessage_ : *default_instance_->gamelistnewmessage_;
}
inline ::GameListNewMessage* PokerTHMessage::mutable_gamelistnewmessage() {
  set_has_gamelistnewmessage();
  if (gamelistnewmessage_ == NULL) gamelistnewmessage_ = new ::GameListNewMessage;
  return gamelistnewmessage_;
}
inline ::GameListNewMessage* PokerTHMessage::release_gamelistnewmessage() {
  clear_has_gamelistnewmessage();
  ::GameListNewMessage* temp = gamelistnewmessage_;
  gamelistnewmessage_ = NULL;
  return temp;
}

// optional .GameListUpdateMessage gameListUpdateMessage = 15;
inline bool PokerTHMessage::has_gamelistupdatemessage() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PokerTHMessage::set_has_gamelistupdatemessage() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PokerTHMessage::clear_has_gamelistupdatemessage() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PokerTHMessage::clear_gamelistupdatemessage() {
  if (gamelistupdatemessage_ != NULL) gamelistupdatemessage_->::GameListUpdateMessage::Clear();
  clear_has_gamelistupdatemessage();
}
inline const ::GameListUpdateMessage& PokerTHMessage::gamelistupdatemessage() const {
  return gamelistupdatemessage_ != NULL ? *gamelistupdatemessage_ : *default_instance_->gamelistupdatemessage_;
}
inline ::GameListUpdateMessage* PokerTHMessage::mutable_gamelistupdatemessage() {
  set_has_gamelistupdatemessage();
  if (gamelistupdatemessage_ == NULL) gamelistupdatemessage_ = new ::GameListUpdateMessage;
  return gamelistupdatemessage_;
}
inline ::GameListUpdateMessage* PokerTHMessage::release_gamelistupdatemessage() {
  clear_has_gamelistupdatemessage();
  ::GameListUpdateMessage* temp = gamelistupdatemessage_;
  gamelistupdatemessage_ = NULL;
  return temp;
}

// optional .GameListPlayerJoinedMessage gameListPlayerJoinedMessage = 16;
inline bool PokerTHMessage::has_gamelistplayerjoinedmessage() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PokerTHMessage::set_has_gamelistplayerjoinedmessage() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PokerTHMessage::clear_has_gamelistplayerjoinedmessage() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PokerTHMessage::clear_gamelistplayerjoinedmessage() {
  if (gamelistplayerjoinedmessage_ != NULL) gamelistplayerjoinedmessage_->::GameListPlayerJoinedMessage::Clear();
  clear_has_gamelistplayerjoinedmessage();
}
inline const ::GameListPlayerJoinedMessage& PokerTHMessage::gamelistplayerjoinedmessage() const {
  return gamelistplayerjoinedmessage_ != NULL ? *gamelistplayerjoinedmessage_ : *default_instance_->gamelistplayerjoinedmessage_;
}
inline ::GameListPlayerJoinedMessage* PokerTHMessage::mutable_gamelistplayerjoinedmessage() {
  set_has_gamelistplayerjoinedmessage();
  if (gamelistplayerjoinedmessage_ == NULL) gamelistplayerjoinedmessage_ = new ::GameListPlayerJoinedMessage;
  return gamelistplayerjoinedmessage_;
}
inline ::GameListPlayerJoinedMessage* PokerTHMessage::release_gamelistplayerjoinedmessage() {
  clear_has_gamelistplayerjoinedmessage();
  ::GameListPlayerJoinedMessage* temp = gamelistplayerjoinedmessage_;
  gamelistplayerjoinedmessage_ = NULL;
  return temp;
}

// optional .GameListPlayerLeftMessage gameListPlayerLeftMessage = 17;
inline bool PokerTHMessage::has_gamelistplayerleftmessage() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PokerTHMessage::set_has_gamelistplayerleftmessage() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PokerTHMessage::clear_has_gamelistplayerleftmessage() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PokerTHMessage::clear_gamelistplayerleftmessage() {
  if (gamelistplayerleftmessage_ != NULL) gamelistplayerleftmessage_->::GameListPlayerLeftMessage::Clear();
  clear_has_gamelistplayerleftmessage();
}
inline const ::GameListPlayerLeftMessage& PokerTHMessage::gamelistplayerleftmessage() const {
  return gamelistplayerleftmessage_ != NULL ? *gamelistplayerleftmessage_ : *default_instance_->gamelistplayerleftmessage_;
}
inline ::GameListPlayerLeftMessage* PokerTHMessage::mutable_gamelistplayerleftmessage() {
  set_has_gamelistplayerleftmessage();
  if (gamelistplayerleftmessage_ == NULL) gamelistplayerleftmessage_ = new ::GameListPlayerLeftMessage;
  return gamelistplayerleftmessage_;
}
inline ::GameListPlayerLeftMessage* PokerTHMessage::release_gamelistplayerleftmessage() {
  clear_has_gamelistplayerleftmessage();
  ::GameListPlayerLeftMessage* temp = gamelistplayerleftmessage_;
  gamelistplayerleftmessage_ = NULL;
  return temp;
}

// optional .GameListAdminChangedMessage gameListAdminChangedMessage = 18;
inline bool PokerTHMessage::has_gamelistadminchangedmessage() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PokerTHMessage::set_has_gamelistadminchangedmessage() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PokerTHMessage::clear_has_gamelistadminchangedmessage() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PokerTHMessage::clear_gamelistadminchangedmessage() {
  if (gamelistadminchangedmessage_ != NULL) gamelistadminchangedmessage_->::GameListAdminChangedMessage::Clear();
  clear_has_gamelistadminchangedmessage();
}
inline const ::GameListAdminChangedMessage& PokerTHMessage::gamelistadminchangedmessage() const {
  return gamelistadminchangedmessage_ != NULL ? *gamelistadminchangedmessage_ : *default_instance_->gamelistadminchangedmessage_;
}
inline ::GameListAdminChangedMessage* PokerTHMessage::mutable_gamelistadminchangedmessage() {
  set_has_gamelistadminchangedmessage();
  if (gamelistadminchangedmessage_ == NULL) gamelistadminchangedmessage_ = new ::GameListAdminChangedMessage;
  return gamelistadminchangedmessage_;
}
inline ::GameListAdminChangedMessage* PokerTHMessage::release_gamelistadminchangedmessage() {
  clear_has_gamelistadminchangedmessage();
  ::GameListAdminChangedMessage* temp = gamelistadminchangedmessage_;
  gamelistadminchangedmessage_ = NULL;
  return temp;
}

// optional .PlayerInfoRequestMessage playerInfoRequestMessage = 19;
inline bool PokerTHMessage::has_playerinforequestmessage() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PokerTHMessage::set_has_playerinforequestmessage() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PokerTHMessage::clear_has_playerinforequestmessage() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PokerTHMessage::clear_playerinforequestmessage() {
  if (playerinforequestmessage_ != NULL) playerinforequestmessage_->::PlayerInfoRequestMessage::Clear();
  clear_has_playerinforequestmessage();
}
inline const ::PlayerInfoRequestMessage& PokerTHMessage::playerinforequestmessage() const {
  return playerinforequestmessage_ != NULL ? *playerinforequestmessage_ : *default_instance_->playerinforequestmessage_;
}
inline ::PlayerInfoRequestMessage* PokerTHMessage::mutable_playerinforequestmessage() {
  set_has_playerinforequestmessage();
  if (playerinforequestmessage_ == NULL) playerinforequestmessage_ = new ::PlayerInfoRequestMessage;
  return playerinforequestmessage_;
}
inline ::PlayerInfoRequestMessage* PokerTHMessage::release_playerinforequestmessage() {
  clear_has_playerinforequestmessage();
  ::PlayerInfoRequestMessage* temp = playerinforequestmessage_;
  playerinforequestmessage_ = NULL;
  return temp;
}

// optional .PlayerInfoReplyMessage playerInfoReplyMessage = 20;
inline bool PokerTHMessage::has_playerinforeplymessage() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PokerTHMessage::set_has_playerinforeplymessage() {
  _has_bits_[0] |= 0x00080000u;
}
inline void PokerTHMessage::clear_has_playerinforeplymessage() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void PokerTHMessage::clear_playerinforeplymessage() {
  if (playerinforeplymessage_ != NULL) playerinforeplymessage_->::PlayerInfoReplyMessage::Clear();
  clear_has_playerinforeplymessage();
}
inline const ::PlayerInfoReplyMessage& PokerTHMessage::playerinforeplymessage() const {
  return playerinforeplymessage_ != NULL ? *playerinforeplymessage_ : *default_instance_->playerinforeplymessage_;
}
inline ::PlayerInfoReplyMessage* PokerTHMessage::mutable_playerinforeplymessage() {
  set_has_playerinforeplymessage();
  if (playerinforeplymessage_ == NULL) playerinforeplymessage_ = new ::PlayerInfoReplyMessage;
  return playerinforeplymessage_;
}
inline ::PlayerInfoReplyMessage* PokerTHMessage::release_playerinforeplymessage() {
  clear_has_playerinforeplymessage();
  ::PlayerInfoReplyMessage* temp = playerinforeplymessage_;
  playerinforeplymessage_ = NULL;
  return temp;
}

// optional .SubscriptionRequestMessage subscriptionRequestMessage = 21;
inline bool PokerTHMessage::has_subscriptionrequestmessage() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PokerTHMessage::set_has_subscriptionrequestmessage() {
  _has_bits_[0] |= 0x00100000u;
}
inline void PokerTHMessage::clear_has_subscriptionrequestmessage() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void PokerTHMessage::clear_subscriptionrequestmessage() {
  if (subscriptionrequestmessage_ != NULL) subscriptionrequestmessage_->::SubscriptionRequestMessage::Clear();
  clear_has_subscriptionrequestmessage();
}
inline const ::SubscriptionRequestMessage& PokerTHMessage::subscriptionrequestmessage() const {
  return subscriptionrequestmessage_ != NULL ? *subscriptionrequestmessage_ : *default_instance_->subscriptionrequestmessage_;
}
inline ::SubscriptionRequestMessage* PokerTHMessage::mutable_subscriptionrequestmessage() {
  set_has_subscriptionrequestmessage();
  if (subscriptionrequestmessage_ == NULL) subscriptionrequestmessage_ = new ::SubscriptionRequestMessage;
  return subscriptionrequestmessage_;
}
inline ::SubscriptionRequestMessage* PokerTHMessage::release_subscriptionrequestmessage() {
  clear_has_subscriptionrequestmessage();
  ::SubscriptionRequestMessage* temp = subscriptionrequestmessage_;
  subscriptionrequestmessage_ = NULL;
  return temp;
}

// optional .JoinExistingGameMessage joinExistingGameMessage = 22;
inline bool PokerTHMessage::has_joinexistinggamemessage() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PokerTHMessage::set_has_joinexistinggamemessage() {
  _has_bits_[0] |= 0x00200000u;
}
inline void PokerTHMessage::clear_has_joinexistinggamemessage() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void PokerTHMessage::clear_joinexistinggamemessage() {
  if (joinexistinggamemessage_ != NULL) joinexistinggamemessage_->::JoinExistingGameMessage::Clear();
  clear_has_joinexistinggamemessage();
}
inline const ::JoinExistingGameMessage& PokerTHMessage::joinexistinggamemessage() const {
  return joinexistinggamemessage_ != NULL ? *joinexistinggamemessage_ : *default_instance_->joinexistinggamemessage_;
}
inline ::JoinExistingGameMessage* PokerTHMessage::mutable_joinexistinggamemessage() {
  set_has_joinexistinggamemessage();
  if (joinexistinggamemessage_ == NULL) joinexistinggamemessage_ = new ::JoinExistingGameMessage;
  return joinexistinggamemessage_;
}
inline ::JoinExistingGameMessage* PokerTHMessage::release_joinexistinggamemessage() {
  clear_has_joinexistinggamemessage();
  ::JoinExistingGameMessage* temp = joinexistinggamemessage_;
  joinexistinggamemessage_ = NULL;
  return temp;
}

// optional .JoinNewGameMessage joinNewGameMessage = 23;
inline bool PokerTHMessage::has_joinnewgamemessage() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PokerTHMessage::set_has_joinnewgamemessage() {
  _has_bits_[0] |= 0x00400000u;
}
inline void PokerTHMessage::clear_has_joinnewgamemessage() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void PokerTHMessage::clear_joinnewgamemessage() {
  if (joinnewgamemessage_ != NULL) joinnewgamemessage_->::JoinNewGameMessage::Clear();
  clear_has_joinnewgamemessage();
}
inline const ::JoinNewGameMessage& PokerTHMessage::joinnewgamemessage() const {
  return joinnewgamemessage_ != NULL ? *joinnewgamemessage_ : *default_instance_->joinnewgamemessage_;
}
inline ::JoinNewGameMessage* PokerTHMessage::mutable_joinnewgamemessage() {
  set_has_joinnewgamemessage();
  if (joinnewgamemessage_ == NULL) joinnewgamemessage_ = new ::JoinNewGameMessage;
  return joinnewgamemessage_;
}
inline ::JoinNewGameMessage* PokerTHMessage::release_joinnewgamemessage() {
  clear_has_joinnewgamemessage();
  ::JoinNewGameMessage* temp = joinnewgamemessage_;
  joinnewgamemessage_ = NULL;
  return temp;
}

// optional .RejoinExistingGameMessage rejoinExistingGameMessage = 24;
inline bool PokerTHMessage::has_rejoinexistinggamemessage() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PokerTHMessage::set_has_rejoinexistinggamemessage() {
  _has_bits_[0] |= 0x00800000u;
}
inline void PokerTHMessage::clear_has_rejoinexistinggamemessage() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void PokerTHMessage::clear_rejoinexistinggamemessage() {
  if (rejoinexistinggamemessage_ != NULL) rejoinexistinggamemessage_->::RejoinExistingGameMessage::Clear();
  clear_has_rejoinexistinggamemessage();
}
inline const ::RejoinExistingGameMessage& PokerTHMessage::rejoinexistinggamemessage() const {
  return rejoinexistinggamemessage_ != NULL ? *rejoinexistinggamemessage_ : *default_instance_->rejoinexistinggamemessage_;
}
inline ::RejoinExistingGameMessage* PokerTHMessage::mutable_rejoinexistinggamemessage() {
  set_has_rejoinexistinggamemessage();
  if (rejoinexistinggamemessage_ == NULL) rejoinexistinggamemessage_ = new ::RejoinExistingGameMessage;
  return rejoinexistinggamemessage_;
}
inline ::RejoinExistingGameMessage* PokerTHMessage::release_rejoinexistinggamemessage() {
  clear_has_rejoinexistinggamemessage();
  ::RejoinExistingGameMessage* temp = rejoinexistinggamemessage_;
  rejoinexistinggamemessage_ = NULL;
  return temp;
}

// optional .JoinGameAckMessage joinGameAckMessage = 25;
inline bool PokerTHMessage::has_joingameackmessage() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PokerTHMessage::set_has_joingameackmessage() {
  _has_bits_[0] |= 0x01000000u;
}
inline void PokerTHMessage::clear_has_joingameackmessage() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void PokerTHMessage::clear_joingameackmessage() {
  if (joingameackmessage_ != NULL) joingameackmessage_->::JoinGameAckMessage::Clear();
  clear_has_joingameackmessage();
}
inline const ::JoinGameAckMessage& PokerTHMessage::joingameackmessage() const {
  return joingameackmessage_ != NULL ? *joingameackmessage_ : *default_instance_->joingameackmessage_;
}
inline ::JoinGameAckMessage* PokerTHMessage::mutable_joingameackmessage() {
  set_has_joingameackmessage();
  if (joingameackmessage_ == NULL) joingameackmessage_ = new ::JoinGameAckMessage;
  return joingameackmessage_;
}
inline ::JoinGameAckMessage* PokerTHMessage::release_joingameackmessage() {
  clear_has_joingameackmessage();
  ::JoinGameAckMessage* temp = joingameackmessage_;
  joingameackmessage_ = NULL;
  return temp;
}

// optional .JoinGameFailedMessage joinGameFailedMessage = 26;
inline bool PokerTHMessage::has_joingamefailedmessage() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void PokerTHMessage::set_has_joingamefailedmessage() {
  _has_bits_[0] |= 0x02000000u;
}
inline void PokerTHMessage::clear_has_joingamefailedmessage() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void PokerTHMessage::clear_joingamefailedmessage() {
  if (joingamefailedmessage_ != NULL) joingamefailedmessage_->::JoinGameFailedMessage::Clear();
  clear_has_joingamefailedmessage();
}
inline const ::JoinGameFailedMessage& PokerTHMessage::joingamefailedmessage() const {
  return joingamefailedmessage_ != NULL ? *joingamefailedmessage_ : *default_instance_->joingamefailedmessage_;
}
inline ::JoinGameFailedMessage* PokerTHMessage::mutable_joingamefailedmessage() {
  set_has_joingamefailedmessage();
  if (joingamefailedmessage_ == NULL) joingamefailedmessage_ = new ::JoinGameFailedMessage;
  return joingamefailedmessage_;
}
inline ::JoinGameFailedMessage* PokerTHMessage::release_joingamefailedmessage() {
  clear_has_joingamefailedmessage();
  ::JoinGameFailedMessage* temp = joingamefailedmessage_;
  joingamefailedmessage_ = NULL;
  return temp;
}

// optional .GamePlayerJoinedMessage gamePlayerJoinedMessage = 27;
inline bool PokerTHMessage::has_gameplayerjoinedmessage() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void PokerTHMessage::set_has_gameplayerjoinedmessage() {
  _has_bits_[0] |= 0x04000000u;
}
inline void PokerTHMessage::clear_has_gameplayerjoinedmessage() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void PokerTHMessage::clear_gameplayerjoinedmessage() {
  if (gameplayerjoinedmessage_ != NULL) gameplayerjoinedmessage_->::GamePlayerJoinedMessage::Clear();
  clear_has_gameplayerjoinedmessage();
}
inline const ::GamePlayerJoinedMessage& PokerTHMessage::gameplayerjoinedmessage() const {
  return gameplayerjoinedmessage_ != NULL ? *gameplayerjoinedmessage_ : *default_instance_->gameplayerjoinedmessage_;
}
inline ::GamePlayerJoinedMessage* PokerTHMessage::mutable_gameplayerjoinedmessage() {
  set_has_gameplayerjoinedmessage();
  if (gameplayerjoinedmessage_ == NULL) gameplayerjoinedmessage_ = new ::GamePlayerJoinedMessage;
  return gameplayerjoinedmessage_;
}
inline ::GamePlayerJoinedMessage* PokerTHMessage::release_gameplayerjoinedmessage() {
  clear_has_gameplayerjoinedmessage();
  ::GamePlayerJoinedMessage* temp = gameplayerjoinedmessage_;
  gameplayerjoinedmessage_ = NULL;
  return temp;
}

// optional .GamePlayerLeftMessage gamePlayerLeftMessage = 28;
inline bool PokerTHMessage::has_gameplayerleftmessage() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void PokerTHMessage::set_has_gameplayerleftmessage() {
  _has_bits_[0] |= 0x08000000u;
}
inline void PokerTHMessage::clear_has_gameplayerleftmessage() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void PokerTHMessage::clear_gameplayerleftmessage() {
  if (gameplayerleftmessage_ != NULL) gameplayerleftmessage_->::GamePlayerLeftMessage::Clear();
  clear_has_gameplayerleftmessage();
}
inline const ::GamePlayerLeftMessage& PokerTHMessage::gameplayerleftmessage() const {
  return gameplayerleftmessage_ != NULL ? *gameplayerleftmessage_ : *default_instance_->gameplayerleftmessage_;
}
inline ::GamePlayerLeftMessage* PokerTHMessage::mutable_gameplayerleftmessage() {
  set_has_gameplayerleftmessage();
  if (gameplayerleftmessage_ == NULL) gameplayerleftmessage_ = new ::GamePlayerLeftMessage;
  return gameplayerleftmessage_;
}
inline ::GamePlayerLeftMessage* PokerTHMessage::release_gameplayerleftmessage() {
  clear_has_gameplayerleftmessage();
  ::GamePlayerLeftMessage* temp = gameplayerleftmessage_;
  gameplayerleftmessage_ = NULL;
  return temp;
}

// optional .GameAdminChangedMessage gameAdminChangedMessage = 29;
inline bool PokerTHMessage::has_gameadminchangedmessage() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void PokerTHMessage::set_has_gameadminchangedmessage() {
  _has_bits_[0] |= 0x10000000u;
}
inline void PokerTHMessage::clear_has_gameadminchangedmessage() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void PokerTHMessage::clear_gameadminchangedmessage() {
  if (gameadminchangedmessage_ != NULL) gameadminchangedmessage_->::GameAdminChangedMessage::Clear();
  clear_has_gameadminchangedmessage();
}
inline const ::GameAdminChangedMessage& PokerTHMessage::gameadminchangedmessage() const {
  return gameadminchangedmessage_ != NULL ? *gameadminchangedmessage_ : *default_instance_->gameadminchangedmessage_;
}
inline ::GameAdminChangedMessage* PokerTHMessage::mutable_gameadminchangedmessage() {
  set_has_gameadminchangedmessage();
  if (gameadminchangedmessage_ == NULL) gameadminchangedmessage_ = new ::GameAdminChangedMessage;
  return gameadminchangedmessage_;
}
inline ::GameAdminChangedMessage* PokerTHMessage::release_gameadminchangedmessage() {
  clear_has_gameadminchangedmessage();
  ::GameAdminChangedMessage* temp = gameadminchangedmessage_;
  gameadminchangedmessage_ = NULL;
  return temp;
}

// optional .RemovedFromGameMessage removedFromGameMessage = 30;
inline bool PokerTHMessage::has_removedfromgamemessage() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void PokerTHMessage::set_has_removedfromgamemessage() {
  _has_bits_[0] |= 0x20000000u;
}
inline void PokerTHMessage::clear_has_removedfromgamemessage() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void PokerTHMessage::clear_removedfromgamemessage() {
  if (removedfromgamemessage_ != NULL) removedfromgamemessage_->::RemovedFromGameMessage::Clear();
  clear_has_removedfromgamemessage();
}
inline const ::RemovedFromGameMessage& PokerTHMessage::removedfromgamemessage() const {
  return removedfromgamemessage_ != NULL ? *removedfromgamemessage_ : *default_instance_->removedfromgamemessage_;
}
inline ::RemovedFromGameMessage* PokerTHMessage::mutable_removedfromgamemessage() {
  set_has_removedfromgamemessage();
  if (removedfromgamemessage_ == NULL) removedfromgamemessage_ = new ::RemovedFromGameMessage;
  return removedfromgamemessage_;
}
inline ::RemovedFromGameMessage* PokerTHMessage::release_removedfromgamemessage() {
  clear_has_removedfromgamemessage();
  ::RemovedFromGameMessage* temp = removedfromgamemessage_;
  removedfromgamemessage_ = NULL;
  return temp;
}

// optional .KickPlayerRequestMessage kickPlayerRequestMessage = 31;
inline bool PokerTHMessage::has_kickplayerrequestmessage() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void PokerTHMessage::set_has_kickplayerrequestmessage() {
  _has_bits_[0] |= 0x40000000u;
}
inline void PokerTHMessage::clear_has_kickplayerrequestmessage() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void PokerTHMessage::clear_kickplayerrequestmessage() {
  if (kickplayerrequestmessage_ != NULL) kickplayerrequestmessage_->::KickPlayerRequestMessage::Clear();
  clear_has_kickplayerrequestmessage();
}
inline const ::KickPlayerRequestMessage& PokerTHMessage::kickplayerrequestmessage() const {
  return kickplayerrequestmessage_ != NULL ? *kickplayerrequestmessage_ : *default_instance_->kickplayerrequestmessage_;
}
inline ::KickPlayerRequestMessage* PokerTHMessage::mutable_kickplayerrequestmessage() {
  set_has_kickplayerrequestmessage();
  if (kickplayerrequestmessage_ == NULL) kickplayerrequestmessage_ = new ::KickPlayerRequestMessage;
  return kickplayerrequestmessage_;
}
inline ::KickPlayerRequestMessage* PokerTHMessage::release_kickplayerrequestmessage() {
  clear_has_kickplayerrequestmessage();
  ::KickPlayerRequestMessage* temp = kickplayerrequestmessage_;
  kickplayerrequestmessage_ = NULL;
  return temp;
}

// optional .LeaveGameRequestMessage leaveGameRequestMessage = 32;
inline bool PokerTHMessage::has_leavegamerequestmessage() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void PokerTHMessage::set_has_leavegamerequestmessage() {
  _has_bits_[0] |= 0x80000000u;
}
inline void PokerTHMessage::clear_has_leavegamerequestmessage() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void PokerTHMessage::clear_leavegamerequestmessage() {
  if (leavegamerequestmessage_ != NULL) leavegamerequestmessage_->::LeaveGameRequestMessage::Clear();
  clear_has_leavegamerequestmessage();
}
inline const ::LeaveGameRequestMessage& PokerTHMessage::leavegamerequestmessage() const {
  return leavegamerequestmessage_ != NULL ? *leavegamerequestmessage_ : *default_instance_->leavegamerequestmessage_;
}
inline ::LeaveGameRequestMessage* PokerTHMessage::mutable_leavegamerequestmessage() {
  set_has_leavegamerequestmessage();
  if (leavegamerequestmessage_ == NULL) leavegamerequestmessage_ = new ::LeaveGameRequestMessage;
  return leavegamerequestmessage_;
}
inline ::LeaveGameRequestMessage* PokerTHMessage::release_leavegamerequestmessage() {
  clear_has_leavegamerequestmessage();
  ::LeaveGameRequestMessage* temp = leavegamerequestmessage_;
  leavegamerequestmessage_ = NULL;
  return temp;
}

// optional .InvitePlayerToGameMessage invitePlayerToGameMessage = 33;
inline bool PokerTHMessage::has_inviteplayertogamemessage() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void PokerTHMessage::set_has_inviteplayertogamemessage() {
  _has_bits_[1] |= 0x00000001u;
}
inline void PokerTHMessage::clear_has_inviteplayertogamemessage() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void PokerTHMessage::clear_inviteplayertogamemessage() {
  if (inviteplayertogamemessage_ != NULL) inviteplayertogamemessage_->::InvitePlayerToGameMessage::Clear();
  clear_has_inviteplayertogamemessage();
}
inline const ::InvitePlayerToGameMessage& PokerTHMessage::inviteplayertogamemessage() const {
  return inviteplayertogamemessage_ != NULL ? *inviteplayertogamemessage_ : *default_instance_->inviteplayertogamemessage_;
}
inline ::InvitePlayerToGameMessage* PokerTHMessage::mutable_inviteplayertogamemessage() {
  set_has_inviteplayertogamemessage();
  if (inviteplayertogamemessage_ == NULL) inviteplayertogamemessage_ = new ::InvitePlayerToGameMessage;
  return inviteplayertogamemessage_;
}
inline ::InvitePlayerToGameMessage* PokerTHMessage::release_inviteplayertogamemessage() {
  clear_has_inviteplayertogamemessage();
  ::InvitePlayerToGameMessage* temp = inviteplayertogamemessage_;
  inviteplayertogamemessage_ = NULL;
  return temp;
}

// optional .InviteNotifyMessage inviteNotifyMessage = 34;
inline bool PokerTHMessage::has_invitenotifymessage() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void PokerTHMessage::set_has_invitenotifymessage() {
  _has_bits_[1] |= 0x00000002u;
}
inline void PokerTHMessage::clear_has_invitenotifymessage() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void PokerTHMessage::clear_invitenotifymessage() {
  if (invitenotifymessage_ != NULL) invitenotifymessage_->::InviteNotifyMessage::Clear();
  clear_has_invitenotifymessage();
}
inline const ::InviteNotifyMessage& PokerTHMessage::invitenotifymessage() const {
  return invitenotifymessage_ != NULL ? *invitenotifymessage_ : *default_instance_->invitenotifymessage_;
}
inline ::InviteNotifyMessage* PokerTHMessage::mutable_invitenotifymessage() {
  set_has_invitenotifymessage();
  if (invitenotifymessage_ == NULL) invitenotifymessage_ = new ::InviteNotifyMessage;
  return invitenotifymessage_;
}
inline ::InviteNotifyMessage* PokerTHMessage::release_invitenotifymessage() {
  clear_has_invitenotifymessage();
  ::InviteNotifyMessage* temp = invitenotifymessage_;
  invitenotifymessage_ = NULL;
  return temp;
}

// optional .RejectGameInvitationMessage rejectGameInvitationMessage = 35;
inline bool PokerTHMessage::has_rejectgameinvitationmessage() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void PokerTHMessage::set_has_rejectgameinvitationmessage() {
  _has_bits_[1] |= 0x00000004u;
}
inline void PokerTHMessage::clear_has_rejectgameinvitationmessage() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void PokerTHMessage::clear_rejectgameinvitationmessage() {
  if (rejectgameinvitationmessage_ != NULL) rejectgameinvitationmessage_->::RejectGameInvitationMessage::Clear();
  clear_has_rejectgameinvitationmessage();
}
inline const ::RejectGameInvitationMessage& PokerTHMessage::rejectgameinvitationmessage() const {
  return rejectgameinvitationmessage_ != NULL ? *rejectgameinvitationmessage_ : *default_instance_->rejectgameinvitationmessage_;
}
inline ::RejectGameInvitationMessage* PokerTHMessage::mutable_rejectgameinvitationmessage() {
  set_has_rejectgameinvitationmessage();
  if (rejectgameinvitationmessage_ == NULL) rejectgameinvitationmessage_ = new ::RejectGameInvitationMessage;
  return rejectgameinvitationmessage_;
}
inline ::RejectGameInvitationMessage* PokerTHMessage::release_rejectgameinvitationmessage() {
  clear_has_rejectgameinvitationmessage();
  ::RejectGameInvitationMessage* temp = rejectgameinvitationmessage_;
  rejectgameinvitationmessage_ = NULL;
  return temp;
}

// optional .RejectInvNotifyMessage rejectInvNotifyMessage = 36;
inline bool PokerTHMessage::has_rejectinvnotifymessage() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void PokerTHMessage::set_has_rejectinvnotifymessage() {
  _has_bits_[1] |= 0x00000008u;
}
inline void PokerTHMessage::clear_has_rejectinvnotifymessage() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void PokerTHMessage::clear_rejectinvnotifymessage() {
  if (rejectinvnotifymessage_ != NULL) rejectinvnotifymessage_->::RejectInvNotifyMessage::Clear();
  clear_has_rejectinvnotifymessage();
}
inline const ::RejectInvNotifyMessage& PokerTHMessage::rejectinvnotifymessage() const {
  return rejectinvnotifymessage_ != NULL ? *rejectinvnotifymessage_ : *default_instance_->rejectinvnotifymessage_;
}
inline ::RejectInvNotifyMessage* PokerTHMessage::mutable_rejectinvnotifymessage() {
  set_has_rejectinvnotifymessage();
  if (rejectinvnotifymessage_ == NULL) rejectinvnotifymessage_ = new ::RejectInvNotifyMessage;
  return rejectinvnotifymessage_;
}
inline ::RejectInvNotifyMessage* PokerTHMessage::release_rejectinvnotifymessage() {
  clear_has_rejectinvnotifymessage();
  ::RejectInvNotifyMessage* temp = rejectinvnotifymessage_;
  rejectinvnotifymessage_ = NULL;
  return temp;
}

// optional .StartEventMessage startEventMessage = 37;
inline bool PokerTHMessage::has_starteventmessage() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void PokerTHMessage::set_has_starteventmessage() {
  _has_bits_[1] |= 0x00000010u;
}
inline void PokerTHMessage::clear_has_starteventmessage() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void PokerTHMessage::clear_starteventmessage() {
  if (starteventmessage_ != NULL) starteventmessage_->::StartEventMessage::Clear();
  clear_has_starteventmessage();
}
inline const ::StartEventMessage& PokerTHMessage::starteventmessage() const {
  return starteventmessage_ != NULL ? *starteventmessage_ : *default_instance_->starteventmessage_;
}
inline ::StartEventMessage* PokerTHMessage::mutable_starteventmessage() {
  set_has_starteventmessage();
  if (starteventmessage_ == NULL) starteventmessage_ = new ::StartEventMessage;
  return starteventmessage_;
}
inline ::StartEventMessage* PokerTHMessage::release_starteventmessage() {
  clear_has_starteventmessage();
  ::StartEventMessage* temp = starteventmessage_;
  starteventmessage_ = NULL;
  return temp;
}

// optional .StartEventAckMessage startEventAckMessage = 38;
inline bool PokerTHMessage::has_starteventackmessage() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void PokerTHMessage::set_has_starteventackmessage() {
  _has_bits_[1] |= 0x00000020u;
}
inline void PokerTHMessage::clear_has_starteventackmessage() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void PokerTHMessage::clear_starteventackmessage() {
  if (starteventackmessage_ != NULL) starteventackmessage_->::StartEventAckMessage::Clear();
  clear_has_starteventackmessage();
}
inline const ::StartEventAckMessage& PokerTHMessage::starteventackmessage() const {
  return starteventackmessage_ != NULL ? *starteventackmessage_ : *default_instance_->starteventackmessage_;
}
inline ::StartEventAckMessage* PokerTHMessage::mutable_starteventackmessage() {
  set_has_starteventackmessage();
  if (starteventackmessage_ == NULL) starteventackmessage_ = new ::StartEventAckMessage;
  return starteventackmessage_;
}
inline ::StartEventAckMessage* PokerTHMessage::release_starteventackmessage() {
  clear_has_starteventackmessage();
  ::StartEventAckMessage* temp = starteventackmessage_;
  starteventackmessage_ = NULL;
  return temp;
}

// optional .GameStartInitialMessage gameStartInitialMessage = 39;
inline bool PokerTHMessage::has_gamestartinitialmessage() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void PokerTHMessage::set_has_gamestartinitialmessage() {
  _has_bits_[1] |= 0x00000040u;
}
inline void PokerTHMessage::clear_has_gamestartinitialmessage() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void PokerTHMessage::clear_gamestartinitialmessage() {
  if (gamestartinitialmessage_ != NULL) gamestartinitialmessage_->::GameStartInitialMessage::Clear();
  clear_has_gamestartinitialmessage();
}
inline const ::GameStartInitialMessage& PokerTHMessage::gamestartinitialmessage() const {
  return gamestartinitialmessage_ != NULL ? *gamestartinitialmessage_ : *default_instance_->gamestartinitialmessage_;
}
inline ::GameStartInitialMessage* PokerTHMessage::mutable_gamestartinitialmessage() {
  set_has_gamestartinitialmessage();
  if (gamestartinitialmessage_ == NULL) gamestartinitialmessage_ = new ::GameStartInitialMessage;
  return gamestartinitialmessage_;
}
inline ::GameStartInitialMessage* PokerTHMessage::release_gamestartinitialmessage() {
  clear_has_gamestartinitialmessage();
  ::GameStartInitialMessage* temp = gamestartinitialmessage_;
  gamestartinitialmessage_ = NULL;
  return temp;
}

// optional .GameStartRejoinMessage gameStartRejoinMessage = 40;
inline bool PokerTHMessage::has_gamestartrejoinmessage() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void PokerTHMessage::set_has_gamestartrejoinmessage() {
  _has_bits_[1] |= 0x00000080u;
}
inline void PokerTHMessage::clear_has_gamestartrejoinmessage() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void PokerTHMessage::clear_gamestartrejoinmessage() {
  if (gamestartrejoinmessage_ != NULL) gamestartrejoinmessage_->::GameStartRejoinMessage::Clear();
  clear_has_gamestartrejoinmessage();
}
inline const ::GameStartRejoinMessage& PokerTHMessage::gamestartrejoinmessage() const {
  return gamestartrejoinmessage_ != NULL ? *gamestartrejoinmessage_ : *default_instance_->gamestartrejoinmessage_;
}
inline ::GameStartRejoinMessage* PokerTHMessage::mutable_gamestartrejoinmessage() {
  set_has_gamestartrejoinmessage();
  if (gamestartrejoinmessage_ == NULL) gamestartrejoinmessage_ = new ::GameStartRejoinMessage;
  return gamestartrejoinmessage_;
}
inline ::GameStartRejoinMessage* PokerTHMessage::release_gamestartrejoinmessage() {
  clear_has_gamestartrejoinmessage();
  ::GameStartRejoinMessage* temp = gamestartrejoinmessage_;
  gamestartrejoinmessage_ = NULL;
  return temp;
}

// optional .HandStartMessage handStartMessage = 41;
inline bool PokerTHMessage::has_handstartmessage() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void PokerTHMessage::set_has_handstartmessage() {
  _has_bits_[1] |= 0x00000100u;
}
inline void PokerTHMessage::clear_has_handstartmessage() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void PokerTHMessage::clear_handstartmessage() {
  if (handstartmessage_ != NULL) handstartmessage_->::HandStartMessage::Clear();
  clear_has_handstartmessage();
}
inline const ::HandStartMessage& PokerTHMessage::handstartmessage() const {
  return handstartmessage_ != NULL ? *handstartmessage_ : *default_instance_->handstartmessage_;
}
inline ::HandStartMessage* PokerTHMessage::mutable_handstartmessage() {
  set_has_handstartmessage();
  if (handstartmessage_ == NULL) handstartmessage_ = new ::HandStartMessage;
  return handstartmessage_;
}
inline ::HandStartMessage* PokerTHMessage::release_handstartmessage() {
  clear_has_handstartmessage();
  ::HandStartMessage* temp = handstartmessage_;
  handstartmessage_ = NULL;
  return temp;
}

// optional .PlayersTurnMessage playersTurnMessage = 42;
inline bool PokerTHMessage::has_playersturnmessage() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void PokerTHMessage::set_has_playersturnmessage() {
  _has_bits_[1] |= 0x00000200u;
}
inline void PokerTHMessage::clear_has_playersturnmessage() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void PokerTHMessage::clear_playersturnmessage() {
  if (playersturnmessage_ != NULL) playersturnmessage_->::PlayersTurnMessage::Clear();
  clear_has_playersturnmessage();
}
inline const ::PlayersTurnMessage& PokerTHMessage::playersturnmessage() const {
  return playersturnmessage_ != NULL ? *playersturnmessage_ : *default_instance_->playersturnmessage_;
}
inline ::PlayersTurnMessage* PokerTHMessage::mutable_playersturnmessage() {
  set_has_playersturnmessage();
  if (playersturnmessage_ == NULL) playersturnmessage_ = new ::PlayersTurnMessage;
  return playersturnmessage_;
}
inline ::PlayersTurnMessage* PokerTHMessage::release_playersturnmessage() {
  clear_has_playersturnmessage();
  ::PlayersTurnMessage* temp = playersturnmessage_;
  playersturnmessage_ = NULL;
  return temp;
}

// optional .MyActionRequestMessage myActionRequestMessage = 43;
inline bool PokerTHMessage::has_myactionrequestmessage() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void PokerTHMessage::set_has_myactionrequestmessage() {
  _has_bits_[1] |= 0x00000400u;
}
inline void PokerTHMessage::clear_has_myactionrequestmessage() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void PokerTHMessage::clear_myactionrequestmessage() {
  if (myactionrequestmessage_ != NULL) myactionrequestmessage_->::MyActionRequestMessage::Clear();
  clear_has_myactionrequestmessage();
}
inline const ::MyActionRequestMessage& PokerTHMessage::myactionrequestmessage() const {
  return myactionrequestmessage_ != NULL ? *myactionrequestmessage_ : *default_instance_->myactionrequestmessage_;
}
inline ::MyActionRequestMessage* PokerTHMessage::mutable_myactionrequestmessage() {
  set_has_myactionrequestmessage();
  if (myactionrequestmessage_ == NULL) myactionrequestmessage_ = new ::MyActionRequestMessage;
  return myactionrequestmessage_;
}
inline ::MyActionRequestMessage* PokerTHMessage::release_myactionrequestmessage() {
  clear_has_myactionrequestmessage();
  ::MyActionRequestMessage* temp = myactionrequestmessage_;
  myactionrequestmessage_ = NULL;
  return temp;
}

// optional .YourActionRejectedMessage yourActionRejectedMessage = 44;
inline bool PokerTHMessage::has_youractionrejectedmessage() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void PokerTHMessage::set_has_youractionrejectedmessage() {
  _has_bits_[1] |= 0x00000800u;
}
inline void PokerTHMessage::clear_has_youractionrejectedmessage() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void PokerTHMessage::clear_youractionrejectedmessage() {
  if (youractionrejectedmessage_ != NULL) youractionrejectedmessage_->::YourActionRejectedMessage::Clear();
  clear_has_youractionrejectedmessage();
}
inline const ::YourActionRejectedMessage& PokerTHMessage::youractionrejectedmessage() const {
  return youractionrejectedmessage_ != NULL ? *youractionrejectedmessage_ : *default_instance_->youractionrejectedmessage_;
}
inline ::YourActionRejectedMessage* PokerTHMessage::mutable_youractionrejectedmessage() {
  set_has_youractionrejectedmessage();
  if (youractionrejectedmessage_ == NULL) youractionrejectedmessage_ = new ::YourActionRejectedMessage;
  return youractionrejectedmessage_;
}
inline ::YourActionRejectedMessage* PokerTHMessage::release_youractionrejectedmessage() {
  clear_has_youractionrejectedmessage();
  ::YourActionRejectedMessage* temp = youractionrejectedmessage_;
  youractionrejectedmessage_ = NULL;
  return temp;
}

// optional .PlayersActionDoneMessage playersActionDoneMessage = 45;
inline bool PokerTHMessage::has_playersactiondonemessage() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void PokerTHMessage::set_has_playersactiondonemessage() {
  _has_bits_[1] |= 0x00001000u;
}
inline void PokerTHMessage::clear_has_playersactiondonemessage() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void PokerTHMessage::clear_playersactiondonemessage() {
  if (playersactiondonemessage_ != NULL) playersactiondonemessage_->::PlayersActionDoneMessage::Clear();
  clear_has_playersactiondonemessage();
}
inline const ::PlayersActionDoneMessage& PokerTHMessage::playersactiondonemessage() const {
  return playersactiondonemessage_ != NULL ? *playersactiondonemessage_ : *default_instance_->playersactiondonemessage_;
}
inline ::PlayersActionDoneMessage* PokerTHMessage::mutable_playersactiondonemessage() {
  set_has_playersactiondonemessage();
  if (playersactiondonemessage_ == NULL) playersactiondonemessage_ = new ::PlayersActionDoneMessage;
  return playersactiondonemessage_;
}
inline ::PlayersActionDoneMessage* PokerTHMessage::release_playersactiondonemessage() {
  clear_has_playersactiondonemessage();
  ::PlayersActionDoneMessage* temp = playersactiondonemessage_;
  playersactiondonemessage_ = NULL;
  return temp;
}

// optional .DealFlopCardsMessage dealFlopCardsMessage = 46;
inline bool PokerTHMessage::has_dealflopcardsmessage() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void PokerTHMessage::set_has_dealflopcardsmessage() {
  _has_bits_[1] |= 0x00002000u;
}
inline void PokerTHMessage::clear_has_dealflopcardsmessage() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void PokerTHMessage::clear_dealflopcardsmessage() {
  if (dealflopcardsmessage_ != NULL) dealflopcardsmessage_->::DealFlopCardsMessage::Clear();
  clear_has_dealflopcardsmessage();
}
inline const ::DealFlopCardsMessage& PokerTHMessage::dealflopcardsmessage() const {
  return dealflopcardsmessage_ != NULL ? *dealflopcardsmessage_ : *default_instance_->dealflopcardsmessage_;
}
inline ::DealFlopCardsMessage* PokerTHMessage::mutable_dealflopcardsmessage() {
  set_has_dealflopcardsmessage();
  if (dealflopcardsmessage_ == NULL) dealflopcardsmessage_ = new ::DealFlopCardsMessage;
  return dealflopcardsmessage_;
}
inline ::DealFlopCardsMessage* PokerTHMessage::release_dealflopcardsmessage() {
  clear_has_dealflopcardsmessage();
  ::DealFlopCardsMessage* temp = dealflopcardsmessage_;
  dealflopcardsmessage_ = NULL;
  return temp;
}

// optional .DealTurnCardMessage dealTurnCardMessage = 47;
inline bool PokerTHMessage::has_dealturncardmessage() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void PokerTHMessage::set_has_dealturncardmessage() {
  _has_bits_[1] |= 0x00004000u;
}
inline void PokerTHMessage::clear_has_dealturncardmessage() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void PokerTHMessage::clear_dealturncardmessage() {
  if (dealturncardmessage_ != NULL) dealturncardmessage_->::DealTurnCardMessage::Clear();
  clear_has_dealturncardmessage();
}
inline const ::DealTurnCardMessage& PokerTHMessage::dealturncardmessage() const {
  return dealturncardmessage_ != NULL ? *dealturncardmessage_ : *default_instance_->dealturncardmessage_;
}
inline ::DealTurnCardMessage* PokerTHMessage::mutable_dealturncardmessage() {
  set_has_dealturncardmessage();
  if (dealturncardmessage_ == NULL) dealturncardmessage_ = new ::DealTurnCardMessage;
  return dealturncardmessage_;
}
inline ::DealTurnCardMessage* PokerTHMessage::release_dealturncardmessage() {
  clear_has_dealturncardmessage();
  ::DealTurnCardMessage* temp = dealturncardmessage_;
  dealturncardmessage_ = NULL;
  return temp;
}

// optional .DealRiverCardMessage dealRiverCardMessage = 48;
inline bool PokerTHMessage::has_dealrivercardmessage() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void PokerTHMessage::set_has_dealrivercardmessage() {
  _has_bits_[1] |= 0x00008000u;
}
inline void PokerTHMessage::clear_has_dealrivercardmessage() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void PokerTHMessage::clear_dealrivercardmessage() {
  if (dealrivercardmessage_ != NULL) dealrivercardmessage_->::DealRiverCardMessage::Clear();
  clear_has_dealrivercardmessage();
}
inline const ::DealRiverCardMessage& PokerTHMessage::dealrivercardmessage() const {
  return dealrivercardmessage_ != NULL ? *dealrivercardmessage_ : *default_instance_->dealrivercardmessage_;
}
inline ::DealRiverCardMessage* PokerTHMessage::mutable_dealrivercardmessage() {
  set_has_dealrivercardmessage();
  if (dealrivercardmessage_ == NULL) dealrivercardmessage_ = new ::DealRiverCardMessage;
  return dealrivercardmessage_;
}
inline ::DealRiverCardMessage* PokerTHMessage::release_dealrivercardmessage() {
  clear_has_dealrivercardmessage();
  ::DealRiverCardMessage* temp = dealrivercardmessage_;
  dealrivercardmessage_ = NULL;
  return temp;
}

// optional .AllInShowCardsMessage allInShowCardsMessage = 49;
inline bool PokerTHMessage::has_allinshowcardsmessage() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void PokerTHMessage::set_has_allinshowcardsmessage() {
  _has_bits_[1] |= 0x00010000u;
}
inline void PokerTHMessage::clear_has_allinshowcardsmessage() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void PokerTHMessage::clear_allinshowcardsmessage() {
  if (allinshowcardsmessage_ != NULL) allinshowcardsmessage_->::AllInShowCardsMessage::Clear();
  clear_has_allinshowcardsmessage();
}
inline const ::AllInShowCardsMessage& PokerTHMessage::allinshowcardsmessage() const {
  return allinshowcardsmessage_ != NULL ? *allinshowcardsmessage_ : *default_instance_->allinshowcardsmessage_;
}
inline ::AllInShowCardsMessage* PokerTHMessage::mutable_allinshowcardsmessage() {
  set_has_allinshowcardsmessage();
  if (allinshowcardsmessage_ == NULL) allinshowcardsmessage_ = new ::AllInShowCardsMessage;
  return allinshowcardsmessage_;
}
inline ::AllInShowCardsMessage* PokerTHMessage::release_allinshowcardsmessage() {
  clear_has_allinshowcardsmessage();
  ::AllInShowCardsMessage* temp = allinshowcardsmessage_;
  allinshowcardsmessage_ = NULL;
  return temp;
}

// optional .EndOfHandShowCardsMessage endOfHandShowCardsMessage = 50;
inline bool PokerTHMessage::has_endofhandshowcardsmessage() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void PokerTHMessage::set_has_endofhandshowcardsmessage() {
  _has_bits_[1] |= 0x00020000u;
}
inline void PokerTHMessage::clear_has_endofhandshowcardsmessage() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void PokerTHMessage::clear_endofhandshowcardsmessage() {
  if (endofhandshowcardsmessage_ != NULL) endofhandshowcardsmessage_->::EndOfHandShowCardsMessage::Clear();
  clear_has_endofhandshowcardsmessage();
}
inline const ::EndOfHandShowCardsMessage& PokerTHMessage::endofhandshowcardsmessage() const {
  return endofhandshowcardsmessage_ != NULL ? *endofhandshowcardsmessage_ : *default_instance_->endofhandshowcardsmessage_;
}
inline ::EndOfHandShowCardsMessage* PokerTHMessage::mutable_endofhandshowcardsmessage() {
  set_has_endofhandshowcardsmessage();
  if (endofhandshowcardsmessage_ == NULL) endofhandshowcardsmessage_ = new ::EndOfHandShowCardsMessage;
  return endofhandshowcardsmessage_;
}
inline ::EndOfHandShowCardsMessage* PokerTHMessage::release_endofhandshowcardsmessage() {
  clear_has_endofhandshowcardsmessage();
  ::EndOfHandShowCardsMessage* temp = endofhandshowcardsmessage_;
  endofhandshowcardsmessage_ = NULL;
  return temp;
}

// optional .EndOfHandHideCardsMessage endOfHandHideCardsMessage = 51;
inline bool PokerTHMessage::has_endofhandhidecardsmessage() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void PokerTHMessage::set_has_endofhandhidecardsmessage() {
  _has_bits_[1] |= 0x00040000u;
}
inline void PokerTHMessage::clear_has_endofhandhidecardsmessage() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void PokerTHMessage::clear_endofhandhidecardsmessage() {
  if (endofhandhidecardsmessage_ != NULL) endofhandhidecardsmessage_->::EndOfHandHideCardsMessage::Clear();
  clear_has_endofhandhidecardsmessage();
}
inline const ::EndOfHandHideCardsMessage& PokerTHMessage::endofhandhidecardsmessage() const {
  return endofhandhidecardsmessage_ != NULL ? *endofhandhidecardsmessage_ : *default_instance_->endofhandhidecardsmessage_;
}
inline ::EndOfHandHideCardsMessage* PokerTHMessage::mutable_endofhandhidecardsmessage() {
  set_has_endofhandhidecardsmessage();
  if (endofhandhidecardsmessage_ == NULL) endofhandhidecardsmessage_ = new ::EndOfHandHideCardsMessage;
  return endofhandhidecardsmessage_;
}
inline ::EndOfHandHideCardsMessage* PokerTHMessage::release_endofhandhidecardsmessage() {
  clear_has_endofhandhidecardsmessage();
  ::EndOfHandHideCardsMessage* temp = endofhandhidecardsmessage_;
  endofhandhidecardsmessage_ = NULL;
  return temp;
}

// optional .ShowMyCardsRequestMessage showMyCardsRequestMessage = 52;
inline bool PokerTHMessage::has_showmycardsrequestmessage() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void PokerTHMessage::set_has_showmycardsrequestmessage() {
  _has_bits_[1] |= 0x00080000u;
}
inline void PokerTHMessage::clear_has_showmycardsrequestmessage() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void PokerTHMessage::clear_showmycardsrequestmessage() {
  if (showmycardsrequestmessage_ != NULL) showmycardsrequestmessage_->::ShowMyCardsRequestMessage::Clear();
  clear_has_showmycardsrequestmessage();
}
inline const ::ShowMyCardsRequestMessage& PokerTHMessage::showmycardsrequestmessage() const {
  return showmycardsrequestmessage_ != NULL ? *showmycardsrequestmessage_ : *default_instance_->showmycardsrequestmessage_;
}
inline ::ShowMyCardsRequestMessage* PokerTHMessage::mutable_showmycardsrequestmessage() {
  set_has_showmycardsrequestmessage();
  if (showmycardsrequestmessage_ == NULL) showmycardsrequestmessage_ = new ::ShowMyCardsRequestMessage;
  return showmycardsrequestmessage_;
}
inline ::ShowMyCardsRequestMessage* PokerTHMessage::release_showmycardsrequestmessage() {
  clear_has_showmycardsrequestmessage();
  ::ShowMyCardsRequestMessage* temp = showmycardsrequestmessage_;
  showmycardsrequestmessage_ = NULL;
  return temp;
}

// optional .AfterHandShowCardsMessage afterHandShowCardsMessage = 53;
inline bool PokerTHMessage::has_afterhandshowcardsmessage() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void PokerTHMessage::set_has_afterhandshowcardsmessage() {
  _has_bits_[1] |= 0x00100000u;
}
inline void PokerTHMessage::clear_has_afterhandshowcardsmessage() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void PokerTHMessage::clear_afterhandshowcardsmessage() {
  if (afterhandshowcardsmessage_ != NULL) afterhandshowcardsmessage_->::AfterHandShowCardsMessage::Clear();
  clear_has_afterhandshowcardsmessage();
}
inline const ::AfterHandShowCardsMessage& PokerTHMessage::afterhandshowcardsmessage() const {
  return afterhandshowcardsmessage_ != NULL ? *afterhandshowcardsmessage_ : *default_instance_->afterhandshowcardsmessage_;
}
inline ::AfterHandShowCardsMessage* PokerTHMessage::mutable_afterhandshowcardsmessage() {
  set_has_afterhandshowcardsmessage();
  if (afterhandshowcardsmessage_ == NULL) afterhandshowcardsmessage_ = new ::AfterHandShowCardsMessage;
  return afterhandshowcardsmessage_;
}
inline ::AfterHandShowCardsMessage* PokerTHMessage::release_afterhandshowcardsmessage() {
  clear_has_afterhandshowcardsmessage();
  ::AfterHandShowCardsMessage* temp = afterhandshowcardsmessage_;
  afterhandshowcardsmessage_ = NULL;
  return temp;
}

// optional .EndOfGameMessage endOfGameMessage = 54;
inline bool PokerTHMessage::has_endofgamemessage() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void PokerTHMessage::set_has_endofgamemessage() {
  _has_bits_[1] |= 0x00200000u;
}
inline void PokerTHMessage::clear_has_endofgamemessage() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void PokerTHMessage::clear_endofgamemessage() {
  if (endofgamemessage_ != NULL) endofgamemessage_->::EndOfGameMessage::Clear();
  clear_has_endofgamemessage();
}
inline const ::EndOfGameMessage& PokerTHMessage::endofgamemessage() const {
  return endofgamemessage_ != NULL ? *endofgamemessage_ : *default_instance_->endofgamemessage_;
}
inline ::EndOfGameMessage* PokerTHMessage::mutable_endofgamemessage() {
  set_has_endofgamemessage();
  if (endofgamemessage_ == NULL) endofgamemessage_ = new ::EndOfGameMessage;
  return endofgamemessage_;
}
inline ::EndOfGameMessage* PokerTHMessage::release_endofgamemessage() {
  clear_has_endofgamemessage();
  ::EndOfGameMessage* temp = endofgamemessage_;
  endofgamemessage_ = NULL;
  return temp;
}

// optional .PlayerIdChangedMessage playerIdChangedMessage = 55;
inline bool PokerTHMessage::has_playeridchangedmessage() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void PokerTHMessage::set_has_playeridchangedmessage() {
  _has_bits_[1] |= 0x00400000u;
}
inline void PokerTHMessage::clear_has_playeridchangedmessage() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void PokerTHMessage::clear_playeridchangedmessage() {
  if (playeridchangedmessage_ != NULL) playeridchangedmessage_->::PlayerIdChangedMessage::Clear();
  clear_has_playeridchangedmessage();
}
inline const ::PlayerIdChangedMessage& PokerTHMessage::playeridchangedmessage() const {
  return playeridchangedmessage_ != NULL ? *playeridchangedmessage_ : *default_instance_->playeridchangedmessage_;
}
inline ::PlayerIdChangedMessage* PokerTHMessage::mutable_playeridchangedmessage() {
  set_has_playeridchangedmessage();
  if (playeridchangedmessage_ == NULL) playeridchangedmessage_ = new ::PlayerIdChangedMessage;
  return playeridchangedmessage_;
}
inline ::PlayerIdChangedMessage* PokerTHMessage::release_playeridchangedmessage() {
  clear_has_playeridchangedmessage();
  ::PlayerIdChangedMessage* temp = playeridchangedmessage_;
  playeridchangedmessage_ = NULL;
  return temp;
}

// optional .AskKickPlayerMessage askKickPlayerMessage = 56;
inline bool PokerTHMessage::has_askkickplayermessage() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void PokerTHMessage::set_has_askkickplayermessage() {
  _has_bits_[1] |= 0x00800000u;
}
inline void PokerTHMessage::clear_has_askkickplayermessage() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void PokerTHMessage::clear_askkickplayermessage() {
  if (askkickplayermessage_ != NULL) askkickplayermessage_->::AskKickPlayerMessage::Clear();
  clear_has_askkickplayermessage();
}
inline const ::AskKickPlayerMessage& PokerTHMessage::askkickplayermessage() const {
  return askkickplayermessage_ != NULL ? *askkickplayermessage_ : *default_instance_->askkickplayermessage_;
}
inline ::AskKickPlayerMessage* PokerTHMessage::mutable_askkickplayermessage() {
  set_has_askkickplayermessage();
  if (askkickplayermessage_ == NULL) askkickplayermessage_ = new ::AskKickPlayerMessage;
  return askkickplayermessage_;
}
inline ::AskKickPlayerMessage* PokerTHMessage::release_askkickplayermessage() {
  clear_has_askkickplayermessage();
  ::AskKickPlayerMessage* temp = askkickplayermessage_;
  askkickplayermessage_ = NULL;
  return temp;
}

// optional .AskKickDeniedMessage askKickDeniedMessage = 57;
inline bool PokerTHMessage::has_askkickdeniedmessage() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void PokerTHMessage::set_has_askkickdeniedmessage() {
  _has_bits_[1] |= 0x01000000u;
}
inline void PokerTHMessage::clear_has_askkickdeniedmessage() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void PokerTHMessage::clear_askkickdeniedmessage() {
  if (askkickdeniedmessage_ != NULL) askkickdeniedmessage_->::AskKickDeniedMessage::Clear();
  clear_has_askkickdeniedmessage();
}
inline const ::AskKickDeniedMessage& PokerTHMessage::askkickdeniedmessage() const {
  return askkickdeniedmessage_ != NULL ? *askkickdeniedmessage_ : *default_instance_->askkickdeniedmessage_;
}
inline ::AskKickDeniedMessage* PokerTHMessage::mutable_askkickdeniedmessage() {
  set_has_askkickdeniedmessage();
  if (askkickdeniedmessage_ == NULL) askkickdeniedmessage_ = new ::AskKickDeniedMessage;
  return askkickdeniedmessage_;
}
inline ::AskKickDeniedMessage* PokerTHMessage::release_askkickdeniedmessage() {
  clear_has_askkickdeniedmessage();
  ::AskKickDeniedMessage* temp = askkickdeniedmessage_;
  askkickdeniedmessage_ = NULL;
  return temp;
}

// optional .StartKickPetitionMessage startKickPetitionMessage = 58;
inline bool PokerTHMessage::has_startkickpetitionmessage() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void PokerTHMessage::set_has_startkickpetitionmessage() {
  _has_bits_[1] |= 0x02000000u;
}
inline void PokerTHMessage::clear_has_startkickpetitionmessage() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void PokerTHMessage::clear_startkickpetitionmessage() {
  if (startkickpetitionmessage_ != NULL) startkickpetitionmessage_->::StartKickPetitionMessage::Clear();
  clear_has_startkickpetitionmessage();
}
inline const ::StartKickPetitionMessage& PokerTHMessage::startkickpetitionmessage() const {
  return startkickpetitionmessage_ != NULL ? *startkickpetitionmessage_ : *default_instance_->startkickpetitionmessage_;
}
inline ::StartKickPetitionMessage* PokerTHMessage::mutable_startkickpetitionmessage() {
  set_has_startkickpetitionmessage();
  if (startkickpetitionmessage_ == NULL) startkickpetitionmessage_ = new ::StartKickPetitionMessage;
  return startkickpetitionmessage_;
}
inline ::StartKickPetitionMessage* PokerTHMessage::release_startkickpetitionmessage() {
  clear_has_startkickpetitionmessage();
  ::StartKickPetitionMessage* temp = startkickpetitionmessage_;
  startkickpetitionmessage_ = NULL;
  return temp;
}

// optional .VoteKickRequestMessage voteKickRequestMessage = 59;
inline bool PokerTHMessage::has_votekickrequestmessage() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void PokerTHMessage::set_has_votekickrequestmessage() {
  _has_bits_[1] |= 0x04000000u;
}
inline void PokerTHMessage::clear_has_votekickrequestmessage() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void PokerTHMessage::clear_votekickrequestmessage() {
  if (votekickrequestmessage_ != NULL) votekickrequestmessage_->::VoteKickRequestMessage::Clear();
  clear_has_votekickrequestmessage();
}
inline const ::VoteKickRequestMessage& PokerTHMessage::votekickrequestmessage() const {
  return votekickrequestmessage_ != NULL ? *votekickrequestmessage_ : *default_instance_->votekickrequestmessage_;
}
inline ::VoteKickRequestMessage* PokerTHMessage::mutable_votekickrequestmessage() {
  set_has_votekickrequestmessage();
  if (votekickrequestmessage_ == NULL) votekickrequestmessage_ = new ::VoteKickRequestMessage;
  return votekickrequestmessage_;
}
inline ::VoteKickRequestMessage* PokerTHMessage::release_votekickrequestmessage() {
  clear_has_votekickrequestmessage();
  ::VoteKickRequestMessage* temp = votekickrequestmessage_;
  votekickrequestmessage_ = NULL;
  return temp;
}

// optional .VoteKickReplyMessage voteKickReplyMessage = 60;
inline bool PokerTHMessage::has_votekickreplymessage() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void PokerTHMessage::set_has_votekickreplymessage() {
  _has_bits_[1] |= 0x08000000u;
}
inline void PokerTHMessage::clear_has_votekickreplymessage() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void PokerTHMessage::clear_votekickreplymessage() {
  if (votekickreplymessage_ != NULL) votekickreplymessage_->::VoteKickReplyMessage::Clear();
  clear_has_votekickreplymessage();
}
inline const ::VoteKickReplyMessage& PokerTHMessage::votekickreplymessage() const {
  return votekickreplymessage_ != NULL ? *votekickreplymessage_ : *default_instance_->votekickreplymessage_;
}
inline ::VoteKickReplyMessage* PokerTHMessage::mutable_votekickreplymessage() {
  set_has_votekickreplymessage();
  if (votekickreplymessage_ == NULL) votekickreplymessage_ = new ::VoteKickReplyMessage;
  return votekickreplymessage_;
}
inline ::VoteKickReplyMessage* PokerTHMessage::release_votekickreplymessage() {
  clear_has_votekickreplymessage();
  ::VoteKickReplyMessage* temp = votekickreplymessage_;
  votekickreplymessage_ = NULL;
  return temp;
}

// optional .KickPetitionUpdateMessage kickPetitionUpdateMessage = 61;
inline bool PokerTHMessage::has_kickpetitionupdatemessage() const {
  return (_has_bits_[1] & 0x10000000u) != 0;
}
inline void PokerTHMessage::set_has_kickpetitionupdatemessage() {
  _has_bits_[1] |= 0x10000000u;
}
inline void PokerTHMessage::clear_has_kickpetitionupdatemessage() {
  _has_bits_[1] &= ~0x10000000u;
}
inline void PokerTHMessage::clear_kickpetitionupdatemessage() {
  if (kickpetitionupdatemessage_ != NULL) kickpetitionupdatemessage_->::KickPetitionUpdateMessage::Clear();
  clear_has_kickpetitionupdatemessage();
}
inline const ::KickPetitionUpdateMessage& PokerTHMessage::kickpetitionupdatemessage() const {
  return kickpetitionupdatemessage_ != NULL ? *kickpetitionupdatemessage_ : *default_instance_->kickpetitionupdatemessage_;
}
inline ::KickPetitionUpdateMessage* PokerTHMessage::mutable_kickpetitionupdatemessage() {
  set_has_kickpetitionupdatemessage();
  if (kickpetitionupdatemessage_ == NULL) kickpetitionupdatemessage_ = new ::KickPetitionUpdateMessage;
  return kickpetitionupdatemessage_;
}
inline ::KickPetitionUpdateMessage* PokerTHMessage::release_kickpetitionupdatemessage() {
  clear_has_kickpetitionupdatemessage();
  ::KickPetitionUpdateMessage* temp = kickpetitionupdatemessage_;
  kickpetitionupdatemessage_ = NULL;
  return temp;
}

// optional .EndKickPetitionMessage endKickPetitionMessage = 62;
inline bool PokerTHMessage::has_endkickpetitionmessage() const {
  return (_has_bits_[1] & 0x20000000u) != 0;
}
inline void PokerTHMessage::set_has_endkickpetitionmessage() {
  _has_bits_[1] |= 0x20000000u;
}
inline void PokerTHMessage::clear_has_endkickpetitionmessage() {
  _has_bits_[1] &= ~0x20000000u;
}
inline void PokerTHMessage::clear_endkickpetitionmessage() {
  if (endkickpetitionmessage_ != NULL) endkickpetitionmessage_->::EndKickPetitionMessage::Clear();
  clear_has_endkickpetitionmessage();
}
inline const ::EndKickPetitionMessage& PokerTHMessage::endkickpetitionmessage() const {
  return endkickpetitionmessage_ != NULL ? *endkickpetitionmessage_ : *default_instance_->endkickpetitionmessage_;
}
inline ::EndKickPetitionMessage* PokerTHMessage::mutable_endkickpetitionmessage() {
  set_has_endkickpetitionmessage();
  if (endkickpetitionmessage_ == NULL) endkickpetitionmessage_ = new ::EndKickPetitionMessage;
  return endkickpetitionmessage_;
}
inline ::EndKickPetitionMessage* PokerTHMessage::release_endkickpetitionmessage() {
  clear_has_endkickpetitionmessage();
  ::EndKickPetitionMessage* temp = endkickpetitionmessage_;
  endkickpetitionmessage_ = NULL;
  return temp;
}

// optional .StatisticsMessage statisticsMessage = 63;
inline bool PokerTHMessage::has_statisticsmessage() const {
  return (_has_bits_[1] & 0x40000000u) != 0;
}
inline void PokerTHMessage::set_has_statisticsmessage() {
  _has_bits_[1] |= 0x40000000u;
}
inline void PokerTHMessage::clear_has_statisticsmessage() {
  _has_bits_[1] &= ~0x40000000u;
}
inline void PokerTHMessage::clear_statisticsmessage() {
  if (statisticsmessage_ != NULL) statisticsmessage_->::StatisticsMessage::Clear();
  clear_has_statisticsmessage();
}
inline const ::StatisticsMessage& PokerTHMessage::statisticsmessage() const {
  return statisticsmessage_ != NULL ? *statisticsmessage_ : *default_instance_->statisticsmessage_;
}
inline ::StatisticsMessage* PokerTHMessage::mutable_statisticsmessage() {
  set_has_statisticsmessage();
  if (statisticsmessage_ == NULL) statisticsmessage_ = new ::StatisticsMessage;
  return statisticsmessage_;
}
inline ::StatisticsMessage* PokerTHMessage::release_statisticsmessage() {
  clear_has_statisticsmessage();
  ::StatisticsMessage* temp = statisticsmessage_;
  statisticsmessage_ = NULL;
  return temp;
}

// optional .ChatRequestMessage chatRequestMessage = 64;
inline bool PokerTHMessage::has_chatrequestmessage() const {
  return (_has_bits_[1] & 0x80000000u) != 0;
}
inline void PokerTHMessage::set_has_chatrequestmessage() {
  _has_bits_[1] |= 0x80000000u;
}
inline void PokerTHMessage::clear_has_chatrequestmessage() {
  _has_bits_[1] &= ~0x80000000u;
}
inline void PokerTHMessage::clear_chatrequestmessage() {
  if (chatrequestmessage_ != NULL) chatrequestmessage_->::ChatRequestMessage::Clear();
  clear_has_chatrequestmessage();
}
inline const ::ChatRequestMessage& PokerTHMessage::chatrequestmessage() const {
  return chatrequestmessage_ != NULL ? *chatrequestmessage_ : *default_instance_->chatrequestmessage_;
}
inline ::ChatRequestMessage* PokerTHMessage::mutable_chatrequestmessage() {
  set_has_chatrequestmessage();
  if (chatrequestmessage_ == NULL) chatrequestmessage_ = new ::ChatRequestMessage;
  return chatrequestmessage_;
}
inline ::ChatRequestMessage* PokerTHMessage::release_chatrequestmessage() {
  clear_has_chatrequestmessage();
  ::ChatRequestMessage* temp = chatrequestmessage_;
  chatrequestmessage_ = NULL;
  return temp;
}

// optional .ChatMessage chatMessage = 65;
inline bool PokerTHMessage::has_chatmessage() const {
  return (_has_bits_[2] & 0x00000001u) != 0;
}
inline void PokerTHMessage::set_has_chatmessage() {
  _has_bits_[2] |= 0x00000001u;
}
inline void PokerTHMessage::clear_has_chatmessage() {
  _has_bits_[2] &= ~0x00000001u;
}
inline void PokerTHMessage::clear_chatmessage() {
  if (chatmessage_ != NULL) chatmessage_->::ChatMessage::Clear();
  clear_has_chatmessage();
}
inline const ::ChatMessage& PokerTHMessage::chatmessage() const {
  return chatmessage_ != NULL ? *chatmessage_ : *default_instance_->chatmessage_;
}
inline ::ChatMessage* PokerTHMessage::mutable_chatmessage() {
  set_has_chatmessage();
  if (chatmessage_ == NULL) chatmessage_ = new ::ChatMessage;
  return chatmessage_;
}
inline ::ChatMessage* PokerTHMessage::release_chatmessage() {
  clear_has_chatmessage();
  ::ChatMessage* temp = chatmessage_;
  chatmessage_ = NULL;
  return temp;
}

// optional .ChatRejectMessage chatRejectMessage = 66;
inline bool PokerTHMessage::has_chatrejectmessage() const {
  return (_has_bits_[2] & 0x00000002u) != 0;
}
inline void PokerTHMessage::set_has_chatrejectmessage() {
  _has_bits_[2] |= 0x00000002u;
}
inline void PokerTHMessage::clear_has_chatrejectmessage() {
  _has_bits_[2] &= ~0x00000002u;
}
inline void PokerTHMessage::clear_chatrejectmessage() {
  if (chatrejectmessage_ != NULL) chatrejectmessage_->::ChatRejectMessage::Clear();
  clear_has_chatrejectmessage();
}
inline const ::ChatRejectMessage& PokerTHMessage::chatrejectmessage() const {
  return chatrejectmessage_ != NULL ? *chatrejectmessage_ : *default_instance_->chatrejectmessage_;
}
inline ::ChatRejectMessage* PokerTHMessage::mutable_chatrejectmessage() {
  set_has_chatrejectmessage();
  if (chatrejectmessage_ == NULL) chatrejectmessage_ = new ::ChatRejectMessage;
  return chatrejectmessage_;
}
inline ::ChatRejectMessage* PokerTHMessage::release_chatrejectmessage() {
  clear_has_chatrejectmessage();
  ::ChatRejectMessage* temp = chatrejectmessage_;
  chatrejectmessage_ = NULL;
  return temp;
}

// optional .DialogMessage dialogMessage = 67;
inline bool PokerTHMessage::has_dialogmessage() const {
  return (_has_bits_[2] & 0x00000004u) != 0;
}
inline void PokerTHMessage::set_has_dialogmessage() {
  _has_bits_[2] |= 0x00000004u;
}
inline void PokerTHMessage::clear_has_dialogmessage() {
  _has_bits_[2] &= ~0x00000004u;
}
inline void PokerTHMessage::clear_dialogmessage() {
  if (dialogmessage_ != NULL) dialogmessage_->::DialogMessage::Clear();
  clear_has_dialogmessage();
}
inline const ::DialogMessage& PokerTHMessage::dialogmessage() const {
  return dialogmessage_ != NULL ? *dialogmessage_ : *default_instance_->dialogmessage_;
}
inline ::DialogMessage* PokerTHMessage::mutable_dialogmessage() {
  set_has_dialogmessage();
  if (dialogmessage_ == NULL) dialogmessage_ = new ::DialogMessage;
  return dialogmessage_;
}
inline ::DialogMessage* PokerTHMessage::release_dialogmessage() {
  clear_has_dialogmessage();
  ::DialogMessage* temp = dialogmessage_;
  dialogmessage_ = NULL;
  return temp;
}

// optional .TimeoutWarningMessage timeoutWarningMessage = 68;
inline bool PokerTHMessage::has_timeoutwarningmessage() const {
  return (_has_bits_[2] & 0x00000008u) != 0;
}
inline void PokerTHMessage::set_has_timeoutwarningmessage() {
  _has_bits_[2] |= 0x00000008u;
}
inline void PokerTHMessage::clear_has_timeoutwarningmessage() {
  _has_bits_[2] &= ~0x00000008u;
}
inline void PokerTHMessage::clear_timeoutwarningmessage() {
  if (timeoutwarningmessage_ != NULL) timeoutwarningmessage_->::TimeoutWarningMessage::Clear();
  clear_has_timeoutwarningmessage();
}
inline const ::TimeoutWarningMessage& PokerTHMessage::timeoutwarningmessage() const {
  return timeoutwarningmessage_ != NULL ? *timeoutwarningmessage_ : *default_instance_->timeoutwarningmessage_;
}
inline ::TimeoutWarningMessage* PokerTHMessage::mutable_timeoutwarningmessage() {
  set_has_timeoutwarningmessage();
  if (timeoutwarningmessage_ == NULL) timeoutwarningmessage_ = new ::TimeoutWarningMessage;
  return timeoutwarningmessage_;
}
inline ::TimeoutWarningMessage* PokerTHMessage::release_timeoutwarningmessage() {
  clear_has_timeoutwarningmessage();
  ::TimeoutWarningMessage* temp = timeoutwarningmessage_;
  timeoutwarningmessage_ = NULL;
  return temp;
}

// optional .ResetTimeoutMessage resetTimeoutMessage = 69;
inline bool PokerTHMessage::has_resettimeoutmessage() const {
  return (_has_bits_[2] & 0x00000010u) != 0;
}
inline void PokerTHMessage::set_has_resettimeoutmessage() {
  _has_bits_[2] |= 0x00000010u;
}
inline void PokerTHMessage::clear_has_resettimeoutmessage() {
  _has_bits_[2] &= ~0x00000010u;
}
inline void PokerTHMessage::clear_resettimeoutmessage() {
  if (resettimeoutmessage_ != NULL) resettimeoutmessage_->::ResetTimeoutMessage::Clear();
  clear_has_resettimeoutmessage();
}
inline const ::ResetTimeoutMessage& PokerTHMessage::resettimeoutmessage() const {
  return resettimeoutmessage_ != NULL ? *resettimeoutmessage_ : *default_instance_->resettimeoutmessage_;
}
inline ::ResetTimeoutMessage* PokerTHMessage::mutable_resettimeoutmessage() {
  set_has_resettimeoutmessage();
  if (resettimeoutmessage_ == NULL) resettimeoutmessage_ = new ::ResetTimeoutMessage;
  return resettimeoutmessage_;
}
inline ::ResetTimeoutMessage* PokerTHMessage::release_resettimeoutmessage() {
  clear_has_resettimeoutmessage();
  ::ResetTimeoutMessage* temp = resettimeoutmessage_;
  resettimeoutmessage_ = NULL;
  return temp;
}

// optional .ReportAvatarMessage reportAvatarMessage = 70;
inline bool PokerTHMessage::has_reportavatarmessage() const {
  return (_has_bits_[2] & 0x00000020u) != 0;
}
inline void PokerTHMessage::set_has_reportavatarmessage() {
  _has_bits_[2] |= 0x00000020u;
}
inline void PokerTHMessage::clear_has_reportavatarmessage() {
  _has_bits_[2] &= ~0x00000020u;
}
inline void PokerTHMessage::clear_reportavatarmessage() {
  if (reportavatarmessage_ != NULL) reportavatarmessage_->::ReportAvatarMessage::Clear();
  clear_has_reportavatarmessage();
}
inline const ::ReportAvatarMessage& PokerTHMessage::reportavatarmessage() const {
  return reportavatarmessage_ != NULL ? *reportavatarmessage_ : *default_instance_->reportavatarmessage_;
}
inline ::ReportAvatarMessage* PokerTHMessage::mutable_reportavatarmessage() {
  set_has_reportavatarmessage();
  if (reportavatarmessage_ == NULL) reportavatarmessage_ = new ::ReportAvatarMessage;
  return reportavatarmessage_;
}
inline ::ReportAvatarMessage* PokerTHMessage::release_reportavatarmessage() {
  clear_has_reportavatarmessage();
  ::ReportAvatarMessage* temp = reportavatarmessage_;
  reportavatarmessage_ = NULL;
  return temp;
}

// optional .ReportAvatarAckMessage reportAvatarAckMessage = 71;
inline bool PokerTHMessage::has_reportavatarackmessage() const {
  return (_has_bits_[2] & 0x00000040u) != 0;
}
inline void PokerTHMessage::set_has_reportavatarackmessage() {
  _has_bits_[2] |= 0x00000040u;
}
inline void PokerTHMessage::clear_has_reportavatarackmessage() {
  _has_bits_[2] &= ~0x00000040u;
}
inline void PokerTHMessage::clear_reportavatarackmessage() {
  if (reportavatarackmessage_ != NULL) reportavatarackmessage_->::ReportAvatarAckMessage::Clear();
  clear_has_reportavatarackmessage();
}
inline const ::ReportAvatarAckMessage& PokerTHMessage::reportavatarackmessage() const {
  return reportavatarackmessage_ != NULL ? *reportavatarackmessage_ : *default_instance_->reportavatarackmessage_;
}
inline ::ReportAvatarAckMessage* PokerTHMessage::mutable_reportavatarackmessage() {
  set_has_reportavatarackmessage();
  if (reportavatarackmessage_ == NULL) reportavatarackmessage_ = new ::ReportAvatarAckMessage;
  return reportavatarackmessage_;
}
inline ::ReportAvatarAckMessage* PokerTHMessage::release_reportavatarackmessage() {
  clear_has_reportavatarackmessage();
  ::ReportAvatarAckMessage* temp = reportavatarackmessage_;
  reportavatarackmessage_ = NULL;
  return temp;
}

// optional .ReportGameMessage reportGameMessage = 72;
inline bool PokerTHMessage::has_reportgamemessage() const {
  return (_has_bits_[2] & 0x00000080u) != 0;
}
inline void PokerTHMessage::set_has_reportgamemessage() {
  _has_bits_[2] |= 0x00000080u;
}
inline void PokerTHMessage::clear_has_reportgamemessage() {
  _has_bits_[2] &= ~0x00000080u;
}
inline void PokerTHMessage::clear_reportgamemessage() {
  if (reportgamemessage_ != NULL) reportgamemessage_->::ReportGameMessage::Clear();
  clear_has_reportgamemessage();
}
inline const ::ReportGameMessage& PokerTHMessage::reportgamemessage() const {
  return reportgamemessage_ != NULL ? *reportgamemessage_ : *default_instance_->reportgamemessage_;
}
inline ::ReportGameMessage* PokerTHMessage::mutable_reportgamemessage() {
  set_has_reportgamemessage();
  if (reportgamemessage_ == NULL) reportgamemessage_ = new ::ReportGameMessage;
  return reportgamemessage_;
}
inline ::ReportGameMessage* PokerTHMessage::release_reportgamemessage() {
  clear_has_reportgamemessage();
  ::ReportGameMessage* temp = reportgamemessage_;
  reportgamemessage_ = NULL;
  return temp;
}

// optional .ReportGameAckMessage reportGameAckMessage = 73;
inline bool PokerTHMessage::has_reportgameackmessage() const {
  return (_has_bits_[2] & 0x00000100u) != 0;
}
inline void PokerTHMessage::set_has_reportgameackmessage() {
  _has_bits_[2] |= 0x00000100u;
}
inline void PokerTHMessage::clear_has_reportgameackmessage() {
  _has_bits_[2] &= ~0x00000100u;
}
inline void PokerTHMessage::clear_reportgameackmessage() {
  if (reportgameackmessage_ != NULL) reportgameackmessage_->::ReportGameAckMessage::Clear();
  clear_has_reportgameackmessage();
}
inline const ::ReportGameAckMessage& PokerTHMessage::reportgameackmessage() const {
  return reportgameackmessage_ != NULL ? *reportgameackmessage_ : *default_instance_->reportgameackmessage_;
}
inline ::ReportGameAckMessage* PokerTHMessage::mutable_reportgameackmessage() {
  set_has_reportgameackmessage();
  if (reportgameackmessage_ == NULL) reportgameackmessage_ = new ::ReportGameAckMessage;
  return reportgameackmessage_;
}
inline ::ReportGameAckMessage* PokerTHMessage::release_reportgameackmessage() {
  clear_has_reportgameackmessage();
  ::ReportGameAckMessage* temp = reportgameackmessage_;
  reportgameackmessage_ = NULL;
  return temp;
}

// optional .ErrorMessage errorMessage = 74;
inline bool PokerTHMessage::has_errormessage() const {
  return (_has_bits_[2] & 0x00000200u) != 0;
}
inline void PokerTHMessage::set_has_errormessage() {
  _has_bits_[2] |= 0x00000200u;
}
inline void PokerTHMessage::clear_has_errormessage() {
  _has_bits_[2] &= ~0x00000200u;
}
inline void PokerTHMessage::clear_errormessage() {
  if (errormessage_ != NULL) errormessage_->::ErrorMessage::Clear();
  clear_has_errormessage();
}
inline const ::ErrorMessage& PokerTHMessage::errormessage() const {
  return errormessage_ != NULL ? *errormessage_ : *default_instance_->errormessage_;
}
inline ::ErrorMessage* PokerTHMessage::mutable_errormessage() {
  set_has_errormessage();
  if (errormessage_ == NULL) errormessage_ = new ::ErrorMessage;
  return errormessage_;
}
inline ::ErrorMessage* PokerTHMessage::release_errormessage() {
  clear_has_errormessage();
  ::ErrorMessage* temp = errormessage_;
  errormessage_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pokerth_2eproto__INCLUDED
