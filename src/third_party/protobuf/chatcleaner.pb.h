// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chatcleaner.proto

#ifndef PROTOBUF_chatcleaner_2eproto__INCLUDED
#define PROTOBUF_chatcleaner_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_chatcleaner_2eproto();
void protobuf_AssignDesc_chatcleaner_2eproto();
void protobuf_ShutdownFile_chatcleaner_2eproto();

class CleanerInitMessage;
class CleanerInitAckMessage;
class CleanerChatRequestMessage;
class CleanerChatReplyMessage;
class ChatCleanerMessage;

enum CleanerChatReplyMessage_CleanerActionType {
  CleanerChatReplyMessage_CleanerActionType_cleanerActionNone = 0,
  CleanerChatReplyMessage_CleanerActionType_cleanerActionWarning = 1,
  CleanerChatReplyMessage_CleanerActionType_cleanerActionKick = 2,
  CleanerChatReplyMessage_CleanerActionType_cleanerActionBan = 3,
  CleanerChatReplyMessage_CleanerActionType_cleanerActionMute = 4
};
bool CleanerChatReplyMessage_CleanerActionType_IsValid(int value);
const CleanerChatReplyMessage_CleanerActionType CleanerChatReplyMessage_CleanerActionType_CleanerActionType_MIN = CleanerChatReplyMessage_CleanerActionType_cleanerActionNone;
const CleanerChatReplyMessage_CleanerActionType CleanerChatReplyMessage_CleanerActionType_CleanerActionType_MAX = CleanerChatReplyMessage_CleanerActionType_cleanerActionMute;
const int CleanerChatReplyMessage_CleanerActionType_CleanerActionType_ARRAYSIZE = CleanerChatReplyMessage_CleanerActionType_CleanerActionType_MAX + 1;

enum ChatCleanerMessage_ChatCleanerMessageType {
  ChatCleanerMessage_ChatCleanerMessageType_Type_CleanerInitMessage = 1,
  ChatCleanerMessage_ChatCleanerMessageType_Type_CleanerInitAckMessage = 2,
  ChatCleanerMessage_ChatCleanerMessageType_Type_CleanerChatRequestMessage = 3,
  ChatCleanerMessage_ChatCleanerMessageType_Type_CleanerChatReplyMessage = 4
};
bool ChatCleanerMessage_ChatCleanerMessageType_IsValid(int value);
const ChatCleanerMessage_ChatCleanerMessageType ChatCleanerMessage_ChatCleanerMessageType_ChatCleanerMessageType_MIN = ChatCleanerMessage_ChatCleanerMessageType_Type_CleanerInitMessage;
const ChatCleanerMessage_ChatCleanerMessageType ChatCleanerMessage_ChatCleanerMessageType_ChatCleanerMessageType_MAX = ChatCleanerMessage_ChatCleanerMessageType_Type_CleanerChatReplyMessage;
const int ChatCleanerMessage_ChatCleanerMessageType_ChatCleanerMessageType_ARRAYSIZE = ChatCleanerMessage_ChatCleanerMessageType_ChatCleanerMessageType_MAX + 1;

enum CleanerChatType {
  cleanerChatTypeLobby = 0,
  cleanerChatTypeGame = 1
};
bool CleanerChatType_IsValid(int value);
const CleanerChatType CleanerChatType_MIN = cleanerChatTypeLobby;
const CleanerChatType CleanerChatType_MAX = cleanerChatTypeGame;
const int CleanerChatType_ARRAYSIZE = CleanerChatType_MAX + 1;

// ===================================================================

class CleanerInitMessage : public ::google::protobuf::MessageLite {
 public:
  CleanerInitMessage();
  virtual ~CleanerInitMessage();

  CleanerInitMessage(const CleanerInitMessage& from);

  inline CleanerInitMessage& operator=(const CleanerInitMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CleanerInitMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CleanerInitMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CleanerInitMessage* other);

  // implements Message ----------------------------------------------

  CleanerInitMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CleanerInitMessage& from);
  void MergeFrom(const CleanerInitMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 requestedVersion = 1;
  inline bool has_requestedversion() const;
  inline void clear_requestedversion();
  static const int kRequestedVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 requestedversion() const;
  inline void set_requestedversion(::google::protobuf::uint32 value);

  // required string clientSecret = 2;
  inline bool has_clientsecret() const;
  inline void clear_clientsecret();
  static const int kClientSecretFieldNumber = 2;
  inline const ::std::string& clientsecret() const;
  inline void set_clientsecret(const ::std::string& value);
  inline void set_clientsecret(const char* value);
  inline void set_clientsecret(const char* value, size_t size);
  inline ::std::string* mutable_clientsecret();
  inline ::std::string* release_clientsecret();
  inline void set_allocated_clientsecret(::std::string* clientsecret);

  // @@protoc_insertion_point(class_scope:CleanerInitMessage)
 private:
  inline void set_has_requestedversion();
  inline void clear_has_requestedversion();
  inline void set_has_clientsecret();
  inline void clear_has_clientsecret();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* clientsecret_;
  ::google::protobuf::uint32 requestedversion_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_chatcleaner_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_chatcleaner_2eproto();
  #endif
  friend void protobuf_AssignDesc_chatcleaner_2eproto();
  friend void protobuf_ShutdownFile_chatcleaner_2eproto();

  void InitAsDefaultInstance();
  static CleanerInitMessage* default_instance_;
};
// -------------------------------------------------------------------

class CleanerInitAckMessage : public ::google::protobuf::MessageLite {
 public:
  CleanerInitAckMessage();
  virtual ~CleanerInitAckMessage();

  CleanerInitAckMessage(const CleanerInitAckMessage& from);

  inline CleanerInitAckMessage& operator=(const CleanerInitAckMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CleanerInitAckMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CleanerInitAckMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CleanerInitAckMessage* other);

  // implements Message ----------------------------------------------

  CleanerInitAckMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CleanerInitAckMessage& from);
  void MergeFrom(const CleanerInitAckMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 serverVersion = 1;
  inline bool has_serverversion() const;
  inline void clear_serverversion();
  static const int kServerVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 serverversion() const;
  inline void set_serverversion(::google::protobuf::uint32 value);

  // required string serverSecret = 2;
  inline bool has_serversecret() const;
  inline void clear_serversecret();
  static const int kServerSecretFieldNumber = 2;
  inline const ::std::string& serversecret() const;
  inline void set_serversecret(const ::std::string& value);
  inline void set_serversecret(const char* value);
  inline void set_serversecret(const char* value, size_t size);
  inline ::std::string* mutable_serversecret();
  inline ::std::string* release_serversecret();
  inline void set_allocated_serversecret(::std::string* serversecret);

  // @@protoc_insertion_point(class_scope:CleanerInitAckMessage)
 private:
  inline void set_has_serverversion();
  inline void clear_has_serverversion();
  inline void set_has_serversecret();
  inline void clear_has_serversecret();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* serversecret_;
  ::google::protobuf::uint32 serverversion_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_chatcleaner_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_chatcleaner_2eproto();
  #endif
  friend void protobuf_AssignDesc_chatcleaner_2eproto();
  friend void protobuf_ShutdownFile_chatcleaner_2eproto();

  void InitAsDefaultInstance();
  static CleanerInitAckMessage* default_instance_;
};
// -------------------------------------------------------------------

class CleanerChatRequestMessage : public ::google::protobuf::MessageLite {
 public:
  CleanerChatRequestMessage();
  virtual ~CleanerChatRequestMessage();

  CleanerChatRequestMessage(const CleanerChatRequestMessage& from);

  inline CleanerChatRequestMessage& operator=(const CleanerChatRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CleanerChatRequestMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CleanerChatRequestMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CleanerChatRequestMessage* other);

  // implements Message ----------------------------------------------

  CleanerChatRequestMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CleanerChatRequestMessage& from);
  void MergeFrom(const CleanerChatRequestMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 requestId = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint32 requestid() const;
  inline void set_requestid(::google::protobuf::uint32 value);

  // required .CleanerChatType cleanerChatType = 2;
  inline bool has_cleanerchattype() const;
  inline void clear_cleanerchattype();
  static const int kCleanerChatTypeFieldNumber = 2;
  inline ::CleanerChatType cleanerchattype() const;
  inline void set_cleanerchattype(::CleanerChatType value);

  // optional uint32 gameId = 3 [default = 0];
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 3;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 4;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 4;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // required string playerName = 5;
  inline bool has_playername() const;
  inline void clear_playername();
  static const int kPlayerNameFieldNumber = 5;
  inline const ::std::string& playername() const;
  inline void set_playername(const ::std::string& value);
  inline void set_playername(const char* value);
  inline void set_playername(const char* value, size_t size);
  inline ::std::string* mutable_playername();
  inline ::std::string* release_playername();
  inline void set_allocated_playername(::std::string* playername);

  // required string chatMessage = 6;
  inline bool has_chatmessage() const;
  inline void clear_chatmessage();
  static const int kChatMessageFieldNumber = 6;
  inline const ::std::string& chatmessage() const;
  inline void set_chatmessage(const ::std::string& value);
  inline void set_chatmessage(const char* value);
  inline void set_chatmessage(const char* value, size_t size);
  inline ::std::string* mutable_chatmessage();
  inline ::std::string* release_chatmessage();
  inline void set_allocated_chatmessage(::std::string* chatmessage);

  // @@protoc_insertion_point(class_scope:CleanerChatRequestMessage)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_cleanerchattype();
  inline void clear_has_cleanerchattype();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_playername();
  inline void clear_has_playername();
  inline void set_has_chatmessage();
  inline void clear_has_chatmessage();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 requestid_;
  int cleanerchattype_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  ::std::string* playername_;
  ::std::string* chatmessage_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_chatcleaner_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_chatcleaner_2eproto();
  #endif
  friend void protobuf_AssignDesc_chatcleaner_2eproto();
  friend void protobuf_ShutdownFile_chatcleaner_2eproto();

  void InitAsDefaultInstance();
  static CleanerChatRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class CleanerChatReplyMessage : public ::google::protobuf::MessageLite {
 public:
  CleanerChatReplyMessage();
  virtual ~CleanerChatReplyMessage();

  CleanerChatReplyMessage(const CleanerChatReplyMessage& from);

  inline CleanerChatReplyMessage& operator=(const CleanerChatReplyMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CleanerChatReplyMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CleanerChatReplyMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CleanerChatReplyMessage* other);

  // implements Message ----------------------------------------------

  CleanerChatReplyMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CleanerChatReplyMessage& from);
  void MergeFrom(const CleanerChatReplyMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CleanerChatReplyMessage_CleanerActionType CleanerActionType;
  static const CleanerActionType cleanerActionNone = CleanerChatReplyMessage_CleanerActionType_cleanerActionNone;
  static const CleanerActionType cleanerActionWarning = CleanerChatReplyMessage_CleanerActionType_cleanerActionWarning;
  static const CleanerActionType cleanerActionKick = CleanerChatReplyMessage_CleanerActionType_cleanerActionKick;
  static const CleanerActionType cleanerActionBan = CleanerChatReplyMessage_CleanerActionType_cleanerActionBan;
  static const CleanerActionType cleanerActionMute = CleanerChatReplyMessage_CleanerActionType_cleanerActionMute;
  static inline bool CleanerActionType_IsValid(int value) {
    return CleanerChatReplyMessage_CleanerActionType_IsValid(value);
  }
  static const CleanerActionType CleanerActionType_MIN =
    CleanerChatReplyMessage_CleanerActionType_CleanerActionType_MIN;
  static const CleanerActionType CleanerActionType_MAX =
    CleanerChatReplyMessage_CleanerActionType_CleanerActionType_MAX;
  static const int CleanerActionType_ARRAYSIZE =
    CleanerChatReplyMessage_CleanerActionType_CleanerActionType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 requestId = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint32 requestid() const;
  inline void set_requestid(::google::protobuf::uint32 value);

  // required .CleanerChatType cleanerChatType = 2;
  inline bool has_cleanerchattype() const;
  inline void clear_cleanerchattype();
  static const int kCleanerChatTypeFieldNumber = 2;
  inline ::CleanerChatType cleanerchattype() const;
  inline void set_cleanerchattype(::CleanerChatType value);

  // optional uint32 gameId = 3 [default = 0];
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 3;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 4;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 4;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // required .CleanerChatReplyMessage.CleanerActionType cleanerActionType = 5;
  inline bool has_cleaneractiontype() const;
  inline void clear_cleaneractiontype();
  static const int kCleanerActionTypeFieldNumber = 5;
  inline ::CleanerChatReplyMessage_CleanerActionType cleaneractiontype() const;
  inline void set_cleaneractiontype(::CleanerChatReplyMessage_CleanerActionType value);

  // optional string cleanerText = 6 [default = ""];
  inline bool has_cleanertext() const;
  inline void clear_cleanertext();
  static const int kCleanerTextFieldNumber = 6;
  inline const ::std::string& cleanertext() const;
  inline void set_cleanertext(const ::std::string& value);
  inline void set_cleanertext(const char* value);
  inline void set_cleanertext(const char* value, size_t size);
  inline ::std::string* mutable_cleanertext();
  inline ::std::string* release_cleanertext();
  inline void set_allocated_cleanertext(::std::string* cleanertext);

  // @@protoc_insertion_point(class_scope:CleanerChatReplyMessage)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_cleanerchattype();
  inline void clear_has_cleanerchattype();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_cleaneractiontype();
  inline void clear_has_cleaneractiontype();
  inline void set_has_cleanertext();
  inline void clear_has_cleanertext();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 requestid_;
  int cleanerchattype_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  ::std::string* cleanertext_;
  int cleaneractiontype_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_chatcleaner_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_chatcleaner_2eproto();
  #endif
  friend void protobuf_AssignDesc_chatcleaner_2eproto();
  friend void protobuf_ShutdownFile_chatcleaner_2eproto();

  void InitAsDefaultInstance();
  static CleanerChatReplyMessage* default_instance_;
};
// -------------------------------------------------------------------

class ChatCleanerMessage : public ::google::protobuf::MessageLite {
 public:
  ChatCleanerMessage();
  virtual ~ChatCleanerMessage();

  ChatCleanerMessage(const ChatCleanerMessage& from);

  inline ChatCleanerMessage& operator=(const ChatCleanerMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ChatCleanerMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChatCleanerMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChatCleanerMessage* other);

  // implements Message ----------------------------------------------

  ChatCleanerMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChatCleanerMessage& from);
  void MergeFrom(const ChatCleanerMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ChatCleanerMessage_ChatCleanerMessageType ChatCleanerMessageType;
  static const ChatCleanerMessageType Type_CleanerInitMessage = ChatCleanerMessage_ChatCleanerMessageType_Type_CleanerInitMessage;
  static const ChatCleanerMessageType Type_CleanerInitAckMessage = ChatCleanerMessage_ChatCleanerMessageType_Type_CleanerInitAckMessage;
  static const ChatCleanerMessageType Type_CleanerChatRequestMessage = ChatCleanerMessage_ChatCleanerMessageType_Type_CleanerChatRequestMessage;
  static const ChatCleanerMessageType Type_CleanerChatReplyMessage = ChatCleanerMessage_ChatCleanerMessageType_Type_CleanerChatReplyMessage;
  static inline bool ChatCleanerMessageType_IsValid(int value) {
    return ChatCleanerMessage_ChatCleanerMessageType_IsValid(value);
  }
  static const ChatCleanerMessageType ChatCleanerMessageType_MIN =
    ChatCleanerMessage_ChatCleanerMessageType_ChatCleanerMessageType_MIN;
  static const ChatCleanerMessageType ChatCleanerMessageType_MAX =
    ChatCleanerMessage_ChatCleanerMessageType_ChatCleanerMessageType_MAX;
  static const int ChatCleanerMessageType_ARRAYSIZE =
    ChatCleanerMessage_ChatCleanerMessageType_ChatCleanerMessageType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .ChatCleanerMessage.ChatCleanerMessageType messageType = 1;
  inline bool has_messagetype() const;
  inline void clear_messagetype();
  static const int kMessageTypeFieldNumber = 1;
  inline ::ChatCleanerMessage_ChatCleanerMessageType messagetype() const;
  inline void set_messagetype(::ChatCleanerMessage_ChatCleanerMessageType value);

  // optional .CleanerInitMessage cleanerInitMessage = 2;
  inline bool has_cleanerinitmessage() const;
  inline void clear_cleanerinitmessage();
  static const int kCleanerInitMessageFieldNumber = 2;
  inline const ::CleanerInitMessage& cleanerinitmessage() const;
  inline ::CleanerInitMessage* mutable_cleanerinitmessage();
  inline ::CleanerInitMessage* release_cleanerinitmessage();
  inline void set_allocated_cleanerinitmessage(::CleanerInitMessage* cleanerinitmessage);

  // optional .CleanerInitAckMessage cleanerInitAckMessage = 3;
  inline bool has_cleanerinitackmessage() const;
  inline void clear_cleanerinitackmessage();
  static const int kCleanerInitAckMessageFieldNumber = 3;
  inline const ::CleanerInitAckMessage& cleanerinitackmessage() const;
  inline ::CleanerInitAckMessage* mutable_cleanerinitackmessage();
  inline ::CleanerInitAckMessage* release_cleanerinitackmessage();
  inline void set_allocated_cleanerinitackmessage(::CleanerInitAckMessage* cleanerinitackmessage);

  // optional .CleanerChatRequestMessage cleanerChatRequestMessage = 4;
  inline bool has_cleanerchatrequestmessage() const;
  inline void clear_cleanerchatrequestmessage();
  static const int kCleanerChatRequestMessageFieldNumber = 4;
  inline const ::CleanerChatRequestMessage& cleanerchatrequestmessage() const;
  inline ::CleanerChatRequestMessage* mutable_cleanerchatrequestmessage();
  inline ::CleanerChatRequestMessage* release_cleanerchatrequestmessage();
  inline void set_allocated_cleanerchatrequestmessage(::CleanerChatRequestMessage* cleanerchatrequestmessage);

  // optional .CleanerChatReplyMessage cleanerChatReplyMessage = 5;
  inline bool has_cleanerchatreplymessage() const;
  inline void clear_cleanerchatreplymessage();
  static const int kCleanerChatReplyMessageFieldNumber = 5;
  inline const ::CleanerChatReplyMessage& cleanerchatreplymessage() const;
  inline ::CleanerChatReplyMessage* mutable_cleanerchatreplymessage();
  inline ::CleanerChatReplyMessage* release_cleanerchatreplymessage();
  inline void set_allocated_cleanerchatreplymessage(::CleanerChatReplyMessage* cleanerchatreplymessage);

  // @@protoc_insertion_point(class_scope:ChatCleanerMessage)
 private:
  inline void set_has_messagetype();
  inline void clear_has_messagetype();
  inline void set_has_cleanerinitmessage();
  inline void clear_has_cleanerinitmessage();
  inline void set_has_cleanerinitackmessage();
  inline void clear_has_cleanerinitackmessage();
  inline void set_has_cleanerchatrequestmessage();
  inline void clear_has_cleanerchatrequestmessage();
  inline void set_has_cleanerchatreplymessage();
  inline void clear_has_cleanerchatreplymessage();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::CleanerInitMessage* cleanerinitmessage_;
  ::CleanerInitAckMessage* cleanerinitackmessage_;
  ::CleanerChatRequestMessage* cleanerchatrequestmessage_;
  ::CleanerChatReplyMessage* cleanerchatreplymessage_;
  int messagetype_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_chatcleaner_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_chatcleaner_2eproto();
  #endif
  friend void protobuf_AssignDesc_chatcleaner_2eproto();
  friend void protobuf_ShutdownFile_chatcleaner_2eproto();

  void InitAsDefaultInstance();
  static ChatCleanerMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// CleanerInitMessage

// required uint32 requestedVersion = 1;
inline bool CleanerInitMessage::has_requestedversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CleanerInitMessage::set_has_requestedversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CleanerInitMessage::clear_has_requestedversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CleanerInitMessage::clear_requestedversion() {
  requestedversion_ = 0u;
  clear_has_requestedversion();
}
inline ::google::protobuf::uint32 CleanerInitMessage::requestedversion() const {
  // @@protoc_insertion_point(field_get:CleanerInitMessage.requestedVersion)
  return requestedversion_;
}
inline void CleanerInitMessage::set_requestedversion(::google::protobuf::uint32 value) {
  set_has_requestedversion();
  requestedversion_ = value;
  // @@protoc_insertion_point(field_set:CleanerInitMessage.requestedVersion)
}

// required string clientSecret = 2;
inline bool CleanerInitMessage::has_clientsecret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CleanerInitMessage::set_has_clientsecret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CleanerInitMessage::clear_has_clientsecret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CleanerInitMessage::clear_clientsecret() {
  if (clientsecret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientsecret_->clear();
  }
  clear_has_clientsecret();
}
inline const ::std::string& CleanerInitMessage::clientsecret() const {
  // @@protoc_insertion_point(field_get:CleanerInitMessage.clientSecret)
  return *clientsecret_;
}
inline void CleanerInitMessage::set_clientsecret(const ::std::string& value) {
  set_has_clientsecret();
  if (clientsecret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientsecret_ = new ::std::string;
  }
  clientsecret_->assign(value);
  // @@protoc_insertion_point(field_set:CleanerInitMessage.clientSecret)
}
inline void CleanerInitMessage::set_clientsecret(const char* value) {
  set_has_clientsecret();
  if (clientsecret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientsecret_ = new ::std::string;
  }
  clientsecret_->assign(value);
  // @@protoc_insertion_point(field_set_char:CleanerInitMessage.clientSecret)
}
inline void CleanerInitMessage::set_clientsecret(const char* value, size_t size) {
  set_has_clientsecret();
  if (clientsecret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientsecret_ = new ::std::string;
  }
  clientsecret_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CleanerInitMessage.clientSecret)
}
inline ::std::string* CleanerInitMessage::mutable_clientsecret() {
  set_has_clientsecret();
  if (clientsecret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientsecret_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CleanerInitMessage.clientSecret)
  return clientsecret_;
}
inline ::std::string* CleanerInitMessage::release_clientsecret() {
  clear_has_clientsecret();
  if (clientsecret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = clientsecret_;
    clientsecret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CleanerInitMessage::set_allocated_clientsecret(::std::string* clientsecret) {
  if (clientsecret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete clientsecret_;
  }
  if (clientsecret) {
    set_has_clientsecret();
    clientsecret_ = clientsecret;
  } else {
    clear_has_clientsecret();
    clientsecret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CleanerInitMessage.clientSecret)
}

// -------------------------------------------------------------------

// CleanerInitAckMessage

// required uint32 serverVersion = 1;
inline bool CleanerInitAckMessage::has_serverversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CleanerInitAckMessage::set_has_serverversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CleanerInitAckMessage::clear_has_serverversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CleanerInitAckMessage::clear_serverversion() {
  serverversion_ = 0u;
  clear_has_serverversion();
}
inline ::google::protobuf::uint32 CleanerInitAckMessage::serverversion() const {
  // @@protoc_insertion_point(field_get:CleanerInitAckMessage.serverVersion)
  return serverversion_;
}
inline void CleanerInitAckMessage::set_serverversion(::google::protobuf::uint32 value) {
  set_has_serverversion();
  serverversion_ = value;
  // @@protoc_insertion_point(field_set:CleanerInitAckMessage.serverVersion)
}

// required string serverSecret = 2;
inline bool CleanerInitAckMessage::has_serversecret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CleanerInitAckMessage::set_has_serversecret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CleanerInitAckMessage::clear_has_serversecret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CleanerInitAckMessage::clear_serversecret() {
  if (serversecret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serversecret_->clear();
  }
  clear_has_serversecret();
}
inline const ::std::string& CleanerInitAckMessage::serversecret() const {
  // @@protoc_insertion_point(field_get:CleanerInitAckMessage.serverSecret)
  return *serversecret_;
}
inline void CleanerInitAckMessage::set_serversecret(const ::std::string& value) {
  set_has_serversecret();
  if (serversecret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serversecret_ = new ::std::string;
  }
  serversecret_->assign(value);
  // @@protoc_insertion_point(field_set:CleanerInitAckMessage.serverSecret)
}
inline void CleanerInitAckMessage::set_serversecret(const char* value) {
  set_has_serversecret();
  if (serversecret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serversecret_ = new ::std::string;
  }
  serversecret_->assign(value);
  // @@protoc_insertion_point(field_set_char:CleanerInitAckMessage.serverSecret)
}
inline void CleanerInitAckMessage::set_serversecret(const char* value, size_t size) {
  set_has_serversecret();
  if (serversecret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serversecret_ = new ::std::string;
  }
  serversecret_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CleanerInitAckMessage.serverSecret)
}
inline ::std::string* CleanerInitAckMessage::mutable_serversecret() {
  set_has_serversecret();
  if (serversecret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serversecret_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CleanerInitAckMessage.serverSecret)
  return serversecret_;
}
inline ::std::string* CleanerInitAckMessage::release_serversecret() {
  clear_has_serversecret();
  if (serversecret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = serversecret_;
    serversecret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CleanerInitAckMessage::set_allocated_serversecret(::std::string* serversecret) {
  if (serversecret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete serversecret_;
  }
  if (serversecret) {
    set_has_serversecret();
    serversecret_ = serversecret;
  } else {
    clear_has_serversecret();
    serversecret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CleanerInitAckMessage.serverSecret)
}

// -------------------------------------------------------------------

// CleanerChatRequestMessage

// required uint32 requestId = 1;
inline bool CleanerChatRequestMessage::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CleanerChatRequestMessage::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CleanerChatRequestMessage::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CleanerChatRequestMessage::clear_requestid() {
  requestid_ = 0u;
  clear_has_requestid();
}
inline ::google::protobuf::uint32 CleanerChatRequestMessage::requestid() const {
  // @@protoc_insertion_point(field_get:CleanerChatRequestMessage.requestId)
  return requestid_;
}
inline void CleanerChatRequestMessage::set_requestid(::google::protobuf::uint32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:CleanerChatRequestMessage.requestId)
}

// required .CleanerChatType cleanerChatType = 2;
inline bool CleanerChatRequestMessage::has_cleanerchattype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CleanerChatRequestMessage::set_has_cleanerchattype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CleanerChatRequestMessage::clear_has_cleanerchattype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CleanerChatRequestMessage::clear_cleanerchattype() {
  cleanerchattype_ = 0;
  clear_has_cleanerchattype();
}
inline ::CleanerChatType CleanerChatRequestMessage::cleanerchattype() const {
  // @@protoc_insertion_point(field_get:CleanerChatRequestMessage.cleanerChatType)
  return static_cast< ::CleanerChatType >(cleanerchattype_);
}
inline void CleanerChatRequestMessage::set_cleanerchattype(::CleanerChatType value) {
  assert(::CleanerChatType_IsValid(value));
  set_has_cleanerchattype();
  cleanerchattype_ = value;
  // @@protoc_insertion_point(field_set:CleanerChatRequestMessage.cleanerChatType)
}

// optional uint32 gameId = 3 [default = 0];
inline bool CleanerChatRequestMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CleanerChatRequestMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CleanerChatRequestMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CleanerChatRequestMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 CleanerChatRequestMessage::gameid() const {
  // @@protoc_insertion_point(field_get:CleanerChatRequestMessage.gameId)
  return gameid_;
}
inline void CleanerChatRequestMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:CleanerChatRequestMessage.gameId)
}

// required uint32 playerId = 4;
inline bool CleanerChatRequestMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CleanerChatRequestMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CleanerChatRequestMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CleanerChatRequestMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 CleanerChatRequestMessage::playerid() const {
  // @@protoc_insertion_point(field_get:CleanerChatRequestMessage.playerId)
  return playerid_;
}
inline void CleanerChatRequestMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:CleanerChatRequestMessage.playerId)
}

// required string playerName = 5;
inline bool CleanerChatRequestMessage::has_playername() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CleanerChatRequestMessage::set_has_playername() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CleanerChatRequestMessage::clear_has_playername() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CleanerChatRequestMessage::clear_playername() {
  if (playername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playername_->clear();
  }
  clear_has_playername();
}
inline const ::std::string& CleanerChatRequestMessage::playername() const {
  // @@protoc_insertion_point(field_get:CleanerChatRequestMessage.playerName)
  return *playername_;
}
inline void CleanerChatRequestMessage::set_playername(const ::std::string& value) {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playername_ = new ::std::string;
  }
  playername_->assign(value);
  // @@protoc_insertion_point(field_set:CleanerChatRequestMessage.playerName)
}
inline void CleanerChatRequestMessage::set_playername(const char* value) {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playername_ = new ::std::string;
  }
  playername_->assign(value);
  // @@protoc_insertion_point(field_set_char:CleanerChatRequestMessage.playerName)
}
inline void CleanerChatRequestMessage::set_playername(const char* value, size_t size) {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playername_ = new ::std::string;
  }
  playername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CleanerChatRequestMessage.playerName)
}
inline ::std::string* CleanerChatRequestMessage::mutable_playername() {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CleanerChatRequestMessage.playerName)
  return playername_;
}
inline ::std::string* CleanerChatRequestMessage::release_playername() {
  clear_has_playername();
  if (playername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = playername_;
    playername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CleanerChatRequestMessage::set_allocated_playername(::std::string* playername) {
  if (playername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete playername_;
  }
  if (playername) {
    set_has_playername();
    playername_ = playername;
  } else {
    clear_has_playername();
    playername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CleanerChatRequestMessage.playerName)
}

// required string chatMessage = 6;
inline bool CleanerChatRequestMessage::has_chatmessage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CleanerChatRequestMessage::set_has_chatmessage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CleanerChatRequestMessage::clear_has_chatmessage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CleanerChatRequestMessage::clear_chatmessage() {
  if (chatmessage_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chatmessage_->clear();
  }
  clear_has_chatmessage();
}
inline const ::std::string& CleanerChatRequestMessage::chatmessage() const {
  // @@protoc_insertion_point(field_get:CleanerChatRequestMessage.chatMessage)
  return *chatmessage_;
}
inline void CleanerChatRequestMessage::set_chatmessage(const ::std::string& value) {
  set_has_chatmessage();
  if (chatmessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chatmessage_ = new ::std::string;
  }
  chatmessage_->assign(value);
  // @@protoc_insertion_point(field_set:CleanerChatRequestMessage.chatMessage)
}
inline void CleanerChatRequestMessage::set_chatmessage(const char* value) {
  set_has_chatmessage();
  if (chatmessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chatmessage_ = new ::std::string;
  }
  chatmessage_->assign(value);
  // @@protoc_insertion_point(field_set_char:CleanerChatRequestMessage.chatMessage)
}
inline void CleanerChatRequestMessage::set_chatmessage(const char* value, size_t size) {
  set_has_chatmessage();
  if (chatmessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chatmessage_ = new ::std::string;
  }
  chatmessage_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CleanerChatRequestMessage.chatMessage)
}
inline ::std::string* CleanerChatRequestMessage::mutable_chatmessage() {
  set_has_chatmessage();
  if (chatmessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chatmessage_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CleanerChatRequestMessage.chatMessage)
  return chatmessage_;
}
inline ::std::string* CleanerChatRequestMessage::release_chatmessage() {
  clear_has_chatmessage();
  if (chatmessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = chatmessage_;
    chatmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CleanerChatRequestMessage::set_allocated_chatmessage(::std::string* chatmessage) {
  if (chatmessage_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete chatmessage_;
  }
  if (chatmessage) {
    set_has_chatmessage();
    chatmessage_ = chatmessage;
  } else {
    clear_has_chatmessage();
    chatmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CleanerChatRequestMessage.chatMessage)
}

// -------------------------------------------------------------------

// CleanerChatReplyMessage

// required uint32 requestId = 1;
inline bool CleanerChatReplyMessage::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CleanerChatReplyMessage::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CleanerChatReplyMessage::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CleanerChatReplyMessage::clear_requestid() {
  requestid_ = 0u;
  clear_has_requestid();
}
inline ::google::protobuf::uint32 CleanerChatReplyMessage::requestid() const {
  // @@protoc_insertion_point(field_get:CleanerChatReplyMessage.requestId)
  return requestid_;
}
inline void CleanerChatReplyMessage::set_requestid(::google::protobuf::uint32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:CleanerChatReplyMessage.requestId)
}

// required .CleanerChatType cleanerChatType = 2;
inline bool CleanerChatReplyMessage::has_cleanerchattype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CleanerChatReplyMessage::set_has_cleanerchattype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CleanerChatReplyMessage::clear_has_cleanerchattype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CleanerChatReplyMessage::clear_cleanerchattype() {
  cleanerchattype_ = 0;
  clear_has_cleanerchattype();
}
inline ::CleanerChatType CleanerChatReplyMessage::cleanerchattype() const {
  // @@protoc_insertion_point(field_get:CleanerChatReplyMessage.cleanerChatType)
  return static_cast< ::CleanerChatType >(cleanerchattype_);
}
inline void CleanerChatReplyMessage::set_cleanerchattype(::CleanerChatType value) {
  assert(::CleanerChatType_IsValid(value));
  set_has_cleanerchattype();
  cleanerchattype_ = value;
  // @@protoc_insertion_point(field_set:CleanerChatReplyMessage.cleanerChatType)
}

// optional uint32 gameId = 3 [default = 0];
inline bool CleanerChatReplyMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CleanerChatReplyMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CleanerChatReplyMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CleanerChatReplyMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 CleanerChatReplyMessage::gameid() const {
  // @@protoc_insertion_point(field_get:CleanerChatReplyMessage.gameId)
  return gameid_;
}
inline void CleanerChatReplyMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:CleanerChatReplyMessage.gameId)
}

// required uint32 playerId = 4;
inline bool CleanerChatReplyMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CleanerChatReplyMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CleanerChatReplyMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CleanerChatReplyMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 CleanerChatReplyMessage::playerid() const {
  // @@protoc_insertion_point(field_get:CleanerChatReplyMessage.playerId)
  return playerid_;
}
inline void CleanerChatReplyMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:CleanerChatReplyMessage.playerId)
}

// required .CleanerChatReplyMessage.CleanerActionType cleanerActionType = 5;
inline bool CleanerChatReplyMessage::has_cleaneractiontype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CleanerChatReplyMessage::set_has_cleaneractiontype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CleanerChatReplyMessage::clear_has_cleaneractiontype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CleanerChatReplyMessage::clear_cleaneractiontype() {
  cleaneractiontype_ = 0;
  clear_has_cleaneractiontype();
}
inline ::CleanerChatReplyMessage_CleanerActionType CleanerChatReplyMessage::cleaneractiontype() const {
  // @@protoc_insertion_point(field_get:CleanerChatReplyMessage.cleanerActionType)
  return static_cast< ::CleanerChatReplyMessage_CleanerActionType >(cleaneractiontype_);
}
inline void CleanerChatReplyMessage::set_cleaneractiontype(::CleanerChatReplyMessage_CleanerActionType value) {
  assert(::CleanerChatReplyMessage_CleanerActionType_IsValid(value));
  set_has_cleaneractiontype();
  cleaneractiontype_ = value;
  // @@protoc_insertion_point(field_set:CleanerChatReplyMessage.cleanerActionType)
}

// optional string cleanerText = 6 [default = ""];
inline bool CleanerChatReplyMessage::has_cleanertext() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CleanerChatReplyMessage::set_has_cleanertext() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CleanerChatReplyMessage::clear_has_cleanertext() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CleanerChatReplyMessage::clear_cleanertext() {
  if (cleanertext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cleanertext_->clear();
  }
  clear_has_cleanertext();
}
inline const ::std::string& CleanerChatReplyMessage::cleanertext() const {
  // @@protoc_insertion_point(field_get:CleanerChatReplyMessage.cleanerText)
  return *cleanertext_;
}
inline void CleanerChatReplyMessage::set_cleanertext(const ::std::string& value) {
  set_has_cleanertext();
  if (cleanertext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cleanertext_ = new ::std::string;
  }
  cleanertext_->assign(value);
  // @@protoc_insertion_point(field_set:CleanerChatReplyMessage.cleanerText)
}
inline void CleanerChatReplyMessage::set_cleanertext(const char* value) {
  set_has_cleanertext();
  if (cleanertext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cleanertext_ = new ::std::string;
  }
  cleanertext_->assign(value);
  // @@protoc_insertion_point(field_set_char:CleanerChatReplyMessage.cleanerText)
}
inline void CleanerChatReplyMessage::set_cleanertext(const char* value, size_t size) {
  set_has_cleanertext();
  if (cleanertext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cleanertext_ = new ::std::string;
  }
  cleanertext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CleanerChatReplyMessage.cleanerText)
}
inline ::std::string* CleanerChatReplyMessage::mutable_cleanertext() {
  set_has_cleanertext();
  if (cleanertext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cleanertext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CleanerChatReplyMessage.cleanerText)
  return cleanertext_;
}
inline ::std::string* CleanerChatReplyMessage::release_cleanertext() {
  clear_has_cleanertext();
  if (cleanertext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cleanertext_;
    cleanertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CleanerChatReplyMessage::set_allocated_cleanertext(::std::string* cleanertext) {
  if (cleanertext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cleanertext_;
  }
  if (cleanertext) {
    set_has_cleanertext();
    cleanertext_ = cleanertext;
  } else {
    clear_has_cleanertext();
    cleanertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CleanerChatReplyMessage.cleanerText)
}

// -------------------------------------------------------------------

// ChatCleanerMessage

// required .ChatCleanerMessage.ChatCleanerMessageType messageType = 1;
inline bool ChatCleanerMessage::has_messagetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatCleanerMessage::set_has_messagetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatCleanerMessage::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatCleanerMessage::clear_messagetype() {
  messagetype_ = 1;
  clear_has_messagetype();
}
inline ::ChatCleanerMessage_ChatCleanerMessageType ChatCleanerMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:ChatCleanerMessage.messageType)
  return static_cast< ::ChatCleanerMessage_ChatCleanerMessageType >(messagetype_);
}
inline void ChatCleanerMessage::set_messagetype(::ChatCleanerMessage_ChatCleanerMessageType value) {
  assert(::ChatCleanerMessage_ChatCleanerMessageType_IsValid(value));
  set_has_messagetype();
  messagetype_ = value;
  // @@protoc_insertion_point(field_set:ChatCleanerMessage.messageType)
}

// optional .CleanerInitMessage cleanerInitMessage = 2;
inline bool ChatCleanerMessage::has_cleanerinitmessage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatCleanerMessage::set_has_cleanerinitmessage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatCleanerMessage::clear_has_cleanerinitmessage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatCleanerMessage::clear_cleanerinitmessage() {
  if (cleanerinitmessage_ != NULL) cleanerinitmessage_->::CleanerInitMessage::Clear();
  clear_has_cleanerinitmessage();
}
inline const ::CleanerInitMessage& ChatCleanerMessage::cleanerinitmessage() const {
  // @@protoc_insertion_point(field_get:ChatCleanerMessage.cleanerInitMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cleanerinitmessage_ != NULL ? *cleanerinitmessage_ : *default_instance().cleanerinitmessage_;
#else
  return cleanerinitmessage_ != NULL ? *cleanerinitmessage_ : *default_instance_->cleanerinitmessage_;
#endif
}
inline ::CleanerInitMessage* ChatCleanerMessage::mutable_cleanerinitmessage() {
  set_has_cleanerinitmessage();
  if (cleanerinitmessage_ == NULL) cleanerinitmessage_ = new ::CleanerInitMessage;
  // @@protoc_insertion_point(field_mutable:ChatCleanerMessage.cleanerInitMessage)
  return cleanerinitmessage_;
}
inline ::CleanerInitMessage* ChatCleanerMessage::release_cleanerinitmessage() {
  clear_has_cleanerinitmessage();
  ::CleanerInitMessage* temp = cleanerinitmessage_;
  cleanerinitmessage_ = NULL;
  return temp;
}
inline void ChatCleanerMessage::set_allocated_cleanerinitmessage(::CleanerInitMessage* cleanerinitmessage) {
  delete cleanerinitmessage_;
  cleanerinitmessage_ = cleanerinitmessage;
  if (cleanerinitmessage) {
    set_has_cleanerinitmessage();
  } else {
    clear_has_cleanerinitmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:ChatCleanerMessage.cleanerInitMessage)
}

// optional .CleanerInitAckMessage cleanerInitAckMessage = 3;
inline bool ChatCleanerMessage::has_cleanerinitackmessage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatCleanerMessage::set_has_cleanerinitackmessage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatCleanerMessage::clear_has_cleanerinitackmessage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatCleanerMessage::clear_cleanerinitackmessage() {
  if (cleanerinitackmessage_ != NULL) cleanerinitackmessage_->::CleanerInitAckMessage::Clear();
  clear_has_cleanerinitackmessage();
}
inline const ::CleanerInitAckMessage& ChatCleanerMessage::cleanerinitackmessage() const {
  // @@protoc_insertion_point(field_get:ChatCleanerMessage.cleanerInitAckMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cleanerinitackmessage_ != NULL ? *cleanerinitackmessage_ : *default_instance().cleanerinitackmessage_;
#else
  return cleanerinitackmessage_ != NULL ? *cleanerinitackmessage_ : *default_instance_->cleanerinitackmessage_;
#endif
}
inline ::CleanerInitAckMessage* ChatCleanerMessage::mutable_cleanerinitackmessage() {
  set_has_cleanerinitackmessage();
  if (cleanerinitackmessage_ == NULL) cleanerinitackmessage_ = new ::CleanerInitAckMessage;
  // @@protoc_insertion_point(field_mutable:ChatCleanerMessage.cleanerInitAckMessage)
  return cleanerinitackmessage_;
}
inline ::CleanerInitAckMessage* ChatCleanerMessage::release_cleanerinitackmessage() {
  clear_has_cleanerinitackmessage();
  ::CleanerInitAckMessage* temp = cleanerinitackmessage_;
  cleanerinitackmessage_ = NULL;
  return temp;
}
inline void ChatCleanerMessage::set_allocated_cleanerinitackmessage(::CleanerInitAckMessage* cleanerinitackmessage) {
  delete cleanerinitackmessage_;
  cleanerinitackmessage_ = cleanerinitackmessage;
  if (cleanerinitackmessage) {
    set_has_cleanerinitackmessage();
  } else {
    clear_has_cleanerinitackmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:ChatCleanerMessage.cleanerInitAckMessage)
}

// optional .CleanerChatRequestMessage cleanerChatRequestMessage = 4;
inline bool ChatCleanerMessage::has_cleanerchatrequestmessage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChatCleanerMessage::set_has_cleanerchatrequestmessage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChatCleanerMessage::clear_has_cleanerchatrequestmessage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChatCleanerMessage::clear_cleanerchatrequestmessage() {
  if (cleanerchatrequestmessage_ != NULL) cleanerchatrequestmessage_->::CleanerChatRequestMessage::Clear();
  clear_has_cleanerchatrequestmessage();
}
inline const ::CleanerChatRequestMessage& ChatCleanerMessage::cleanerchatrequestmessage() const {
  // @@protoc_insertion_point(field_get:ChatCleanerMessage.cleanerChatRequestMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cleanerchatrequestmessage_ != NULL ? *cleanerchatrequestmessage_ : *default_instance().cleanerchatrequestmessage_;
#else
  return cleanerchatrequestmessage_ != NULL ? *cleanerchatrequestmessage_ : *default_instance_->cleanerchatrequestmessage_;
#endif
}
inline ::CleanerChatRequestMessage* ChatCleanerMessage::mutable_cleanerchatrequestmessage() {
  set_has_cleanerchatrequestmessage();
  if (cleanerchatrequestmessage_ == NULL) cleanerchatrequestmessage_ = new ::CleanerChatRequestMessage;
  // @@protoc_insertion_point(field_mutable:ChatCleanerMessage.cleanerChatRequestMessage)
  return cleanerchatrequestmessage_;
}
inline ::CleanerChatRequestMessage* ChatCleanerMessage::release_cleanerchatrequestmessage() {
  clear_has_cleanerchatrequestmessage();
  ::CleanerChatRequestMessage* temp = cleanerchatrequestmessage_;
  cleanerchatrequestmessage_ = NULL;
  return temp;
}
inline void ChatCleanerMessage::set_allocated_cleanerchatrequestmessage(::CleanerChatRequestMessage* cleanerchatrequestmessage) {
  delete cleanerchatrequestmessage_;
  cleanerchatrequestmessage_ = cleanerchatrequestmessage;
  if (cleanerchatrequestmessage) {
    set_has_cleanerchatrequestmessage();
  } else {
    clear_has_cleanerchatrequestmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:ChatCleanerMessage.cleanerChatRequestMessage)
}

// optional .CleanerChatReplyMessage cleanerChatReplyMessage = 5;
inline bool ChatCleanerMessage::has_cleanerchatreplymessage() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChatCleanerMessage::set_has_cleanerchatreplymessage() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChatCleanerMessage::clear_has_cleanerchatreplymessage() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChatCleanerMessage::clear_cleanerchatreplymessage() {
  if (cleanerchatreplymessage_ != NULL) cleanerchatreplymessage_->::CleanerChatReplyMessage::Clear();
  clear_has_cleanerchatreplymessage();
}
inline const ::CleanerChatReplyMessage& ChatCleanerMessage::cleanerchatreplymessage() const {
  // @@protoc_insertion_point(field_get:ChatCleanerMessage.cleanerChatReplyMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cleanerchatreplymessage_ != NULL ? *cleanerchatreplymessage_ : *default_instance().cleanerchatreplymessage_;
#else
  return cleanerchatreplymessage_ != NULL ? *cleanerchatreplymessage_ : *default_instance_->cleanerchatreplymessage_;
#endif
}
inline ::CleanerChatReplyMessage* ChatCleanerMessage::mutable_cleanerchatreplymessage() {
  set_has_cleanerchatreplymessage();
  if (cleanerchatreplymessage_ == NULL) cleanerchatreplymessage_ = new ::CleanerChatReplyMessage;
  // @@protoc_insertion_point(field_mutable:ChatCleanerMessage.cleanerChatReplyMessage)
  return cleanerchatreplymessage_;
}
inline ::CleanerChatReplyMessage* ChatCleanerMessage::release_cleanerchatreplymessage() {
  clear_has_cleanerchatreplymessage();
  ::CleanerChatReplyMessage* temp = cleanerchatreplymessage_;
  cleanerchatreplymessage_ = NULL;
  return temp;
}
inline void ChatCleanerMessage::set_allocated_cleanerchatreplymessage(::CleanerChatReplyMessage* cleanerchatreplymessage) {
  delete cleanerchatreplymessage_;
  cleanerchatreplymessage_ = cleanerchatreplymessage;
  if (cleanerchatreplymessage) {
    set_has_cleanerchatreplymessage();
  } else {
    clear_has_cleanerchatreplymessage();
  }
  // @@protoc_insertion_point(field_set_allocated:ChatCleanerMessage.cleanerChatReplyMessage)
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_chatcleaner_2eproto__INCLUDED
